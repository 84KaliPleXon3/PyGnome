// Generated by CoffeeScript 2.0.0-beta1
//@ sourceMappingURL=/static/js/lib/rivets.js.map')
void function () {
  var bindEvent, getInputValue, Rivets, rivets, unbindEvent;
  Rivets = {};
  if (!String.prototype.trim)
    String.prototype.trim = function () {
      return this.replace(/^\s+|\s+$/g, '');
    };
  Rivets.Binding = function () {
    function Binding(param$, param$1, param$2, param$3, param$4) {
      var identifier, instance$, regexp, value;
      instance$ = this;
      this.unbind = function () {
        return Binding.prototype.unbind.apply(instance$, arguments);
      };
      this.bind = function () {
        return Binding.prototype.bind.apply(instance$, arguments);
      };
      this.publish = function () {
        return Binding.prototype.publish.apply(instance$, arguments);
      };
      this.sync = function () {
        return Binding.prototype.sync.apply(instance$, arguments);
      };
      this.set = function (a) {
        return Binding.prototype.set.apply(instance$, arguments);
      };
      this.formattedValue = function (a) {
        return Binding.prototype.formattedValue.apply(instance$, arguments);
      };
      this.el = param$;
      this.type = param$1;
      this.model = param$2;
      this.keypath = param$3;
      this.options = param$4;
      if (null == this.options)
        this.options = {};
      if (!(this.binder = Rivets.binders[type]))
        for (identifier in Rivets.binders) {
          value = Rivets.binders[identifier];
          if (identifier !== '*' && identifier.indexOf('*') !== -1) {
            regexp = new RegExp('^' + identifier.replace('*', '.+') + '$');
            if (regexp.test(type)) {
              this.binder = value;
              this.args = new RegExp('^' + identifier.replace('*', '(.+)') + '$').exec(type);
              this.args.shift();
            }
          }
        }
      this.binder || (this.binder = Rivets.binders['*']);
      if (this.binder instanceof Function)
        this.binder = { routine: this.binder };
      this.formatters = this.options.formatters || [];
    }
    Binding.prototype.formattedValue = function (value) {
      var args, formatter, id;
      for (var i$ = 0, length$ = this.formatters.length; i$ < length$; ++i$) {
        formatter = this.formatters[i$];
        args = formatter.split(/\s+/);
        id = args.shift();
        formatter = this.model[id] instanceof Function ? this.model[id] : Rivets.formatters[id];
        if ((null != formatter ? formatter.read : void 0) instanceof Function) {
          value = formatter.read.apply(formatter, [value].concat([].slice.call(args)));
        } else if (formatter instanceof Function) {
          value = formatter.apply(null, [value].concat([].slice.call(args)));
        }
      }
      return value;
    };
    Binding.prototype.set = function (value) {
      value = value instanceof Function && !this.binder['function'] ? this.formattedValue(value.call(this.model)) : this.formattedValue(value);
      if (null != this.binder.routine)
        return this.binder.routine.call(this, this.el, value);
    };
    Binding.prototype.sync = function () {
      return this.set(this.options.bypass ? this.model[this.keypath] : Rivets.config.adapter.read(this.model, this.keypath));
    };
    Binding.prototype.publish = function () {
      var args, formatter, id, value;
      value = getInputValue(this.el);
      for (var cache$ = this.formatters.slice(0).reverse(), i$ = 0, length$ = cache$.length; i$ < length$; ++i$) {
        formatter = cache$[i$];
        args = formatter.split(/\s+/);
        id = args.shift();
        if (null != Rivets.formatters[id] ? Rivets.formatters[id].publish : void 0)
          value = Rivets.formatters[id].publish.apply(Rivets.formatters[id], [value].concat([].slice.call(args)));
      }
      return Rivets.config.adapter.publish(this.model, this.keypath, value);
    };
    Binding.prototype.bind = function () {
      if (null != this.binder.bind)
        this.binder.bind.call(this, this.el);
      if (this.options.bypass) {
        this.sync();
      } else {
        Rivets.config.adapter.subscribe(this.model, this.keypath, this.sync);
        if (Rivets.config.preloadData)
          this.sync();
      }
      if (null != this.options.dependencies ? this.options.dependencies.length : void 0)
        return function (accum$) {
          var dependency, keypath, model;
          for (var i$ = 0, length$ = this.options.dependencies.length; i$ < length$; ++i$) {
            dependency = this.options.dependencies[i$];
            if (/^\./.test(dependency)) {
              model = this.model;
              keypath = dependency.substr(1);
            } else {
              dependency = dependency.split('.');
              model = this.view.models[dependency.shift()];
              keypath = dependency.join('.');
            }
            accum$.push(Rivets.config.adapter.subscribe(model, keypath, this.sync));
          }
          return accum$;
        }.call(this, []);
    };
    Binding.prototype.unbind = function () {
      if (null != this.binder.unbind)
        this.binder.unbind.call(this, this.el);
      if (!this.options.bypass)
        Rivets.config.adapter.unsubscribe(this.model, this.keypath, this.sync);
      if (null != this.options.dependencies ? this.options.dependencies.length : void 0)
        return function (accum$) {
          var dependency, keypath, model;
          for (var i$ = 0, length$ = this.options.dependencies.length; i$ < length$; ++i$) {
            dependency = this.options.dependencies[i$];
            if (/^\./.test(dependency)) {
              model = this.model;
              keypath = dependency.substr(1);
            } else {
              dependency = dependency.split('.');
              model = this.view.models[dependency.shift()];
              keypath = dependency.join('.');
            }
            accum$.push(Rivets.config.adapter.unsubscribe(model, keypath, this.sync));
          }
          return accum$;
        }.call(this, []);
    };
    return Binding;
  }();
  Rivets.View = function () {
    function View(param$, param$1) {
      var instance$;
      instance$ = this;
      this.publish = function () {
        return View.prototype.publish.apply(instance$, arguments);
      };
      this.sync = function () {
        return View.prototype.sync.apply(instance$, arguments);
      };
      this.unbind = function () {
        return View.prototype.unbind.apply(instance$, arguments);
      };
      this.bind = function () {
        return View.prototype.bind.apply(instance$, arguments);
      };
      this.select = function (a) {
        return View.prototype.select.apply(instance$, arguments);
      };
      this.build = function () {
        return View.prototype.build.apply(instance$, arguments);
      };
      this.bindingRegExp = function () {
        return View.prototype.bindingRegExp.apply(instance$, arguments);
      };
      this.els = param$;
      this.models = param$1;
      if (!(this.els.jquery || this.els instanceof Array))
        this.els = [this.els];
      this.build();
    }
    View.prototype.bindingRegExp = function () {
      var prefix;
      prefix = Rivets.config.prefix;
      if (prefix) {
        return new RegExp('^data-' + prefix + '-');
      } else {
        return /^data-/;
      }
    };
    View.prototype.build = function () {
      var bindingRegExp, el, node, parse, skipNodes, this$;
      this.bindings = [];
      skipNodes = [];
      bindingRegExp = this.bindingRegExp();
      parse = (this$ = this, function (node) {
        var attribute, attributes, binder, binding, context, dependencies, identifier, keypath, model, n, options, path, pipes, regexp, splitPath, type, value;
        if (!in$(node, skipNodes)) {
          for (var i$ = 0, length$ = node.attributes.length; i$ < length$; ++i$) {
            attribute = node.attributes[i$];
            if (bindingRegExp.test(attribute.name)) {
              type = attribute.name.replace(bindingRegExp, '');
              if (!(binder = Rivets.binders[type]))
                for (identifier in Rivets.binders) {
                  value = Rivets.binders[identifier];
                  if (identifier !== '*' && identifier.indexOf('*') !== -1) {
                    regexp = new RegExp('^' + identifier.replace('*', '.+') + '$');
                    if (regexp.test(type))
                      binder = value;
                  }
                }
              binder || (binder = Rivets.binders['*']);
              if (binder.block) {
                for (var cache$ = node.getElementsByTagName('*'), i$1 = 0, length$1 = cache$.length; i$1 < length$1; ++i$1) {
                  n = cache$[i$1];
                  skipNodes.push(n);
                }
                attributes = [attribute];
              }
            }
          }
          for (var i$2 = 0, length$2 = (attributes || node.attributes).length; i$2 < length$2; ++i$2) {
            attribute = (attributes || node.attributes)[i$2];
            if (bindingRegExp.test(attribute.name)) {
              options = {};
              type = attribute.name.replace(bindingRegExp, '');
              pipes = function (accum$) {
                var pipe;
                for (var cache$1 = attribute.value.split('|'), i$3 = 0, length$3 = cache$1.length; i$3 < length$3; ++i$3) {
                  pipe = cache$1[i$3];
                  accum$.push(pipe.trim());
                }
                return accum$;
              }.call(this$, []);
              context = function (accum$) {
                var ctx;
                for (var cache$1 = pipes.shift().split('<'), i$3 = 0, length$3 = cache$1.length; i$3 < length$3; ++i$3) {
                  ctx = cache$1[i$3];
                  accum$.push(ctx.trim());
                }
                return accum$;
              }.call(this$, []);
              path = context.shift();
              splitPath = path.split(/\.|:/);
              options.formatters = pipes;
              options.bypass = path.indexOf(':') !== -1;
              if (splitPath[0]) {
                model = this$.models[splitPath.shift()];
              } else {
                model = this$.models;
                splitPath.shift();
              }
              keypath = splitPath.join('.');
              if (model) {
                if (dependencies = context.shift())
                  options.dependencies = dependencies.split(/\s+/);
                binding = new Rivets.Binding(node, type, model, keypath, options);
                binding.view = this$;
                this$.bindings.push(binding);
              }
            }
          }
          if (attributes)
            attributes = null;
        }
      });
      for (var i$ = 0, length$ = this.els.length; i$ < length$; ++i$) {
        el = this.els[i$];
        parse(el);
        for (var cache$ = el.getElementsByTagName('*'), i$1 = 0, length$1 = cache$.length; i$1 < length$1; ++i$1) {
          node = cache$[i$1];
          if (!(null != node.attributes))
            continue;
          parse(node);
        }
      }
    };
    View.prototype.select = function (fn) {
      return function (accum$) {
        var binding;
        for (var i$ = 0, length$ = this.bindings.length; i$ < length$; ++i$) {
          binding = this.bindings[i$];
          if (!fn(binding))
            continue;
          accum$.push(binding);
        }
        return accum$;
      }.call(this, []);
    };
    View.prototype.bind = function () {
      return function (accum$) {
        var binding;
        for (var i$ = 0, length$ = this.bindings.length; i$ < length$; ++i$) {
          binding = this.bindings[i$];
          accum$.push(binding.bind());
        }
        return accum$;
      }.call(this, []);
    };
    View.prototype.unbind = function () {
      return function (accum$) {
        var binding;
        for (var i$ = 0, length$ = this.bindings.length; i$ < length$; ++i$) {
          binding = this.bindings[i$];
          accum$.push(binding.unbind());
        }
        return accum$;
      }.call(this, []);
    };
    View.prototype.sync = function () {
      return function (accum$) {
        var binding;
        for (var i$ = 0, length$ = this.bindings.length; i$ < length$; ++i$) {
          binding = this.bindings[i$];
          accum$.push(binding.sync());
        }
        return accum$;
      }.call(this, []);
    };
    View.prototype.publish = function () {
      return function (accum$) {
        var binding;
        for (var cache$ = this.select(function (b) {
              return b.binder.publishes;
            }), i$ = 0, length$ = cache$.length; i$ < length$; ++i$) {
          binding = cache$[i$];
          accum$.push(binding.publish());
        }
        return accum$;
      }.call(this, []);
    };
    return View;
  }();
  bindEvent = function (el, event, handler, context) {
    var fn;
    fn = function (e) {
      return handler.call(context, e);
    };
    if (null != window.jQuery) {
      el = jQuery(el);
      if (null != el.on) {
        el.on(event, fn);
      } else {
        el.bind(event, fn);
      }
    } else if (null != window.addEventListener) {
      el.addEventListener(event, fn, false);
    } else {
      event = 'on' + event;
      el.attachEvent(event, fn);
    }
    return fn;
  };
  unbindEvent = function (el, event, fn) {
    if (null != window.jQuery) {
      el = jQuery(el);
      if (null != el.off) {
        return el.off(event, fn);
      } else {
        return el.unbind(event, fn);
      }
    } else if (window.removeEventListener) {
      return el.removeEventListener(event, fn, false);
    } else {
      event = 'on' + event;
      return el.detachEvent(event, fn);
    }
  };
  getInputValue = function (el) {
    switch (el.type) {
    case 'checkbox':
      return el.checked;
    case 'select-multiple':
      return function (accum$) {
        var o;
        for (var i$ = 0, length$ = el.length; i$ < length$; ++i$) {
          o = el[i$];
          if (!o.selected)
            continue;
          accum$.push(o.value);
        }
        return accum$;
      }.call(this, []);
    default:
      return el.value;
    }
  };
  Rivets.binders = {
    enabled: function (el, value) {
      return el.disabled = !value;
    },
    disabled: function (el, value) {
      return el.disabled = !!value;
    },
    checked: {
      publishes: true,
      bind: function (el) {
        return this.currentListener = bindEvent(el, 'change', this.publish);
      },
      unbind: function (el) {
        return unbindEvent(el, 'change', this.currentListener);
      },
      routine: function (el, value) {
        if (el.type === 'radio') {
          return el.checked = el.value === value;
        } else {
          return el.checked = !!value;
        }
      }
    },
    unchecked: {
      publishes: true,
      bind: function (el) {
        return this.currentListener = bindEvent(el, 'change', this.publish);
      },
      unbind: function (el) {
        return unbindEvent(el, 'change', this.currentListener);
      },
      routine: function (el, value) {
        if (el.type === 'radio') {
          return el.checked = el.value !== value;
        } else {
          return el.checked = !value;
        }
      }
    },
    show: function (el, value) {
      return el.style.display = value ? '' : 'none';
    },
    hide: function (el, value) {
      return el.style.display = value ? 'none' : '';
    },
    html: function (el, value) {
      return el.innerHTML = null != value ? value : '';
    },
    value: {
      publishes: true,
      bind: function (el) {
        return this.currentListener = bindEvent(el, 'change', this.publish);
      },
      unbind: function (el) {
        return unbindEvent(el, 'change', this.currentListener);
      },
      routine: function (el, value) {
        if (el.type === 'select-multiple') {
          if (null != value) {
            return function (accum$) {
              var o;
              for (var i$ = 0, length$ = el.length; i$ < length$; ++i$) {
                o = el[i$];
                accum$.push(o.selected = in$(o.value, value));
              }
              return accum$;
            }.call(this, []);
          }
        } else {
          return el.value = null != value ? value : '';
        }
      }
    },
    text: function (el, value) {
      if (null != el.innerText) {
        return el.innerText = null != value ? value : '';
      } else {
        return el.textContent = null != value ? value : '';
      }
    },
    'on-*': {
      'function': true,
      routine: function (el, value) {
        if (this.currentListener)
          unbindEvent(el, this.args[0], this.currentListener);
        return this.currentListener = bindEvent(el, this.args[0], value, this.model);
      }
    },
    'each-*': {
      block: true,
      bind: function (el, collection) {
        return el.removeAttribute([
          'data',
          rivets.config.prefix,
          this.type
        ].join('-').replace('--', '-'));
      },
      routine: function (el, collection) {
        var e, view;
        if (null != this.iterated) {
          for (var i$ = 0, length$ = this.iterated.length; i$ < length$; ++i$) {
            view = this.iterated[i$];
            view.unbind();
            for (var i$1 = 0, length$1 = view.els.length; i$1 < length$1; ++i$1) {
              e = view.els[i$1];
              e.parentNode.removeChild(e);
            }
          }
        } else {
          this.marker = document.createComment(' rivets: ' + this.type + ' ');
          el.parentNode.insertBefore(this.marker, el);
          el.parentNode.removeChild(el);
        }
        this.iterated = [];
        if (collection)
          return function (accum$) {
            var data, item, itemEl, m, n, previous;
            for (var i$2 = 0, length$2 = collection.length; i$2 < length$2; ++i$2) {
              item = collection[i$2];
              data = {};
              for (n in this.view.models) {
                m = this.view.models[n];
                data[n] = m;
              }
              data[this.args[0]] = item;
              itemEl = el.cloneNode(true);
              if (this.iterated.length > 0) {
                previous = this.iterated[this.iterated.length - 1].els[0];
              } else {
                previous = this.marker;
              }
              this.marker.parentNode.insertBefore(itemEl, null != previous.nextSibling ? previous.nextSibling : null);
              accum$.push(this.iterated.push(rivets.bind(itemEl, data)));
            }
            return accum$;
          }.call(this, []);
      }
    },
    'class-*': function (el, value) {
      var elClass;
      elClass = ' ' + el.className + ' ';
      if (!value === (elClass.indexOf(' ' + this.args[0] + ' ') !== -1))
        return el.className = value ? '' + el.className + ' ' + this.args[0] : elClass.replace(' ' + this.args[0] + ' ', ' ').trim();
    },
    '*': function (el, value) {
      if (value) {
        return el.setAttribute(this.type, value);
      } else {
        return el.removeAttribute(this.type);
      }
    }
  };
  Rivets.config = { preloadData: true };
  Rivets.formatters = {};
  rivets = {
    binders: Rivets.binders,
    formatters: Rivets.formatters,
    config: Rivets.config,
    configure: function (options) {
      var property, value;
      if (null == options)
        options = {};
      for (property in options) {
        value = options[property];
        Rivets.config[property] = value;
      }
    },
    bind: function (el, models) {
      var view;
      if (null == models)
        models = {};
      view = new Rivets.View(el, models);
      view.bind();
      return view;
    }
  };
  if ('undefined' !== typeof module && null != module) {
    module.exports = rivets;
  } else {
    this.rivets = rivets;
  }
  function in$(member, list) {
    for (var i = 0, length = list.length; i < length; ++i)
      if (i in list && list[i] === member)
        return true;
    return false;
  }
}.call(this);
