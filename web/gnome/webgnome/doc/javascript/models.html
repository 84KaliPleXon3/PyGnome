<!DOCTYPE html>

<html>
<head>
  <title>models.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>models.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>
define([
    <span class="string">'jquery'</span>,
    <span class="string">'lib/underscore'</span>,
    <span class="string">'lib/backbone'</span>,
    <span class="string">'util'</span>,
    <span class="string">'lib/jsv/environments'</span>,
    <span class="string">'lib/jsv/jsv'</span>
], <span class="keyword">function</span>($, _, Backbone, util) {

     <span class="function"><span class="keyword">function</span> <span class="title">prependWithGnomeUrl</span><span class="params">()</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>A base URL is required</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">if</span> (<span class="keyword">this</span>.url === <span class="literal">undefined</span>) {
            <span class="keyword">return</span>;
        }

        <span class="keyword">if</span> (<span class="keyword">this</span>.url === Backbone.Model.prototype.url || Backbone.Collection.prototype.url) {
            <span class="keyword">return</span>;
        }

        <span class="keyword">var</span> url = <span class="keyword">this</span>.url;

        <span class="keyword">if</span> (<span class="keyword">this</span>.url <span class="keyword">instanceof</span> Function) {
            url = <span class="keyword">this</span>.url();
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>URL is already prefixed, probably through a BaseCollection</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">if</span> (url.search(<span class="keyword">this</span>.gnomeModel.url()) === <span class="number">0</span>) {
            <span class="keyword">return</span>;
        }

        <span class="keyword">this</span>.url = <span class="keyword">function</span>() {</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>Model URLs should begin with a forward-slash</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="keyword">return</span> <span class="keyword">this</span>.gnomeModel.url() + url;
        }
    }


    <span class="keyword">var</span> BaseModel = Backbone.Model.extend({
        <span class="comment">/*
         Add an array of field names here that should be converted to strings
         during `toJSON` calls and to `moment` objects during `get` calls.
         */</span>
        dateFields: <span class="literal">null</span>,

        schema: <span class="literal">null</span>,

        initialize: <span class="keyword">function</span>(attrs, opts) {
            <span class="keyword">this</span>.dirty = <span class="literal">false</span>;
            <span class="keyword">this</span>.bind(<span class="string">'change'</span>, <span class="keyword">this</span>.change, <span class="keyword">this</span>);
            <span class="keyword">this</span>.bind(<span class="string">'change:id'</span>, <span class="keyword">this</span>.onIndexChange, <span class="keyword">this</span>);

            BaseModel.__super__.initialize.apply(<span class="keyword">this</span>, arguments);

            <span class="keyword">if</span> (opts &amp;&amp; opts.gnomeModel) {
                <span class="keyword">this</span>.gnomeModel = opts.gnomeModel;
                prependWithGnomeUrl.call(<span class="keyword">this</span>);
            }
        },</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>Allow only empty or schema-compliant attributes</p>
<p>Inspired by:
     <a href="https://github.com/salsita/backbone-schema/blob/master/lib/backbone-schema.js#L41">https://github.com/salsita/backbone-schema/blob/master/lib/backbone-schema.js#L41</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        validate: <span class="keyword">function</span>(attrs) {
            <span class="keyword">if</span> (!<span class="keyword">this</span>.schema) {
                <span class="keyword">return</span> <span class="literal">null</span>;
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>JSV defaults to JSON Schema draft 3 by default.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="keyword">var</span> env = JSV.createEnvironment();</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>Resulting model consists of attributes we already have set and
the attributes provided as argument to this function (merged).
When an attribute is <code>unset</code>, it is passed in <code>attrs</code> object,
the attribute has special value of <code>undefined</code>. To learn how the
resulting object will look like, we need to:
+ merge the already-set attributes with the new ones, and
+ remove the attributes that are to be unset.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="keyword">var</span> obj = _.extend({}, <span class="keyword">this</span>.attributes, attrs);

            <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> obj) {
                <span class="keyword">if</span> (obj.hasOwnProperty(key)) {
                    <span class="keyword">if</span> (<span class="string">'undefined'</span> === <span class="keyword">typeof</span> obj[key]) {
                        <span class="keyword">delete</span> obj[key];
                    }
                }
            }

            <span class="keyword">if</span> (_.isEmpty(obj)) {
                <span class="keyword">return</span>;
            }

            obj = <span class="keyword">this</span>.jsonify(obj);
            <span class="keyword">var</span> r = env.validate(obj, <span class="keyword">this</span>.schema);

            <span class="keyword">if</span> (!r.errors.length) {
                <span class="keyword">return</span> <span class="literal">null</span>;
            }

            <span class="keyword">var</span> errors = [];

            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; r.errors.length; i++) {
                <span class="keyword">var</span> error = r.errors[i];
                errors.push(<span class="keyword">this</span>.formatSchemaError(error));
            }

            <span class="keyword">return</span> errors;
        },

        schemaErrorDescriptionTemplates: {
            <span class="string">'type'</span>: <span class="string">'Value should be a {{-error.details}}'</span>,
            <span class="string">'type_many'</span>: <span class="string">'Value should be one of these types: {{-error.details}}'</span>,
            <span class="string">'minimum'</span>: <span class="string">'Value should be at least: {{-error.details}}'</span>,
            <span class="string">'maximum'</span>: <span class="string">'Value should be at most: {{-error.details}}'</span>
        },

        <span class="comment">/*
         Format a JSON Schema error generated by JSV `error` with a description
         that we can show directly to a user.
         */</span>
        formatSchemaError: <span class="keyword">function</span>(error) {
            <span class="keyword">var</span> uriParts = error.uri.split(<span class="string">'/'</span>);
            <span class="keyword">var</span> description = error.message;
            <span class="keyword">var</span> attribute = error.attribute;

            <span class="keyword">if</span> (attribute == <span class="string">'type'</span> &amp;&amp; error.details.length &gt; <span class="number">1</span>) {
                attribute = <span class="string">'type_many'</span>;
            }

            <span class="keyword">var</span> template = <span class="keyword">this</span>.schemaErrorDescriptionTemplates[attribute];

            <span class="keyword">if</span> (template) {
                template = _.template(template);
                description = template({error: error});
            }

            <span class="keyword">return</span> {
                description: description,</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>Field name is the last part of the URI</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                name: uriParts[uriParts.length - <span class="number">1</span>]
            }
        },

        onIndexChange: <span class="keyword">function</span>() {
            <span class="keyword">if</span> (<span class="keyword">this</span>.collection &amp;&amp; <span class="keyword">this</span>.collection.comparator) {
                <span class="keyword">this</span>.collection.sort({silent: <span class="literal">true</span>});
            }
        },

        <span class="comment">/*
         Keep an array field on the model in sync with a field that represents
         one item in the array.

         E.g. given a `start_position` field that is an array, the model might
         have a `start_position_x` field that we use for easier data binding
         in views. The following usage of `syncArrayField` will keep
         `start_position` up to date with the latest value of `start_position_x`:
         at index 0 and vice versa.

                syncArrayField('start_position', 'start_position_x', 0);
         */</span>
        syncArrayField: <span class="keyword">function</span>(arrayFieldName, arrayItemFieldName, index) {

            <span class="function"><span class="keyword">function</span> <span class="title">setArrayField</span><span class="params">(model)</span> {</span>
                <span class="keyword">var</span> arrayField = model.get(arrayFieldName);
                arrayField[index] = model.get(arrayItemFieldName);
                <span class="keyword">this</span>.set(arrayFieldName, arrayField);
            }

            <span class="function"><span class="keyword">function</span> <span class="title">setArrayItemField</span><span class="params">(model)</span> {</span>
                <span class="keyword">var</span> arrayField = model.get(arrayFieldName);
                model.set(arrayItemFieldName, arrayField[index]);
            }

            <span class="keyword">this</span>.on(<span class="string">'change:'</span> + arrayItemFieldName, setArrayField);
            <span class="keyword">this</span>.on(<span class="string">'change:'</span> + arrayFieldName, setArrayItemField);

            <span class="keyword">var</span> arrayField = <span class="keyword">this</span>.get(arrayFieldName);

            <span class="keyword">if</span> (arrayField &amp;&amp; arrayField.length) {
                setArrayItemField(<span class="keyword">this</span>);
            }
        },

        change: <span class="keyword">function</span>() {
            <span class="keyword">this</span>.dirty = <span class="literal">true</span>;
        },

        save: <span class="keyword">function</span>(attrs, options) {
            options = options || {};
            <span class="keyword">var</span> _<span class="keyword">this</span> = <span class="keyword">this</span>;

            <span class="keyword">if</span> (!_.has(options, <span class="string">'wait'</span>)) {
                options.wait = <span class="literal">true</span>;
            }

            <span class="keyword">if</span> (_.has(options, <span class="string">'success'</span>)) {
                <span class="keyword">var</span> success = options.success;

                options.success = <span class="keyword">function</span>(model, response, options) {
                    _<span class="keyword">this</span>.success(model, response, options);
                    success(model, response, options);
                }
            } <span class="keyword">else</span> {
                options.success = <span class="keyword">this</span>.success;
            }

            <span class="keyword">if</span> (!_.has(options, <span class="string">'error'</span>)) {
                options.error = <span class="keyword">this</span>.error;
            }

            <span class="keyword">return</span> BaseModel.__super__.save.apply(<span class="keyword">this</span>, [attrs, options]);
        },

        success: <span class="keyword">function</span>(model, response, options) {
            model.errors = <span class="literal">null</span>;
            model.dirty = <span class="literal">false</span>;
        },

        destroy: <span class="keyword">function</span>(options) {
            options = options || {};

            <span class="keyword">if</span> (!_.has(options, <span class="string">'wait'</span>)) {
                options.wait = <span class="literal">true</span>;
            }

            BaseModel.__super__.destroy.apply(<span class="keyword">this</span>, [options]);
        },

        error: <span class="keyword">function</span>(model, response, options) {
            <span class="keyword">try</span> {
                response = $.parseJSON(response.responseText);
            } <span class="keyword">catch</span>(e) {
                response.errors = [{
                    name: <span class="string">'server'</span>,
                    description: <span class="string">'A server error prevented saving the model.'</span>
                }];
            }

            <span class="keyword">if</span> (response &amp;&amp; response.errors.length) {
                model.errors = response.errors;
                model.set(model.previousAttributes());
            }
        },

        fetch: <span class="keyword">function</span>(options) {
            options = options || {};

            <span class="keyword">if</span> (!_.has(options, <span class="string">'success'</span>)) {
                options.success = <span class="keyword">this</span>.success
            }

            <span class="keyword">return</span> BaseModel.__super__.fetch.apply(<span class="keyword">this</span>, [options]);
        },

        parse: <span class="keyword">function</span>(response) {
            <span class="keyword">var</span> message = util.parseMessage(response);
            <span class="keyword">if</span> (message) {
                <span class="keyword">this</span>.trigger(BaseModel.MESSAGE_RECEIVED, message);
            }

            <span class="keyword">var</span> data = BaseModel.__super__.parse.apply(<span class="keyword">this</span>, arguments);</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>Convert date fields from strings into <code>moment</code> objects.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="keyword">if</span> (<span class="keyword">this</span>.dateFields) {
                _.each(<span class="keyword">this</span>.dateFields, <span class="keyword">function</span>(field) {
                    <span class="keyword">if</span> (<span class="keyword">typeof</span>(data[field] === <span class="string">"string"</span>)) {
                        data[field] = moment(data[field]);
                    }
                });
            }

            <span class="keyword">return</span> data;
        },</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>Return a <code>moment</code> object for any date field.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        get: <span class="keyword">function</span>(attr) {
            <span class="keyword">var</span> val = BaseModel.__super__.get.apply(<span class="keyword">this</span>, arguments);

            <span class="keyword">if</span>(val &amp;&amp; <span class="keyword">this</span>.dateFields &amp;&amp; _.contains(<span class="keyword">this</span>.dateFields, attr)) {
                <span class="keyword">var</span> date = moment(val);
                <span class="keyword">if</span> (date &amp;&amp; date.isValid()) {
                    <span class="keyword">return</span> date;
                } <span class="keyword">else</span> {
                    <span class="keyword">return</span> val;
                }
            }

            <span class="keyword">return</span> val;
        },

        <span class="comment">/*
         Call .format() on any date fields when preparing them for JSON
         serialization.

         Included in a separate method so it can be called during validation.
         */</span>
        jsonify: <span class="keyword">function</span>(data) {
            <span class="keyword">if</span> (<span class="keyword">this</span>.dateFields) {
                _.each(<span class="keyword">this</span>.dateFields, <span class="keyword">function</span>(field) {
                    <span class="keyword">if</span> (<span class="keyword">typeof</span>(data[field]) === <span class="string">"string"</span>) {
                        <span class="keyword">return</span>;
                    }

                    <span class="keyword">if</span> (data[field]) {
                        data[field] = data[field].format();
                    }
                });
            }

            <span class="keyword">return</span> data;
        },

        toJSON: <span class="keyword">function</span>() {
            <span class="keyword">var</span> data = BaseModel.__super__.toJSON.apply(<span class="keyword">this</span>, arguments);
            <span class="keyword">return</span> <span class="keyword">this</span>.jsonify(data);
        }
    }, {
        MESSAGE_RECEIVED: <span class="string">'ajaxForm:messageReceived'</span>
    });


    <span class="keyword">var</span> BaseCollection = Backbone.Collection.extend({
        initialize: <span class="function"><span class="keyword">function</span> <span class="params">(objs, opts)</span> {</span>
            BaseCollection.__super__.initialize.apply(<span class="keyword">this</span>, arguments);

            <span class="keyword">if</span> (opts &amp;&amp; opts.gnomeModel) {
                <span class="keyword">this</span>.gnomeModel = opts.gnomeModel;
                prependWithGnomeUrl.call(<span class="keyword">this</span>);
            }
        }
    });


     <span class="comment">/*
     `TimeStep` represents a single time step of the user's actively-running
     model on the server.
     */</span>
    <span class="keyword">var</span> TimeStep = BaseModel.extend({
        url: <span class="keyword">function</span>() {
            <span class="keyword">return</span> <span class="string">'/step/'</span> + <span class="keyword">this</span>.id;
        },

        get: <span class="keyword">function</span>(attr) {
            <span class="keyword">var</span> value = Backbone.Model.prototype.get.call(<span class="keyword">this</span>, attr);

            <span class="keyword">if</span> (attr === <span class="string">'timestamp'</span>) {
                value = util.formatTimestamp(value);
            }

            <span class="keyword">return</span> value;
        }
    });


    <span class="comment">/*
     `StepGenerator` is a collection of `TimeStep` objects representing a run of
     the user's active Gnome model. It also contains logic to get the next
     available step from the model's step generator web service.
     */</span>
    <span class="keyword">var</span> StepGenerator = Backbone.Collection.extend({
        model: TimeStep,

        initialize: <span class="keyword">function</span>(timeSteps, opts) {
            _.bindAll(<span class="keyword">this</span>, <span class="string">'runSuccess'</span>, <span class="string">'timeStepRequestFailure'</span>);

            <span class="keyword">this</span>.url = opts.url + <span class="string">'/step_generator'</span>;
            <span class="keyword">this</span>.currentTimeStep = opts.currentTimeStep || <span class="number">0</span>;
            <span class="keyword">this</span>.nextTimeStep = <span class="keyword">this</span>.currentTimeStep ? <span class="keyword">this</span>.currentTimeStep + <span class="number">1</span> : <span class="number">0</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>An array of timestamps, one for each step we expect the server
to make, passed back when we initiate a model run.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="keyword">this</span>.expectedTimeSteps = opts.expectedTimeSteps || [];</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>Create a collection to manage the server&#39;s generated time steps.
This won&#39;t get reset when the client-side cache is invalided.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="keyword">this</span>.serverCachedTimeSteps = <span class="keyword">new</span> Backbone.Collection(timeSteps);</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>If true, <code>Model</code> will request a new set of time steps from the
server on the next run. Assume we want to do this by default
(i.e., at construction time) if there are no time steps.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="keyword">this</span>.dirty = timeSteps.length === <span class="number">0</span>;
            <span class="keyword">this</span>.gnomeModel = opts.gnomeModel;</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>When initializing the model at the last time step of a
generated series, rewind to the beginning so the user can play
the series again.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="keyword">if</span> (<span class="keyword">this</span>.isOnLastTimeStep()) {
                <span class="keyword">this</span>.rewind();
            }
        },

        hasData: <span class="keyword">function</span>() {
            <span class="keyword">return</span> <span class="keyword">this</span>.expectedTimeSteps.length &gt; <span class="number">0</span>;
        },

        <span class="comment">/*
         Return true if the model has time step data for the step numbered
         `stepNum`.
         */</span>
        hasCachedTimeStep: <span class="keyword">function</span>(stepNum) {
            <span class="keyword">return</span> <span class="keyword">this</span>.get(stepNum) !== <span class="literal">undefined</span>;
        },

        serverHasCachedTimeStep: <span class="keyword">function</span>(stepNum) {
            <span class="keyword">return</span> <span class="keyword">this</span>.serverCachedTimeSteps.get(stepNum) != <span class="literal">undefined</span>;
        },

        <span class="comment">/*
         Get time step `stepNum` from the cached time step web service.

         If the time step is not known to be available, don't check the server -
         to avoid an unnecessary network request (and 404).

         Returns an object with a 'then' method -- either a failed jQuery
         deferred, if the server is not known by the client to have the
         requested time step, or the promise created by jQuery when the step is
         fetched from the server.
         */</span>
        getTimeStep: <span class="keyword">function</span>(stepNum) {
            <span class="keyword">var</span> _<span class="keyword">this</span> = <span class="keyword">this</span>;

            <span class="keyword">if</span> (!<span class="keyword">this</span>.serverHasCachedTimeStep(stepNum)) {
                <span class="keyword">return</span> $.Deferred().fail();
            }

            <span class="keyword">var</span> step = <span class="keyword">new</span> TimeStep({id: stepNum}, {gnomeModel: <span class="keyword">this</span>.gnomeModel});
            <span class="keyword">return</span> step.fetch().done(<span class="keyword">function</span>() {
                _<span class="keyword">this</span>.add(step);
                _<span class="keyword">this</span>.serverCachedTimeSteps.add(step);
            });
        },

        <span class="comment">/*
         Return true if the server gave us a time step for step number `stepNum`.
         */</span>
        serverHasTimeStep: <span class="keyword">function</span>(stepNum) {
            <span class="keyword">return</span> <span class="keyword">this</span>.expectedTimeSteps[stepNum] !== <span class="literal">undefined</span>;
        },

        <span class="comment">/*
         Return the timestamp the server returned for the expected step `stepNum`.
         Unlike `this.getTimeStep()`, this function may be called for steps that
         the model has not yet received from the server.
         */</span>
        getTimestampForExpectedStep: <span class="keyword">function</span>(stepNum) {
            <span class="keyword">var</span> timestamp;

            <span class="keyword">if</span> (<span class="keyword">this</span>.serverHasTimeStep(stepNum)) {
                timestamp = util.formatTimestamp(<span class="keyword">this</span>.expectedTimeSteps[stepNum]);
            }

            <span class="keyword">return</span> timestamp;
        },

        <span class="comment">/*
         Handle a successful request to the server to start the model run.
         Events:

         - Triggers:
            - `Model.MESSAGE_RECEIVED` if the server sent a message.
            - `Model.RUN_BEGAN` unless we received an error message.
         */</span>
        runSuccess: <span class="keyword">function</span>(data) {
            <span class="keyword">var</span> message = util.parseMessage(data);

            <span class="keyword">if</span> (message) {
                <span class="keyword">this</span>.trigger(StepGenerator.MESSAGE_RECEIVED, message);

                <span class="keyword">if</span> (message.error) {
                    <span class="keyword">this</span>.trigger(StepGenerator.RUN_ERROR);
                    <span class="keyword">return</span> <span class="literal">false</span>;
                }
            }

            <span class="keyword">this</span>.dirty = <span class="literal">false</span>;

            <span class="keyword">var</span> isFirstStep = data.time_step.id === <span class="number">0</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>The Gnome model was reset on the server without our knowledge,
so reset the client-side model to stay in sync.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="keyword">if</span> (isFirstStep &amp;&amp; <span class="keyword">this</span>.currentTimeStep) {
                <span class="keyword">this</span>.rewind();
                <span class="keyword">this</span>.trigger(StepGenerator.SERVER_RESET);
            }

            <span class="keyword">if</span> (isFirstStep) {
                <span class="keyword">this</span>.serverCachedTimeSteps.reset();
                <span class="keyword">this</span>.addTimeStep(data.time_step);
                <span class="keyword">this</span>.expectedTimeSteps = data.expected_time_steps;
                <span class="keyword">this</span>.trigger(StepGenerator.RUN_BEGAN, data);
                <span class="keyword">return</span>;
            }

            <span class="keyword">this</span>.addTimeStep(data.time_step);
        },

        <span class="comment">/*
         Helper that performs an AJAX request to start ("run") the model.

         Receives an array of timestamps, one for each step the server expects
         to generate on subsequent requests.
         */</span>
        doRun: <span class="keyword">function</span>(opts) {
            <span class="keyword">var</span> isInvalid = <span class="keyword">function</span>(obj) {
                <span class="keyword">return</span> obj === <span class="literal">undefined</span> || obj === <span class="literal">null</span> || <span class="keyword">typeof</span>(obj) !== <span class="string">"object"</span>;
            };

            <span class="keyword">this</span>.expectedTimeSteps = [];

            $.ajax({
                type: <span class="string">'POST'</span>,
                url: <span class="keyword">this</span>.url,
                data: opts,
                tryCount: <span class="number">0</span>,
                retryLimit: <span class="number">3</span>,
                success: <span class="keyword">this</span>.runSuccess,
                error: util.handleAjaxError
            });
        },

        <span class="comment">/*
         Run the model.

         If the model is dirty, make an AJAX request to the server to initiate a
         model run. Otherwise request the next time step.

         Options:
         - `runUntilTimeStep`: the time step to stop running. This value is
             passed to the server-side model and running will stop after the
             client requests the step with this number.
         */</span>
        run: <span class="keyword">function</span>(opts) {
            <span class="keyword">var</span> options = $.extend({}, {
                runUntilTimeStep: <span class="keyword">this</span>.runUntilTimeStep
            }, opts);

            <span class="keyword">this</span>.runUntilTimeStep = options.runUntilTimeStep || <span class="literal">null</span>;

            <span class="keyword">if</span> (<span class="keyword">this</span>.dirty) {
                <span class="keyword">this</span>.doRun(options);
                <span class="keyword">return</span>;
            }

            <span class="keyword">this</span>.getNextTimeStep();
        },

        <span class="comment">/*
         Return the `TimeStep` object whose ID matches `self.currentTimeStep`.
         */</span>
        getCurrentTimeStep: <span class="keyword">function</span>() {
            <span class="keyword">return</span> <span class="keyword">this</span>.get(<span class="keyword">this</span>.currentTimeStep);
        },

        <span class="comment">/*
         Set the current time step to `newStepNum`.
         */</span>
        addTimeStep: <span class="keyword">function</span>(timeStepJson) {
            <span class="keyword">var</span> timeStep = <span class="keyword">new</span> TimeStep(timeStepJson, {gnomeModel: <span class="keyword">this</span>.gnomeModel});
            <span class="keyword">var</span> now = <span class="keyword">new</span> Date().getTime();
            <span class="keyword">var</span> requestBegan = <span class="keyword">this</span>.timeStepRequestBegin || now;
            timeStep.set(<span class="string">'requestTime'</span>, now - requestBegan);
            <span class="keyword">this</span>.add(timeStep);
            <span class="keyword">this</span>.serverCachedTimeSteps.add(timeStep);
            <span class="keyword">this</span>.setCurrentTimeStep(timeStep.id);
        },

        checkIfRunIsFinished: <span class="keyword">function</span>() {
            <span class="keyword">if</span> (<span class="keyword">this</span>.currentTimeStep === <span class="keyword">this</span>.runUntilTimeStep ||
                <span class="keyword">this</span>.currentTimeStep === _.last(<span class="keyword">this</span>.expectedTimeSteps)) {
                <span class="keyword">this</span>.trigger(StepGenerator.RUN_FINISHED);
                <span class="keyword">this</span>.runUntilTimeStep = <span class="literal">null</span>;
            }
        },

        <span class="comment">/*
         Set the current time step to `stepNum`.

         Triggers:
         - `Model.NEXT_TIME_STEP_READY` with the time step object for the new step.
         - `Model.RUN_FINISHED` if the model has run until `this.runUntilTimeStep`.
         */</span>
        setCurrentTimeStep: <span class="keyword">function</span>(stepNum) {
            <span class="keyword">var</span> _<span class="keyword">this</span> = <span class="keyword">this</span>;
            <span class="keyword">this</span>.currentTimeStep = stepNum;
            <span class="keyword">this</span>.nextTimeStep = stepNum + <span class="number">1</span>;

            <span class="function"><span class="keyword">function</span> <span class="title">finish</span><span class="params">()</span> {</span>
                _<span class="keyword">this</span>.trigger(StepGenerator.NEXT_TIME_STEP_READY, _<span class="keyword">this</span>.getCurrentTimeStep());
                _<span class="keyword">this</span>.checkIfRunIsFinished();
            }

            <span class="keyword">if</span> (<span class="keyword">this</span>.hasCachedTimeStep(<span class="keyword">this</span>.currentTimeStep)) {
                finish();
                <span class="keyword">return</span> $.Deferred().resolve();
            }

            <span class="keyword">return</span> <span class="keyword">this</span>.getTimeStep(<span class="keyword">this</span>.currentTimeStep).done(finish);
        },

        isOnLastTimeStep: <span class="keyword">function</span>() {
            <span class="keyword">return</span> <span class="keyword">this</span>.currentTimeStep === <span class="keyword">this</span>.expectedTimeSteps.length - <span class="number">1</span>;
        },

         <span class="comment">/*
         Finish the current run.

         Triggers:
         - `Model.RUN_FINISHED`
         */</span>
        finishRun: <span class="keyword">function</span>() {
            <span class="keyword">this</span>.rewind();
            <span class="keyword">this</span>.runUntilTimeStep = <span class="literal">null</span>;
            <span class="keyword">this</span>.trigger(StepGenerator.RUN_FINISHED);
        },

        <span class="comment">/*
         Request the next step from the step generator web service.
         */</span>
        generateStep: <span class="keyword">function</span>() {
            <span class="keyword">this</span>.timeStepRequestBegin = <span class="keyword">new</span> Date().getTime();

            <span class="keyword">return</span> $.ajax({
                type: <span class="string">"GET"</span>,
                url: <span class="keyword">this</span>.url,
                success: <span class="keyword">this</span>.runSuccess,
                error: <span class="keyword">this</span>.timeStepRequestFailure
            });
        },

        <span class="comment">/*
         Makes a request to the server for the next time step.

         Retrieves the step from the server's cache of generated steps if the
         step exists there, otherwise requests a new step from the step
         generator web service.

         Triggers:
         - `Model.RUN_FINISHED` if the server has no more time steps to run.
         */</span>
        getNextTimeStep: <span class="keyword">function</span>() {
            <span class="keyword">var</span> _<span class="keyword">this</span> = <span class="keyword">this</span>;
            <span class="keyword">if</span> (!<span class="keyword">this</span>.serverHasTimeStep(<span class="keyword">this</span>.nextTimeStep)) {
                <span class="keyword">this</span>.finishRun();
                <span class="keyword">return</span>;
            }

            <span class="keyword">if</span> (<span class="keyword">this</span>.serverHasCachedTimeStep(<span class="keyword">this</span>.nextTimeStep)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>Try to get the the next time step from the server cache. If
the cache returns a 404 (no time step) then request the next
step from the step generator.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="keyword">var</span> promise = <span class="keyword">this</span>.setCurrentTimeStep(<span class="keyword">this</span>.nextTimeStep);
                <span class="keyword">if</span> (promise) {
                    promise.fail(<span class="keyword">function</span>() {
                        _<span class="keyword">this</span>.generateStep()
                    });
                }
                <span class="keyword">return</span> promise;
            }

            <span class="keyword">return</span> <span class="keyword">this</span>.generateStep();
        },

       timeStepRequestFailure: <span class="keyword">function</span>(xhr, textStatus, errorThrown) {
           <span class="keyword">if</span> (xhr.status === <span class="number">500</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>TODO: Inform user of more information.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>               alert(<span class="string">'The run failed due to a server-side error.'</span>);
           } <span class="keyword">if</span> (xhr.status === <span class="number">404</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>The run finished. We already check if the server is expected
to have a time step before th in a local cache of
expected time steps for the run, so we should not reach
this point in normal operation. That is, assuming the local
cache of time steps matches the server&#39;s -- which it always
should.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>               <span class="keyword">this</span>.finishRun();
           }
           <span class="keyword">this</span>.finishRun();
           util.log(xhr);
       },

       <span class="comment">/*
         Set the current time step to 0.
         */</span>
        rewind: <span class="keyword">function</span>() {
            <span class="keyword">this</span>.currentTimeStep = <span class="number">0</span>;
            <span class="keyword">this</span>.nextTimeStep = <span class="number">0</span>;
        },

        <span class="comment">/*
         Clear all time step data. Used when creating a new server-side model.
         */</span>
        clearData: <span class="keyword">function</span>() {
            <span class="keyword">this</span>.dirty = <span class="literal">true</span>;
            <span class="keyword">this</span>.rewind();
            <span class="keyword">this</span>.reset();
            <span class="keyword">this</span>.expectedTimeSteps = [];
        }
    }, {</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p>Class events</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        CREATED: <span class="string">'model:Created'</span>,
        RUN_BEGAN: <span class="string">'model:stepGeneratorBegan'</span>,
        RUN_FINISHED: <span class="string">'model:stepGeneratorFinished'</span>,
        RUN_ERROR: <span class="string">'model:runError'</span>,
        NEXT_TIME_STEP_READY: <span class="string">'model:nextTimeStepReady'</span>,
        MESSAGE_RECEIVED: <span class="string">'model:messageReceived'</span>,
        SERVER_RESET: <span class="string">'model:serverReset'</span>
    });


    <span class="keyword">var</span> GnomeModel = BaseModel.extend({
        dateFields: [<span class="string">'start_time'</span>],

        url: <span class="keyword">function</span>() {
            <span class="keyword">var</span> id = <span class="keyword">this</span>.id ? <span class="string">'/'</span> + <span class="keyword">this</span>.id : <span class="string">''</span>;
            <span class="keyword">return</span> <span class="string">'/model'</span> + id;
        }
    });</pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p>Spills</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">var</span> SurfaceReleaseSpill = BaseModel.extend({
        dateFields: [<span class="string">'release_time'</span>, <span class="string">'end_release_time'</span>],

        initialize: <span class="keyword">function</span>() {
            <span class="keyword">this</span>.syncArrayField(<span class="string">'start_position'</span>, <span class="string">'start_position_x'</span>, <span class="number">0</span>);
            <span class="keyword">this</span>.syncArrayField(<span class="string">'start_position'</span>, <span class="string">'start_position_y'</span>, <span class="number">1</span>);
            <span class="keyword">this</span>.syncArrayField(<span class="string">'start_position'</span>, <span class="string">'start_position_z'</span>, <span class="number">2</span>);

            <span class="keyword">this</span>.syncArrayField(<span class="string">'end_position'</span>, <span class="string">'end_position_x'</span>, <span class="number">0</span>);
            <span class="keyword">this</span>.syncArrayField(<span class="string">'end_position'</span>, <span class="string">'end_position_y'</span>, <span class="number">1</span>);
            <span class="keyword">this</span>.syncArrayField(<span class="string">'end_position'</span>, <span class="string">'end_position_z'</span>, <span class="number">2</span>);
            
            <span class="keyword">this</span>.syncArrayField(<span class="string">'windage_range'</span>, <span class="string">'windage_range_min'</span>, <span class="number">0</span>);
            <span class="keyword">this</span>.syncArrayField(<span class="string">'windage_range'</span>, <span class="string">'windage_range_max'</span>, <span class="number">1</span>);

            <span class="keyword">return</span> SurfaceReleaseSpill.__super__.initialize.apply(<span class="keyword">this</span>, arguments);
        }
    });


    <span class="keyword">var</span> SurfaceReleaseSpillCollection = BaseCollection.extend({
        model: SurfaceReleaseSpill,
        url: <span class="string">'/spill/surface_release'</span>,

        comparator: <span class="keyword">function</span>(spill) {
            <span class="keyword">return</span> moment(spill.get(<span class="string">'release_time'</span>)).valueOf();
        }
    });</pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <p>Movers</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">var</span> Wind = BaseModel.extend({
        dateFields: [<span class="string">'updated_at'</span>],

        initialize: <span class="keyword">function</span>(attrs, options) {
            <span class="keyword">if</span> (!attrs || !attrs.timeseries) {</pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <p>Set a default timeseries value.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="keyword">this</span>.set(<span class="string">'timeseries'</span>, [[moment(), <span class="number">0</span>, <span class="number">0</span>]]);
            }

            <span class="keyword">return</span> Wind.__super__.set.apply(<span class="keyword">this</span>, arguments);
        },

        <span class="comment">/*
         Whenever `timeseries` is set, sort it by datetime.
         */</span>
        set: <span class="keyword">function</span>(key, val, options) {
            <span class="keyword">if</span> (key.timeseries &amp;&amp; key.timeseries.length) {
                key.timeseries = _.sortBy(key.timeseries, <span class="keyword">function</span>(item) {
                    <span class="keyword">return</span> item[<span class="number">0</span>];
                });
            } <span class="keyword">else</span> <span class="keyword">if</span> (key === <span class="string">'timeseries'</span> &amp;&amp; val &amp;&amp; val.length) {
                val = _.sortBy(val, <span class="keyword">function</span>(item) {
                    <span class="keyword">return</span> item[<span class="number">0</span>];
                });
            }

            <span class="keyword">return</span> Wind.__super__.set.apply(<span class="keyword">this</span>, [key, val, options]);
        },

        isNws: <span class="keyword">function</span>() {
            <span class="keyword">return</span> <span class="keyword">this</span>.get(<span class="string">'source_type'</span>) === <span class="string">'nws'</span>;
        },

        isBuoy: <span class="keyword">function</span>() {
            <span class="keyword">return</span> <span class="keyword">this</span>.get(<span class="string">'source_type'</span>) === <span class="string">'buoy'</span>;
        },

        sourceIdRequired: <span class="keyword">function</span>() {
            <span class="keyword">return</span> <span class="keyword">this</span>.isBuoy() &amp;&amp; !(<span class="keyword">this</span>.get(<span class="string">'longitude'</span>));
        },

        longitudeRequired: <span class="keyword">function</span>() {
            <span class="keyword">return</span> (<span class="keyword">this</span>.isNws() || <span class="keyword">this</span>.isBuoy())
                &amp;&amp; !(<span class="keyword">this</span>.get(<span class="string">'longitude'</span>));
        },

        latitudeRequired: <span class="keyword">function</span>() {
            <span class="keyword">return</span> (<span class="keyword">this</span>.isNws() || <span class="keyword">this</span>.isBuoy())
                &amp;&amp; !(<span class="keyword">this</span>.get(<span class="string">'latitude'</span>));
        },

        type: <span class="keyword">function</span>() {
            <span class="keyword">var</span> timeseries = <span class="keyword">this</span>.get(<span class="string">'timeseries'</span>);

            <span class="keyword">if</span> (timeseries &amp;&amp; timeseries.length &gt; <span class="number">1</span>) {
                <span class="keyword">return</span> <span class="string">'variable-wind'</span>;
            } <span class="keyword">else</span> {
                <span class="keyword">return</span> <span class="string">'constant-wind'</span>;
            }
        },

        constantSpeed: <span class="keyword">function</span>() {
            <span class="keyword">var</span> timeseries = <span class="keyword">this</span>.get(<span class="string">'timeseries'</span>);

            <span class="keyword">if</span> (timeseries &amp;&amp; timeseries.length) {
                <span class="keyword">return</span> timeseries[<span class="number">0</span>][<span class="number">1</span>];
            } <span class="keyword">else</span> {
                <span class="keyword">return</span> <span class="number">0</span>;
            }
        },

        constantDirection: <span class="keyword">function</span>() {
            <span class="keyword">var</span> timeseries = <span class="keyword">this</span>.get(<span class="string">'timeseries'</span>);

            <span class="keyword">if</span> (timeseries &amp;&amp; timeseries.length) {
                <span class="keyword">return</span> timeseries[<span class="number">0</span>][<span class="number">2</span>];
            } <span class="keyword">else</span> {
                <span class="keyword">return</span> <span class="number">0</span>;
            }
        }
    });


    <span class="keyword">var</span> WindCollection = BaseCollection.extend({
        model: Wind,
        url: <span class="string">'/environment/wind'</span>
    });


    <span class="keyword">var</span> BaseMover = BaseModel.extend({
        dateFields: [<span class="string">'active_start'</span>, <span class="string">'active_stop'</span>]
    });


    <span class="keyword">var</span> WindMover = BaseMover.extend({});


    <span class="keyword">var</span> WindMoverCollection = BaseCollection.extend({
        model: WindMover,
        url: <span class="string">'/mover/wind'</span>
    });
    
    
    <span class="keyword">var</span> RandomMover = BaseMover.extend({});


    <span class="keyword">var</span> RandomMoverCollection = BaseCollection.extend({
        model: RandomMover,
        url: <span class="string">'/mover/random'</span>,

        comparator: <span class="keyword">function</span>(mover) {
            <span class="keyword">return</span> <span class="keyword">this</span>.get(<span class="string">'active_start'</span>);
        }
    });


    <span class="keyword">var</span> Map = BaseModel.extend({
        url: <span class="string">'/map'</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p>Bounds are stored as Long, Lat. Return then as Lat, Long.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        getLatLongBounds: <span class="keyword">function</span>() {
            <span class="keyword">var</span> bounds = <span class="keyword">this</span>.get(<span class="string">'map_bounds'</span>);

            <span class="keyword">if</span> (!bounds.length) {
                <span class="keyword">return</span>;
            }

            <span class="keyword">return</span> {
                nw: [bounds[<span class="number">1</span>][<span class="number">1</span>], bounds[<span class="number">1</span>][<span class="number">0</span>]],
                ne: [bounds[<span class="number">2</span>][<span class="number">1</span>], bounds[<span class="number">2</span>][<span class="number">0</span>]],
                se: [bounds[<span class="number">3</span>][<span class="number">1</span>], bounds[<span class="number">3</span>][<span class="number">0</span>]],
                sw: [bounds[<span class="number">0</span>][<span class="number">1</span>], bounds[<span class="number">0</span>][<span class="number">0</span>]]
            }
        },

        getLatLongCenter: <span class="keyword">function</span>() {
            <span class="keyword">var</span> bounds = <span class="keyword">this</span>.getLatLongBounds();

            <span class="keyword">if</span> (!bounds) {
                <span class="keyword">return</span>;
            }

            <span class="keyword">var</span> latLngBounds = <span class="keyword">new</span> google.maps.LatLngBounds(
                <span class="keyword">new</span> google.maps.LatLng(bounds.sw[<span class="number">0</span>], bounds.sw[<span class="number">1</span>]),
                <span class="keyword">new</span> google.maps.LatLng(bounds.ne[<span class="number">0</span>], bounds.sw[<span class="number">1</span>])
            );
            <span class="keyword">return</span> latLngBounds.getCenter();
        }
    });


    <span class="keyword">var</span> MapCollection = BaseCollection.extend({
        model: Map,
        url: <span class="string">'/map'</span>
    });


    <span class="keyword">var</span> Renderer = BaseModel.extend({
        url: <span class="string">'/renderer'</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <p>Viewport is stored as Long, Lat. Return then as Lat, Long.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        getLatLongViewport: <span class="keyword">function</span>() {
            <span class="keyword">var</span> viewport = <span class="keyword">this</span>.get(<span class="string">'viewport'</span>);

            <span class="keyword">if</span> (!viewport || !viewport.length) {
                <span class="keyword">return</span>;
            }

            <span class="keyword">return</span> {
                sw: [viewport[<span class="number">0</span>][<span class="number">1</span>], viewport[<span class="number">0</span>][<span class="number">0</span>]],
                ne: [viewport[<span class="number">1</span>][<span class="number">1</span>], viewport[<span class="number">1</span>][<span class="number">0</span>]]
            }
        }
    });


    <span class="keyword">var</span> CustomMap = BaseModel.extend({
        url: <span class="string">'/custom_map'</span>
    });


    <span class="keyword">var</span> LocationFile = GnomeModel.extend({
        url: <span class="keyword">function</span>() {
            <span class="keyword">return</span> <span class="string">'/location_file/'</span> + <span class="keyword">this</span>.get(<span class="string">'filename'</span>)
        }
    });


    <span class="keyword">var</span> LocationFileMeta = BaseModel.extend({
        idAttribute: <span class="string">'filename'</span>
    });


    <span class="keyword">var</span> LocationFileMetaCollection = BaseCollection.extend({
        model: LocationFileMeta,
        url: <span class="string">'/location_file_meta'</span>
    });


    <span class="keyword">var</span> LocationFileWizard = BaseModel.extend({</pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <p>XXX: What to do here?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        url: <span class="keyword">function</span>() {
            <span class="keyword">return</span> <span class="keyword">this</span>.collection.url() + <span class="string">'/'</span> + <span class="keyword">this</span>.id + <span class="string">'/wizard'</span>;
        }
    });


    <span class="keyword">var</span> LocationFileWizardCollection = BaseCollection.extend({
        model: LocationFileWizard,
        url: <span class="string">'/location_file'</span>
    });


    <span class="keyword">var</span> GnomeModelFromLocationFile = BaseModel.extend({
        url: <span class="keyword">function</span>() {
            <span class="keyword">return</span> <span class="string">'/from_location_file/'</span> + <span class="keyword">this</span>.get(<span class="string">'location_name'</span>)
        }
    });


    <span class="keyword">var</span> GnomeModelValidator = GnomeModel.extend({
        url: <span class="string">'/validate/model'</span>
    });


    <span class="keyword">var</span> WindMoverValidator = WindMover.extend({
        url: <span class="string">'/validate/mover/wind'</span>
    });


    <span class="keyword">var</span> WindValidator = Wind.extend({
        url: <span class="string">'/validate/environment/wind'</span>
    });


    <span class="keyword">var</span> RandomMoverValidator = RandomMover.extend({
        url: <span class="string">'/validate/mover/random'</span>
    });


    <span class="keyword">var</span> SurfaceReleaseSpillValidator = SurfaceReleaseSpill.extend({
        url: <span class="string">'/validate/spill/surface_release'</span>
    });


    <span class="keyword">var</span> MapValidator = Map.extend({
        url: <span class="string">'/validate/map'</span>
    });


    <span class="keyword">var</span> CustomMapValidator = CustomMap.extend({
        url: <span class="string">'/validate/custom_map'</span>
    });


    <span class="keyword">var</span> LocationFileValidator = LocationFile.extend({
        url: <span class="string">'/validate/location_file'</span>
    });
    
    
    <span class="function"><span class="keyword">function</span> <span class="title">makeSetter</span><span class="params">(state)</span> {</span>
        <span class="keyword">return</span> <span class="keyword">function</span>() {
            <span class="keyword">this</span>.set(<span class="string">'state'</span>, state);
        }
    }
    
    <span class="function"><span class="keyword">function</span> <span class="title">makeChecker</span><span class="params">(state)</span> {</span>
        <span class="keyword">return</span> <span class="keyword">function</span>() {
            <span class="keyword">return</span> <span class="keyword">this</span>.get(<span class="string">'state'</span>) === state;
        }
    }


    <span class="keyword">var</span> StateMachine = Backbone.Model.extend({
        initialize: <span class="keyword">function</span>() {
            <span class="keyword">this</span>.set(<span class="string">'state'</span>, <span class="keyword">this</span>.defaultState);
        }
    });


    <span class="keyword">var</span> AnimationState = StateMachine.extend({}, {
        STOPPED: <span class="number">0</span>,
        PLAYING: <span class="number">1</span>,
        PAUSED: <span class="number">2</span>
    });
    
    AnimationState = AnimationState.extend({
        defaultState: AnimationState.STOPPED,

        setStopped: makeSetter(AnimationState.STOPPED),
        setPlaying: makeSetter(AnimationState.PLAYING),
        setPaused: makeSetter(AnimationState.PAUSED),

        isStopped: makeChecker(AnimationState.STOPPED),
        isPlaying: makeChecker(AnimationState.PLAYING),
        isPaused: makeChecker(AnimationState.PAUSED)       
    });


    <span class="keyword">var</span> CursorState = StateMachine.extend({}, {
        RESTING: <span class="number">0</span>,
        ZOOMING_IN: <span class="number">1</span>,
        ZOOMING_OUT: <span class="number">2</span>,
        MOVING: <span class="number">3</span>,
        DRAWING_SPILL: <span class="number">4</span>
    });
    
    CursorState = CursorState.extend({
        defaultState: CursorState.RESTING,

        setZoomingIn: makeSetter(CursorState.ZOOMING_IN),
        setZoomingOut: makeSetter(CursorState.ZOOMING_OUT),
        setResting: makeSetter(CursorState.RESTING),
        setMoving: makeSetter(CursorState.MOVING),
        setDrawingSpill: makeSetter(CursorState.DRAWING_SPILL),

        isZoomingIn: makeChecker(CursorState.ZOOMING_IN),
        isZoomingOut: makeChecker(CursorState.ZOOMING_OUT),
        isResting: makeChecker(CursorState.RESTING),
        isMoving: makeChecker(CursorState.MOVING),
        isDrawingSpill: makeChecker(CursorState.DRAWING_SPILL)
    });


    <span class="keyword">var</span> FullscreenState = StateMachine.extend({}, {
        DISABLED: <span class="number">0</span>,
        ENABLED: <span class="number">1</span>
    });

    FullscreenState = FullscreenState.extend({
        defaultState: FullscreenState.DISABLED,

        setEnabled: makeSetter(FullscreenState.ENABLED),
        setDisabled: makeSetter(FullscreenState.DISABLED),

        isEnabled: makeChecker(FullscreenState.ENABLED),
        isDisabled: makeChecker(FullscreenState.DISABLED)
    });


    <span class="keyword">var</span> AppState = Backbone.Model.extend({
        initialize: <span class="keyword">function</span>() {
            <span class="keyword">this</span>.animation = <span class="keyword">new</span> AnimationState();
            <span class="keyword">this</span>.cursor = <span class="keyword">new</span> CursorState();
            <span class="keyword">this</span>.fullscreen = <span class="keyword">new</span> FullscreenState();

            <span class="keyword">var</span> _<span class="keyword">this</span> = <span class="keyword">this</span>;

            <span class="keyword">this</span>.listenTo(<span class="keyword">this</span>.animation, <span class="string">'change'</span>, <span class="keyword">function</span>(obj) {
                _<span class="keyword">this</span>.trigger(<span class="string">'change:animation'</span>, obj.get(<span class="string">'state'</span>));
            });

            <span class="keyword">this</span>.listenTo(<span class="keyword">this</span>.cursor, <span class="string">'change'</span>, <span class="keyword">function</span>(obj) {
                _<span class="keyword">this</span>.trigger(<span class="string">'change:cursor'</span>, obj.get(<span class="string">'state'</span>));
            });

            <span class="keyword">this</span>.listenTo(<span class="keyword">this</span>.fullscreen, <span class="string">'change'</span>, <span class="keyword">function</span>(obj) {
                _<span class="keyword">this</span>.trigger(<span class="string">'change:fullscreen'</span>, obj.get(<span class="string">'state'</span>));
            });
        }
    });


    <span class="function"><span class="keyword">function</span> <span class="title">nwsWindError</span><span class="params">(resp)</span> {</span>
        <span class="keyword">var</span> error;
        <span class="keyword">var</span> defaultError = <span class="string">'Could not contact the National Weather Service.'</span>;
        <span class="keyword">try</span> {
            error = JSON.parse(resp.responseText).error;
        } <span class="keyword">catch</span> (e) {
            error = defaultError;
        }
        window.alert(error);
    }


    <span class="function"><span class="keyword">function</span> <span class="title">getNwsWind</span><span class="params">(coords, opts)</span> {</span>
        <span class="keyword">var</span> url = <span class="string">'/nws/wind?lat='</span> + coords.latitude + <span class="string">'&amp;lon='</span> + coords.longitude;
        <span class="keyword">var</span> error = opts.error || nwsWindError;
        <span class="keyword">var</span> success = opts.success;
        $.ajax({
            url: url,
            success: success,
            error: error,
            dataType: <span class="string">'json'</span>
        });
    }


    <span class="function"><span class="keyword">function</span> <span class="title">init</span><span class="params">(opts)</span> {</span>
        <span class="keyword">var</span> schema = opts.jsonSchema;
        SurfaceReleaseSpill.prototype.defaults = opts.defaultSurfaceReleaseSpill;
        SurfaceReleaseSpill.prototype.schema =  schema.properties.surface_release_spills.items;
    }


    <span class="keyword">return</span> {
        init: init,
        TimeStep: TimeStep,
        StepGenerator: StepGenerator,
        GnomeModel: GnomeModel,
        GnomeModelFromLocationFile: GnomeModelFromLocationFile,
        BaseModel: BaseModel,
        BaseCollection: BaseCollection,
        SurfaceReleaseSpill: SurfaceReleaseSpill,
        SurfaceReleaseSpillCollection: SurfaceReleaseSpillCollection,
        Wind: Wind,
        WindCollection: WindCollection,
        WindMover: WindMover,
        WindMoverCollection: WindMoverCollection,
        RandomMover: RandomMover,
        RandomMoverCollection: RandomMoverCollection,
        Map: Map,
        Renderer: Renderer,
        CustomMap: CustomMap,
        LocationFile: LocationFile,
        LocationFileMeta: LocationFileMeta,
        LocationFileMetaCollection: LocationFileMetaCollection,
        LocationFileWizard: LocationFileWizard,
        LocationFileWizardCollection: LocationFileWizardCollection,
        GnomeModelValidator: GnomeModelValidator,
        WindValidator: WindValidator,
        WindMoverValidator: WindMoverValidator,
        RandomMoverValidator: RandomMoverValidator,
        SurfaceReleaseSpillValidator: SurfaceReleaseSpillValidator,
        MapValidator: MapValidator,
        CustomMapValidator: CustomMapValidator,
        LocationFileValidator: LocationFileValidator,
        getNwsWind: getNwsWind,
        AppState: AppState,
        AnimationState: AnimationState,
        CursorState: CursorState,
        FullscreenState: FullscreenState
    };

});</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
