

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>pyGNOME Reference &mdash; pyGNOME 0.1.1 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '0.1.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="pyGNOME 0.1.1 documentation" href="index.html" />
    <link rel="next" title="Units used in GNOME / PyGNOME" href="units.html" />
    <link rel="prev" title="CATS currents" href="tutorial_2.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="units.html" title="Units used in GNOME / PyGNOME"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="tutorial_2.html" title="CATS currents"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">pyGNOME 0.1.1 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="pygnome-reference">
<span id="reference"></span><h1><tt class="docutils literal"><span class="pre">pyGNOME</span></tt> Reference<a class="headerlink" href="#pygnome-reference" title="Permalink to this headline">¶</a></h1>
<p>pyGNOMEis a wrapper around a set of C++ libraries. THe C++ code is designed to be used by itself, or from Python, though using it in Python is easier. The API is perhaps a bit klunky &#8211; the C++ code was all orginally written as part of a monolithic GUI program &#8211; we have separated the GUI parts, and cleaned up the API so that the pieces can be used individually.</p>
<div class="section" id="basic-structure">
<h2>Basic Structure<a class="headerlink" href="#basic-structure" title="Permalink to this headline">¶</a></h2>
<p>There are a handlful of core base classes you need to use pyGNOME for anything useful:</p>
<dl class="docutils">
<dt>a model:</dt>
<dd>This is the main class that keeps track of all the pieces, runs the loop through time, etc. The code comes with a full-featured version &#8211; you may want a simpler one if you aren&#8217;t doing a full-on oil spill model.</dd>
<dt>movers:</dt>
<dd>These are classes that represent anything that moves a particle.  Or in fact, alters a particle in any way (the name mover is a bit historical &#8211; they used to only move particles...).  Examples include surface winds, currents (from a variety of sources), weathering processes, etc. &#8211; this is where the real work is done.  Each mover&#8217;s action is essentially linear superposed with the others. i.e at each time step, the model loops through all the movers, and passes the spill objects to be acted on.
At the C++ level, each mover has a <cite>get_move</cite> method that takes the current time, model time step, and pointers to the arrays of particle properties it needs.  At the Python level, the get_move method takes a spill object, and the required arrays are extracted from the spill object &#8211; this lets us pass to a mover only the data that it really needs, and lets us use Python for the dynamic parts &#8211; making sure that the data needed exists.</dd>
<dt>spills:</dt>
<dd><blockquote class="first">
<div><p>A spill class is a class that holds a set of particles and various information about them. Each of the particle properties are stored as numpy arrays (in a dict) &#8211; so that for a given model setup, the spill only needs to have the properties required, and the properties used by a given mover (and only those) can be passed in as a C pointer to the mover code.  At the very least, each spill has a set of particle position arrays.</p>
<p>There may be multiple spills in a model set-up, but for efficiency&#8217;s sake, each spill usually is a set of 1000 or so particles that share various properties.</p>
</div></blockquote>
<p class="last">A spill class has a <cite>release_particles</cite> method that is called at each time step, so that the number of particles can increase as time goes on, etc.</p>
</dd>
<dt>a map:</dt>
<dd>A map keeps track of where land and water are.  The simplest map is all the earth with no land.  It has methods to ask if a location is on land, if a location is &#8220;spillable&#8221;, etc.  The most commonly used map for surface oil spills is intialized with a <cite>*.bna</cite> file describing polygons of land &#8211; this is rasterized into a land-eater bitmap.  During the run, the model calls the <cite>&#8216;beach_LEs</cite> method, which determines which particles have hit land in the last time step, and sets those particles to &#8220;beached&#8221;.</dd>
</dl>
</div>
<div class="section" id="module-gnome">
<span id="class-reference"></span><h2>Class Reference:<a class="headerlink" href="#module-gnome" title="Permalink to this headline">¶</a></h2>
<p>__init__.py for the gnome package</p>
</div>
<div class="section" id="module-gnome.model">
<span id="gnome-model-the-pygnome-model-class"></span><h2><tt class="docutils literal"><span class="pre">gnome.model</span></tt> &#8211; the pyGNOME model class<a class="headerlink" href="#module-gnome.model" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="gnome.model.Model">
<em class="property">class </em><tt class="descclassname">gnome.model.</tt><tt class="descname">Model</tt><big>(</big><em>time_step=datetime.timedelta(0</em>, <em>900)</em>, <em>start_time=datetime.datetime(2013</em>, <em>11</em>, <em>19</em>, <em>18</em>, <em>0)</em>, <em>duration=datetime.timedelta(1)</em>, <em>map=&lt;gnome.map.GnomeMap object at 0x2d04fb0&gt;</em>, <em>uncertain=False</em>, <em>cache_enabled=False</em>, <em>id=None</em><big>)</big><a class="reference internal" href="_modules/gnome/model.html#Model"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.model.Model" title="Permalink to this definition">¶</a></dt>
<dd><p>PyGNOME Model Class</p>
<p>Initializes a model. All arguments have a default.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>time_step=timedelta(minutes=15)</strong> &#8211; model time step in seconds or as a timedelta object</li>
<li><strong>start_time=datetime.now()</strong> &#8211; start time of model, datetime object. default to now, rounded to the nearest hour</li>
<li><strong>duration=timedelta(days=1)</strong> &#8211; how long to run the model, a timedelta object</li>
<li><strong>map=gnome.map.GnomeMap()</strong> &#8211; the land-water map, default is a map with no land-water</li>
<li><strong>uncertain=False</strong> &#8211; flag for setting uncertainty</li>
<li><strong>cache_enabled=False</strong> &#8211; flag for setting whether the mocel should cache results to disk.</li>
<li><strong>id</strong> &#8211; Unique Id identifying the newly created mover (a UUID as a string). 
This is used when loading an object from a persisted model</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="gnome.model.Model.environment_to_dict">
<tt class="descname">environment_to_dict</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/gnome/model.html#Model.environment_to_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.model.Model.environment_to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>call to_dict method of OrderedCollection object</p>
</dd></dl>

<dl class="method">
<dt id="gnome.model.Model.full_run">
<tt class="descname">full_run</tt><big>(</big><em>rewind=True</em>, <em>log=False</em><big>)</big><a class="reference internal" href="_modules/gnome/model.html#Model.full_run"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.model.Model.full_run" title="Permalink to this definition">¶</a></dt>
<dd><p>Do a full run of the model.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>rewind=True</strong> &#8211; whether to rewind the model first &#8211; defaults to True
if set to false, model will be run from the current
step to the end</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">list of outputter info dicts</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.model.Model.map_to_dict">
<tt class="descname">map_to_dict</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/gnome/model.html#Model.map_to_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.model.Model.map_to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>create a tuple that contains: (type, object.id)</p>
</dd></dl>

<dl class="method">
<dt id="gnome.model.Model.move_elements">
<tt class="descname">move_elements</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/gnome/model.html#Model.move_elements"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.model.Model.move_elements" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Moves elements:</dt>
<dd><ul class="first last simple">
<li>loops through all the movers. and moves the elements</li>
<li>sets new_position array for each spill</li>
<li>calls the beaching code to beach the elements that need beaching.</li>
<li>sets the new position</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="gnome.model.Model.movers_to_dict">
<tt class="descname">movers_to_dict</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/gnome/model.html#Model.movers_to_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.model.Model.movers_to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>call to_dict method of OrderedCollection object</p>
</dd></dl>

<dl class="classmethod">
<dt id="gnome.model.Model.new_from_dict">
<em class="property">classmethod </em><tt class="descname">new_from_dict</tt><big>(</big><em>dict_</em><big>)</big><a class="reference internal" href="_modules/gnome/model.html#Model.new_from_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.model.Model.new_from_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Restore model from previously persisted state</p>
</dd></dl>

<dl class="method">
<dt id="gnome.model.Model.next">
<tt class="descname">next</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/gnome/model.html#Model.next"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.model.Model.next" title="Permalink to this definition">¶</a></dt>
<dd><p>(This method here to satisfy Python&#8217;s iterator and generator protocols)</p>
<p>Simply calls model.step()</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">the step number</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.model.Model.outputters_to_dict">
<tt class="descname">outputters_to_dict</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/gnome/model.html#Model.outputters_to_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.model.Model.outputters_to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>call to_dict method of OrderedCollection object</p>
</dd></dl>

<dl class="method">
<dt id="gnome.model.Model.reset">
<tt class="descname">reset</tt><big>(</big><em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/gnome/model.html#Model.reset"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.model.Model.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Resets model to defaults &#8211; Caution &#8211; clears all movers, spills, etc.</p>
<p>Takes same keyword arguments as __init__</p>
</dd></dl>

<dl class="method">
<dt id="gnome.model.Model.rewind">
<tt class="descname">rewind</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/gnome/model.html#Model.rewind"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.model.Model.rewind" title="Permalink to this definition">¶</a></dt>
<dd><p>Rewinds the model to the beginning (start_time)</p>
</dd></dl>

<dl class="method">
<dt id="gnome.model.Model.setup_model_run">
<tt class="descname">setup_model_run</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/gnome/model.html#Model.setup_model_run"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.model.Model.setup_model_run" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets up each mover for the model run</p>
</dd></dl>

<dl class="method">
<dt id="gnome.model.Model.setup_time_step">
<tt class="descname">setup_time_step</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/gnome/model.html#Model.setup_time_step"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.model.Model.setup_time_step" title="Permalink to this definition">¶</a></dt>
<dd><p>sets up everything for the current time_step:</p>
<p>right now only prepares the movers &#8211; maybe more later?.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.model.Model.step">
<tt class="descname">step</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/gnome/model.html#Model.step"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.model.Model.step" title="Permalink to this definition">¶</a></dt>
<dd><p>Steps the model forward (or backward) in time. Needs testing for
hind casting.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.model.Model.step_is_done">
<tt class="descname">step_is_done</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/gnome/model.html#Model.step_is_done"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.model.Model.step_is_done" title="Permalink to this definition">¶</a></dt>
<dd><p>Loop through movers and call model_step_is_done</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-gnome.map">
<span id="gnome-map-the-pygnome-map-class"></span><h2><tt class="docutils literal"><span class="pre">gnome.map</span></tt> &#8211; the pyGNOME map class<a class="headerlink" href="#module-gnome.map" title="Permalink to this headline">¶</a></h2>
<p>An implementation of the GNOME land-water map.</p>
<p>This is a re-write of the C++ raster map approach</p>
<dl class="class">
<dt id="gnome.map.GnomeMap">
<em class="property">class </em><tt class="descclassname">gnome.map.</tt><tt class="descname">GnomeMap</tt><big>(</big><em>map_bounds=None</em>, <em>spillable_area=None</em>, <em>id=None</em><big>)</big><a class="reference internal" href="_modules/gnome/map.html#GnomeMap"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.map.GnomeMap" title="Permalink to this definition">¶</a></dt>
<dd><p>The very simplest map for GNOME &#8211; all water
with only a bounding box for the map bounds.</p>
<p>This also serves as a description of the interface</p>
<p>This __init__ will be different for other implementations</p>
<p>Optional parameters (kwargs)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>map_bounds</strong> &#8211; The polygon bounding the map &#8211; could be larger
or smaller than the land raster</li>
<li><strong>spillable_area</strong> &#8211; The polygon bounding the spillable_area</li>
<li><strong>id</strong> (<em>string</em>) &#8211; unique ID of the object. Using UUID as a string.
This is only used when loading object from save file.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Note on &#8216;map_bounds&#8217;:</dt>
<dd>( (x1,y1), (x2,y2),(x3,y3),..)
An NX2 array of points that describe a polygon
if no map bounds is provided &#8211; the whole world is valid</dd>
</dl>
<dl class="method">
<dt id="gnome.map.GnomeMap.allowable_spill_position">
<tt class="descname">allowable_spill_position</tt><big>(</big><em>coord</em><big>)</big><a class="reference internal" href="_modules/gnome/map.html#GnomeMap.allowable_spill_position"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.map.GnomeMap.allowable_spill_position" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>coord</strong> (<em>3-tuple of floats: (long, lat, depth)</em>) &#8211; location for test.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><ul class="simple">
<li>True if the point is an allowable spill position</li>
<li>False if the point is not an allowable spill position</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">it could be either off the map, or in a location that
spills aren&#8217;t allowed</p>
</div>
</dd></dl>

<dl class="method">
<dt id="gnome.map.GnomeMap.beach_elements">
<tt class="descname">beach_elements</tt><big>(</big><em>spill</em><big>)</big><a class="reference internal" href="_modules/gnome/map.html#GnomeMap.beach_elements"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.map.GnomeMap.beach_elements" title="Permalink to this definition">¶</a></dt>
<dd><p>Determines which LEs were or weren&#8217;t beached or moved off_map.
status_code is changed to oil_status.off_maps if off the map.</p>
<p>Called by the model in the main time loop, after all movers have acted.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>spill</strong> (<tt class="xref py py-class docutils literal"><span class="pre">gnome.spill_container.SpillContainer</span></tt>) &#8211; current SpillContainer</td>
</tr>
</tbody>
</table>
<p>This map class has no land, so only the map check is done
and nothing changes</p>
</dd></dl>

<dl class="method">
<dt id="gnome.map.GnomeMap.in_water">
<tt class="descname">in_water</tt><big>(</big><em>coords</em><big>)</big><a class="reference internal" href="_modules/gnome/map.html#GnomeMap.in_water"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.map.GnomeMap.in_water" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>coords</strong> (<em>3-tuple of floats: (long, lat, depth)
or an Nx3 array</em>) &#8211; location for test.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><ul class="simple">
<li>True if the point is in the water,</li>
<li>False if the point is on land (or off map?)</li>
</ul>
<p>This implementation has no land, so always True in on the map.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.map.GnomeMap.on_land">
<tt class="descname">on_land</tt><big>(</big><em>coord</em><big>)</big><a class="reference internal" href="_modules/gnome/map.html#GnomeMap.on_land"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.map.GnomeMap.on_land" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>coord</strong> (<em>3-tuple of floats: (long, lat, depth)</em>) &#8211; location for test.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><ul class="simple">
<li>Always returns False&#8211; no land in this implementation</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.map.GnomeMap.on_map">
<tt class="descname">on_map</tt><big>(</big><em>coords</em><big>)</big><a class="reference internal" href="_modules/gnome/map.html#GnomeMap.on_map"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.map.GnomeMap.on_map" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>coords</strong> (<em>3-tuple of floats: (long, lat, depth) or a
NX3 numpy array</em>) &#8211; location for test.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">bool array: True if the location is on the map,
False otherwise</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Note:</dt>
<dd>coord is 3-d, but the concept of &#8220;on the map&#8221; is 2-d in this context,
so depth is ignored.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="gnome.map.GnomeMap.refloat_elements">
<tt class="descname">refloat_elements</tt><big>(</big><em>spill_container</em>, <em>time_step</em><big>)</big><a class="reference internal" href="_modules/gnome/map.html#GnomeMap.refloat_elements"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.map.GnomeMap.refloat_elements" title="Permalink to this definition">¶</a></dt>
<dd><p>This method performs the re-float logic &#8211; changing the element
status flag, and moving the element to the last known water position</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>spill_container</strong> (<tt class="xref py py-class docutils literal"><span class="pre">gnome.spill_container.SpillContainer</span></tt>) &#8211; current SpillContainer</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This map class has no land, and so is a no-op.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="gnome.map.GnomeMap.resurface_airborne_elements">
<tt class="descname">resurface_airborne_elements</tt><big>(</big><em>spill_container</em><big>)</big><a class="reference internal" href="_modules/gnome/map.html#GnomeMap.resurface_airborne_elements"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.map.GnomeMap.resurface_airborne_elements" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes any elements that are left above the water surface (z &lt; 0.0)
and puts them on the surface (z == 0.0)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>spill_container</strong> (<tt class="xref py py-class docutils literal"><span class="pre">gnome.spill_container.SpillContainer</span></tt>) &#8211; current SpillContainer</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">While this shouldn&#8217;t occur according to the physics we&#8217;re modeling,
some movers may push elements up to high, or multiple movers may
add vertical movement that adds up to over the surface.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="gnome.map.MapFromBNA">
<em class="property">class </em><tt class="descclassname">gnome.map.</tt><tt class="descname">MapFromBNA</tt><big>(</big><em>filename</em>, <em>refloat_halflife</em>, <em>raster_size=1048576</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/gnome/map.html#MapFromBNA"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.map.MapFromBNA" title="Permalink to this definition">¶</a></dt>
<dd><p>A raster land-water map, created from a BNA file</p>
<p>Creates a GnomeMap (specifically a RasterMap) from a bna file.
It is expected that you will get the spillable area and map bounds
from the BNA &#8211; if they exist</p>
<p>Required arguments:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>bna_file</strong> &#8211; full path to a bna file</li>
<li><strong>refloat_halflife</strong> &#8211; the half-life (in hours) for the re-floating.</li>
<li><strong>raster_size</strong> &#8211; the total number of pixels (bytes) to make the
raster &#8211; the actual size will match the
aspect ratio of the bounding box of the land</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Optional arguments (kwargs):</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>map_bounds</strong> &#8211; The polygon bounding the map &#8211; could be larger or
smaller than the land raster</li>
<li><strong>spillable_area</strong> &#8211; The polygon bounding the spillable_area</li>
<li><strong>id</strong> (<em>string</em>) &#8211; unique ID of the object. Using UUID as a string.
This is only used when loading object from save file.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="gnome.map.RasterMap">
<em class="property">class </em><tt class="descclassname">gnome.map.</tt><tt class="descname">RasterMap</tt><big>(</big><em>refloat_halflife</em>, <em>bitmap_array</em>, <em>projection</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/gnome/map.html#RasterMap"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.map.RasterMap" title="Permalink to this definition">¶</a></dt>
<dd><p>A land water map implemented as a raster</p>
<p>This one uses a numpy array of uint8, so there are 8 bits to choose from...</p>
<p>It requires a constant refloat half-life in hours</p>
<p>This will usually be initialized in a sub-class (from a BNA, etc)
NOTE: Nothing new added to state attribute for serialization</p>
<p>create a new RasterMap</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>refloat_halflife</strong> (<em>float. Units are hours</em>) &#8211; The halflife for refloating off land
&#8211; assumed to be the same for all land.</li>
<li><strong>bitmap_array</strong> (<em>a (W,H) numpy array of type uint8</em>) &#8211; A numpy array that stores the land-water map</li>
<li><strong>projection</strong> (<tt class="xref py py-class docutils literal"><span class="pre">gnome.map_canvas.Projection</span></tt>) &#8211; A Projection object &#8211; used to convert from
lat-long to pixels in the array</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Optional arguments (kwargs)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>map_bounds</strong> (<em>(N,2) numpy array of floats</em>) &#8211; The polygon bounding the map &#8211; could be larger
or smaller than the land raster</li>
<li><strong>spillable_area</strong> (<em>(N,2) numpy array of floats</em>) &#8211; The polygon bounding the spillable_area</li>
<li><strong>id</strong> (<em>string</em>) &#8211; unique ID of the object. Using UUID as a string.
This is only used when loading object from save file.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="gnome.map.RasterMap.allowable_spill_position">
<tt class="descname">allowable_spill_position</tt><big>(</big><em>coord</em><big>)</big><a class="reference internal" href="_modules/gnome/map.html#RasterMap.allowable_spill_position"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.map.RasterMap.allowable_spill_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true is the spill position is in the allowable spill area</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This may not be the same as in_water!</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>coord</strong> &#8211; (lon, lat, depth) coordinate</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.map.RasterMap.beach_elements">
<tt class="descname">beach_elements</tt><big>(</big><em>spill</em><big>)</big><a class="reference internal" href="_modules/gnome/map.html#RasterMap.beach_elements"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.map.RasterMap.beach_elements" title="Permalink to this definition">¶</a></dt>
<dd><p>Determines which elements were or weren&#8217;t beached.</p>
<p>Any that are beached have the beached flag set, and a
&#8220;last known water position&#8221; (lkwp) is computed</p>
<p>This version uses a modified Bresenham algorithm to find out
which pixels the LE may have crossed.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>spill</strong> (<tt class="xref py py-class docutils literal"><span class="pre">gnome.spill_container.SpillContainer</span></tt>
It must have the following data arrays:
(&#8216;prev_position&#8217;, &#8216;positions&#8217;, &#8216;last_water_pt&#8217;, &#8216;status_code&#8217;)) &#8211; the current spill container</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.map.RasterMap.in_water">
<tt class="descname">in_water</tt><big>(</big><em>coord</em><big>)</big><a class="reference internal" href="_modules/gnome/map.html#RasterMap.in_water"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.map.RasterMap.in_water" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>checks if it&#8217;s on the map, first.</dt>
<dd>(depth is ignored in this version)</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>coord</strong> &#8211; (lon, lat, depth) coordinate</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">true if the point given by coord is in the water</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.map.RasterMap.on_land">
<tt class="descname">on_land</tt><big>(</big><em>coord</em><big>)</big><a class="reference internal" href="_modules/gnome/map.html#RasterMap.on_land"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.map.RasterMap.on_land" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>coord</strong> (<em>3-tyuple of floats &#8211; (long, lat, depth)</em>) &#8211; (long, lat, depth) location &#8211; depth is ignored here.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><ul class="simple">
<li>1 if point on land</li>
<li>0 if not on land</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">to_pixel() converts to array of points...</p>
</div>
</dd></dl>

<dl class="method">
<dt id="gnome.map.RasterMap.refloat_elements">
<tt class="descname">refloat_elements</tt><big>(</big><em>spill_container</em>, <em>time_step</em><big>)</big><a class="reference internal" href="_modules/gnome/map.html#RasterMap.refloat_elements"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.map.RasterMap.refloat_elements" title="Permalink to this definition">¶</a></dt>
<dd><p>This method performs the re-float logic &#8211; changing the element
status flag, and moving the element to the last known water position</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>spill_container</strong> (<tt class="xref py py-class docutils literal"><span class="pre">gnome.spill_container.SpillContainer</span></tt>) &#8211; the current spill container</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.map.RasterMap.to_pixel_array">
<tt class="descname">to_pixel_array</tt><big>(</big><em>coords</em><big>)</big><a class="reference internal" href="_modules/gnome/map.html#RasterMap.to_pixel_array"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.map.RasterMap.to_pixel_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Projects an array of (lon, lat) tuples onto the bitmap,
and modifies it in place to hold the corresponding projected values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>coords</strong> &#8211; a numpy array of (lon, lat, depth) points</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">a numpy array of (x, y) pixel values</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-gnome.spill">
<span id="gnome-spill-the-pygnome-spill-class"></span><h2><tt class="docutils literal"><span class="pre">gnome.spill</span></tt> &#8211; the pyGNOME spill class<a class="headerlink" href="#module-gnome.spill" title="Permalink to this headline">¶</a></h2>
<p>spill.py - An implementation of the spill class(s)</p>
<p>A &#8220;spill&#8221; is essentially a source of elements. These classes provide
the logic about where an when the elements are released</p>
<dl class="class">
<dt id="gnome.spill.PointLineSource">
<em class="property">class </em><tt class="descclassname">gnome.spill.</tt><tt class="descname">PointLineSource</tt><big>(</big><em>num_elements</em>, <em>start_position</em>, <em>release_time</em>, <em>end_position=None</em>, <em>end_release_time=None</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/gnome/spill.html#PointLineSource"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.spill.PointLineSource" title="Permalink to this definition">¶</a></dt>
<dd><p>The primary spill source class  &#8211;  a release of floating
non-weathering particles, can be instantaneous or continuous, and be
released at a single point, or over a line.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>num_elements</strong> (<em>integer</em>) &#8211; total number of elements to be released</li>
<li><strong>start_position</strong> (<em>3-tuple of floats (long, lat, z)</em>) &#8211; initial location the elements are released</li>
<li><strong>release_time</strong> (<em>datetime.datetime</em>) &#8211; time the LEs are released (datetime object)</li>
<li><strong>end_position=None</strong> &#8211; optional. For moving source, the end position</li>
<li><strong>end_release_time=None</strong> &#8211; optional &#8211; for a release over time, the
end release time</li>
<li><strong>0.04)</strong> (<em>windage_range=(0.01,</em>) &#8211; the windage range of the elements
default is (0.01, 0.04) from 1% to 4%.</li>
<li><strong>windage_persist=-1</strong> &#8211; Default is 900s, so windage is updated every
900 sec. -1 means the persistence is infinite so it is only set at
the beginning of the run.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Remaining kwargs are passed onto base class __init__ using super.
See <tt class="xref py py-class docutils literal"><span class="pre">FloatingSpill</span></tt> documentation for remaining valid kwargs.</p>
<dl class="classmethod">
<dt id="gnome.spill.PointLineSource.new_from_dict">
<em class="property">classmethod </em><tt class="descname">new_from_dict</tt><big>(</big><em>dict_</em><big>)</big><a class="reference internal" href="_modules/gnome/spill.html#PointLineSource.new_from_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.spill.PointLineSource.new_from_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>create object using the same settings as persisted object.
In addition, set the state of other properties after initialization</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.PointLineSource.num_elements_to_release">
<tt class="descname">num_elements_to_release</tt><big>(</big><em>current_time</em>, <em>time_step</em><big>)</big><a class="reference internal" href="_modules/gnome/spill.html#PointLineSource.num_elements_to_release"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.spill.PointLineSource.num_elements_to_release" title="Permalink to this definition">¶</a></dt>
<dd><p>return number of particles released in current_time + time_step</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.PointLineSource.rewind">
<tt class="descname">rewind</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/gnome/spill.html#PointLineSource.rewind"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.spill.PointLineSource.rewind" title="Permalink to this definition">¶</a></dt>
<dd><p>reset to initial conditions &#8211; i.e. nothing released.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="gnome.spill.SpatialRelease">
<em class="property">class </em><tt class="descclassname">gnome.spill.</tt><tt class="descname">SpatialRelease</tt><big>(</big><em>start_positions</em>, <em>release_time</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/gnome/spill.html#SpatialRelease"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.spill.SpatialRelease" title="Permalink to this definition">¶</a></dt>
<dd><p>A simple spill class  &#8211;  a release of floating non-weathering particles,
with their initial positions pre-specified</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>start_positions</strong> (<em>(num_elements, 3) numpy array of float64
&#8211; (long, lat, z)</em>) &#8211; locations the LEs are released</li>
<li><strong>release_time</strong> (<em>datetime.datetime</em>) &#8211; time the LEs are released</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="gnome.spill.SpatialRelease.num_elements_to_release">
<tt class="descname">num_elements_to_release</tt><big>(</big><em>current_time</em>, <em>time_step</em><big>)</big><a class="reference internal" href="_modules/gnome/spill.html#SpatialRelease.num_elements_to_release"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.spill.SpatialRelease.num_elements_to_release" title="Permalink to this definition">¶</a></dt>
<dd><p>return number of particles released in current_time + time_step</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.SpatialRelease.rewind">
<tt class="descname">rewind</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/gnome/spill.html#SpatialRelease.rewind"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.spill.SpatialRelease.rewind" title="Permalink to this definition">¶</a></dt>
<dd><p>rewind to initial conditions &#8211; i.e. nothing released.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.SpatialRelease.set_newparticle_values">
<tt class="descname">set_newparticle_values</tt><big>(</big><em>num_new_particles</em>, <em>current_time</em>, <em>time_step</em>, <em>data_arrays</em><big>)</big><a class="reference internal" href="_modules/gnome/spill.html#SpatialRelease.set_newparticle_values"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.spill.SpatialRelease.set_newparticle_values" title="Permalink to this definition">¶</a></dt>
<dd><p>set positions for new elements added by the SpillContainer</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">this releases all the elements at their initial positions at
the release_time</p>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="gnome.spill.Spill">
<em class="property">class </em><tt class="descclassname">gnome.spill.</tt><tt class="descname">Spill</tt><big>(</big><em>num_elements=0</em>, <em>on=True</em>, <em>volume=None</em>, <em>volume_units='m^3'</em>, <em>mass=None</em>, <em>mass_units='g'</em>, <em>oil='oil_conservative'</em>, <em>windage_range=None</em>, <em>windage_persist=None</em>, <em>element_type=None</em>, <em>id=None</em><big>)</big><a class="reference internal" href="_modules/gnome/spill.html#Spill"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.spill.Spill" title="Permalink to this definition">¶</a></dt>
<dd><p>base class for a source of elements</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This class is not serializable since it will not be used in
PyGnome. It does not release any elements</p>
</div>
<p>Base spill class. Spill used by a gnome model derive from this class</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>num_elements</strong> (<em>int</em>) &#8211; number of LEs - default is 0.</td>
</tr>
</tbody>
</table>
<p>Optional parameters (kwargs):</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>on</strong> (<em>bool</em>) &#8211; Toggles the spill on/off (bool). Default is &#8216;on&#8217;.</li>
<li><strong>volume</strong> (<em>float</em>) &#8211; oil spilled volume (used to compute mass per particle)
Default is None.</li>
<li><strong>volume_units=m^3</strong> &#8211; volume units</li>
<li><strong>oil=&#8217;oil_conservative&#8217;</strong> &#8211; Type of oil spilled.
If this is a string, or an oillibrary.models.Oil object, then
create gnome.spill.OilProps(oil) object. If this is a
gnome.spill.OilProps object, then simply instance oil_props
variable to it: self.oil_props = oil</li>
<li><strong>windage_range</strong> (<em>a tuple of size 2 (min, max)</em>) &#8211; A tuple defining the min/max % of wind acting on
each LE. Default (0.01, 0.04)</li>
<li><strong>id</strong> (<em>str</em>) &#8211; Unique Id identifying the newly created mover (a UUID as a
string), used when loading from a persisted model</li>
<li><strong>element_type=None</strong> &#8211; list of various element_type that are
released. These are spill specific properties of the elements.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="gnome.spill.Spill.get_volume">
<tt class="descname">get_volume</tt><big>(</big><em>units=None</em><big>)</big><a class="reference internal" href="_modules/gnome/spill.html#Spill.get_volume"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.spill.Spill.get_volume" title="Permalink to this definition">¶</a></dt>
<dd><p>return the volume released during the spill. The default units for
volume are as defined in &#8216;volume_units&#8217; property. User can also specify
desired output units in the function.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.Spill.num_elements_to_release">
<tt class="descname">num_elements_to_release</tt><big>(</big><em>current_time</em>, <em>time_step</em><big>)</big><a class="reference internal" href="_modules/gnome/spill.html#Spill.num_elements_to_release"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.spill.Spill.num_elements_to_release" title="Permalink to this definition">¶</a></dt>
<dd><p>Determines the number of elements to be released during:
current_time + time_step</p>
<p>This base class method if checks is current_time in first step
is valid and toggles the self.start_time_invalid flag if it is valid.
If current_time &lt;= self.release_time the first time this is called,
then toggle start_time_invalid to True.</p>
<p>Subclasses should define the implementation and return number of new
particles to be released once this check passes. Be sure to call the
base class method first if start_time_invalid flag should be checked.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>current_time</strong> (<em>datetime.datetime</em>) &#8211; current time</li>
<li><strong>time_step</strong> (<em>integer seconds</em>) &#8211; the time step, sometimes used to decide how many
should get released.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the number of elements that will be released. This is taken
by SpillContainer to initialize all data_arrays.</p>
</td>
</tr>
</tbody>
</table>
<p>self.num_released is updated after self.set_newparticle_values is
called. Particles are considered released after the values are set.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.Spill.rewind">
<tt class="descname">rewind</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/gnome/spill.html#Spill.rewind"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.spill.Spill.rewind" title="Permalink to this definition">¶</a></dt>
<dd><p>rewinds the Spill to original status (before anything has been
released).</p>
<p>Base class sets &#8216;num_released&#8217;=0 and &#8216;start_time_invalid&#8217;=True
properties to original state.
Subclasses should overload for additional functions required to reset
state.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.Spill.set_newparticle_values">
<tt class="descname">set_newparticle_values</tt><big>(</big><em>num_new_particles</em>, <em>current_time</em>, <em>time_step</em>, <em>data_arrays</em><big>)</big><a class="reference internal" href="_modules/gnome/spill.html#Spill.set_newparticle_values"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.spill.Spill.set_newparticle_values" title="Permalink to this definition">¶</a></dt>
<dd><p>SpillContainer will release elements and initialize all data_arrays
to default initial value. The SpillContainer gets passed as input and
the data_arrays for &#8216;position&#8217;, get initialized correctly.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>num_new_particles</strong> (<em>int</em>) &#8211; number of new particles that were added</li>
<li><strong>current_time</strong> (<em>datetime.datetime</em>) &#8211; current time</li>
<li><strong>time_step</strong> (<em>integer seconds</em>) &#8211; the time step, sometimes used to decide how many
should get released.</li>
<li><strong>data_arrays</strong> (<em>dict containing numpy arrays for values</em>) &#8211; dict of data_arrays provided by the SpillContainer.
Look for &#8216;positions&#8217; array in the dict and update positions for
latest num_new_particles that are released</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Also, the set_newparticle_values() method for all element_type gets
called so each element_type sets the values for its own data correctly</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.Spill.set_volume">
<tt class="descname">set_volume</tt><big>(</big><em>volume</em>, <em>units</em><big>)</big><a class="reference internal" href="_modules/gnome/spill.html#Spill.set_volume"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.spill.Spill.set_volume" title="Permalink to this definition">¶</a></dt>
<dd><p>set the volume released during the spill. The default units for
volume are as defined in &#8216;volume_units&#8217; property. User can also specify
desired output units in the function.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.Spill.uncertain_copy">
<tt class="descname">uncertain_copy</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/gnome/spill.html#Spill.uncertain_copy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.spill.Spill.uncertain_copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a deepcopy of this spill for the uncertainty runs</p>
<p>The copy has everything the same, including the spill_num,
but it is a new object with a new id.</p>
<p>Not much to this method, but it could be overridden to do something
fancier in the future or a subclass.</p>
</dd></dl>

<dl class="attribute">
<dt id="gnome.spill.Spill.volume_units">
<tt class="descname">volume_units</tt><a class="reference internal" href="_modules/gnome/spill.html#Spill.volume_units"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.spill.Spill.volume_units" title="Permalink to this definition">¶</a></dt>
<dd><p>default units in which volume data is returned</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-gnome.movers">
<span id="gnome-movers-pygnome-mover-classes"></span><h2><tt class="docutils literal"><span class="pre">gnome.movers</span></tt> &#8211; pyGNOME mover classes<a class="headerlink" href="#module-gnome.movers" title="Permalink to this headline">¶</a></h2>
<p>__init__.py for the gnome package</p>
<dl class="class">
<dt id="gnome.movers.Mover">
<em class="property">class </em><tt class="descclassname">gnome.movers.</tt><tt class="descname">Mover</tt><big>(</big><em>**kwargs</em><big>)</big><a class="headerlink" href="#gnome.movers.Mover" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class from which all Python movers can inherit</p>
<p>It defines the interface for a Python mover. The model expects the methods
defined here. The get_move(...) method needs to be implemented by the
derived class.</p>
<p>Initialize default Mover parameters</p>
<p>All parameters are optional (kwargs)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>on</strong> &#8211; boolean as to whether the object is on or not. Default is on</li>
<li><strong>active_start</strong> &#8211; datetime when the mover should be active</li>
<li><strong>active_stop</strong> &#8211; datetime after which the mover should be inactive</li>
<li><strong>id</strong> &#8211; Unique Id identifying the newly created mover
(a UUID as a string).
This is used when loading an object from a persisted model</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="gnome.movers.Mover.datetime_to_seconds">
<tt class="descname">datetime_to_seconds</tt><big>(</big><em>model_time</em><big>)</big><a class="headerlink" href="#gnome.movers.Mover.datetime_to_seconds" title="Permalink to this definition">¶</a></dt>
<dd><p>Put the time conversion call here - in case we decide to change it, it
only updates here</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.Mover.get_move">
<tt class="descname">get_move</tt><big>(</big><em>sc</em>, <em>time_step</em>, <em>model_time_datetime</em><big>)</big><a class="headerlink" href="#gnome.movers.Mover.get_move" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the move in (long,lat,z) space. It returns the delta move
for each element of the spill as a numpy array of size
(number_elements X 3) and dtype = gnome.basic_types.world_point_type</p>
<p>Not implemented in base class
Each class derived from Mover object must implement it&#8217;s own get_move</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>sc</strong> &#8211; an instance of gnome.spill_container.SpillContainer class</li>
<li><strong>time_step</strong> &#8211; time step in seconds</li>
<li><strong>model_time_datetime</strong> &#8211; current model time as datetime object</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.Mover.model_step_is_done">
<tt class="descname">model_step_is_done</tt><big>(</big><em>sc=None</em><big>)</big><a class="headerlink" href="#gnome.movers.Mover.model_step_is_done" title="Permalink to this definition">¶</a></dt>
<dd><p>This method gets called by the model when after everything else is done
in a time step. Put any code need for clean-up, etc in here in
subclassed movers.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.Mover.prepare_for_model_run">
<tt class="descname">prepare_for_model_run</tt><big>(</big><big>)</big><a class="headerlink" href="#gnome.movers.Mover.prepare_for_model_run" title="Permalink to this definition">¶</a></dt>
<dd><p>Override this method if a derived mover class needs to perform any
actions prior to a model run</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.Mover.prepare_for_model_step">
<tt class="descname">prepare_for_model_step</tt><big>(</big><em>sc</em>, <em>time_step</em>, <em>model_time_datetime</em><big>)</big><a class="headerlink" href="#gnome.movers.Mover.prepare_for_model_step" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>sets active flag based on time_span and on flag. If</dt>
<dd>model_time &gt; active_start and model_time &lt; active_stop then set
flag to true.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>sc</strong> &#8211; an instance of gnome.spill_container.SpillContainer class</li>
<li><strong>time_step</strong> &#8211; time step in seconds</li>
<li><strong>model_time_datetime</strong> &#8211; current model time as datetime object</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="gnome.movers.CyMover">
<em class="property">class </em><tt class="descclassname">gnome.movers.</tt><tt class="descname">CyMover</tt><big>(</big><em>**kwargs</em><big>)</big><a class="headerlink" href="#gnome.movers.CyMover" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class for python wrappers around cython movers.
Uses super(CyMover,self).__init__(**kwargs) to call Mover class
__init__ method</p>
<p>All cython movers (CyWindMover, CyRandomMover) are instantiated by a
derived class, and then contained by this class in the member &#8216;movers&#8217;.
They will need to extract info from spill object.</p>
<p>We assumes any derived class will instantiate a &#8216;mover&#8217; object that
has methods like: prepare_for_model_run, prepare_for_model_step,</p>
<p>All kwargs passed on to super class</p>
<dl class="method">
<dt id="gnome.movers.CyMover.get_move">
<tt class="descname">get_move</tt><big>(</big><em>sc</em>, <em>time_step</em>, <em>model_time_datetime</em><big>)</big><a class="headerlink" href="#gnome.movers.CyMover.get_move" title="Permalink to this definition">¶</a></dt>
<dd><p>Base implementation of Cython wrapped C++ movers
Override for things like the WindMover since it has a different
implementation</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>sc</strong> &#8211; spill_container.SpillContainer object</li>
<li><strong>time_step</strong> &#8211; time step in seconds</li>
<li><strong>model_time_datetime</strong> &#8211; current model time as datetime object</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.CyMover.model_step_is_done">
<tt class="descname">model_step_is_done</tt><big>(</big><em>sc=None</em><big>)</big><a class="headerlink" href="#gnome.movers.CyMover.model_step_is_done" title="Permalink to this definition">¶</a></dt>
<dd><p>This method gets called by the model after everything else is done
in a time step, and is intended to perform any necessary clean-up
operations. Subclassed movers can override this method.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.CyMover.prepare_data_for_get_move">
<tt class="descname">prepare_data_for_get_move</tt><big>(</big><em>sc</em>, <em>model_time_datetime</em><big>)</big><a class="headerlink" href="#gnome.movers.CyMover.prepare_data_for_get_move" title="Permalink to this definition">¶</a></dt>
<dd><p>organizes the spill object into inputs for calling with Cython
wrapper&#8217;s get_move(...)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>sc</strong> &#8211; an instance of gnome.spill_container.SpillContainer class</li>
<li><strong>model_time_datetime</strong> &#8211; current model time as datetime object</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.CyMover.prepare_for_model_run">
<tt class="descname">prepare_for_model_run</tt><big>(</big><big>)</big><a class="headerlink" href="#gnome.movers.CyMover.prepare_for_model_run" title="Permalink to this definition">¶</a></dt>
<dd><p>Calls the contained cython mover&#8217;s prepare_for_model_run()</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.CyMover.prepare_for_model_step">
<tt class="descname">prepare_for_model_step</tt><big>(</big><em>sc</em>, <em>time_step</em>, <em>model_time_datetime</em><big>)</big><a class="headerlink" href="#gnome.movers.CyMover.prepare_for_model_step" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Default implementation of prepare_for_model_step(...)</dt>
<dd><ul class="first last simple">
<li>Sets the mover&#8217;s active flag if time is within specified timespan
(done in base class Mover)</li>
<li>Invokes the cython mover&#8217;s prepare_for_model_step</li>
</ul>
</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>sc</strong> &#8211; an instance of gnome.spill_container.SpillContainer class</li>
<li><strong>time_step</strong> &#8211; time step in seconds</li>
<li><strong>model_time_datetime</strong> &#8211; current model time as datetime object</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Uses super to invoke Mover class prepare_for_model_step and does a
couple more things specific to CyMover.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="gnome.movers.RandomMover">
<em class="property">class </em><tt class="descclassname">gnome.movers.</tt><tt class="descname">RandomMover</tt><big>(</big><em>**kwargs</em><big>)</big><a class="headerlink" href="#gnome.movers.RandomMover" title="Permalink to this definition">¶</a></dt>
<dd><p>This mover class inherits from CyMover and contains CyRandomMover</p>
<p>The real work is done by CyRandomMover.
CyMover sets everything up that is common to all movers.</p>
<p>Uses super to invoke base class __init__ method.</p>
<p>Optional parameters (kwargs)
:param diffusion_coef: Diffusion coefficient for random diffusion. Default is 100,000 cm2/sec</p>
<p>Remaining kwargs are passed onto <a class="reference internal" href="#gnome.movers.Mover" title="gnome.movers.Mover"><tt class="xref py py-class docutils literal"><span class="pre">gnome.movers.Mover</span></tt></a> __init__ using super. 
See Mover documentation for remaining valid kwargs.</p>
<dl class="method">
<dt id="gnome.movers.RandomMover.datetime_to_seconds">
<tt class="descname">datetime_to_seconds</tt><big>(</big><em>model_time</em><big>)</big><a class="headerlink" href="#gnome.movers.RandomMover.datetime_to_seconds" title="Permalink to this definition">¶</a></dt>
<dd><p>Put the time conversion call here - in case we decide to change it, it
only updates here</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.RandomMover.from_dict">
<tt class="descname">from_dict</tt><big>(</big><em>data</em><big>)</big><a class="headerlink" href="#gnome.movers.RandomMover.from_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>modifies state of the object using dictionary &#8216;data&#8217;. 
Only the self.state.update list contains properties that can me modified for existing object</p>
<p>Set the state of this object using the dictionary <tt class="docutils literal"><span class="pre">data</span></tt> by looking up
the value of each key in <tt class="docutils literal"><span class="pre">data</span></tt> that is also in  <cite>list_</cite>. Input <a href="#id15"><span class="problematic" id="id16">list_</span></a> 
contains the object&#8217;s attributes (or fields) updated with data</p>
<p>For every field, the choice of how to set the field is as follows:</p>
<p>If there is a method defined on the object such that the method name is
<cite>{field_name}_from_dict</cite>, call that method with the field&#8217;s data.</p>
<p>If the field on the object has a <tt class="docutils literal"><span class="pre">from_dict</span></tt> method, then use that
method instead.</p>
<p>If neither method exists, then set the field with the value from
<tt class="docutils literal"><span class="pre">data</span></tt> directly on the object.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.RandomMover.get_move">
<tt class="descname">get_move</tt><big>(</big><em>sc</em>, <em>time_step</em>, <em>model_time_datetime</em><big>)</big><a class="headerlink" href="#gnome.movers.RandomMover.get_move" title="Permalink to this definition">¶</a></dt>
<dd><p>Base implementation of Cython wrapped C++ movers
Override for things like the WindMover since it has a different
implementation</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>sc</strong> &#8211; spill_container.SpillContainer object</li>
<li><strong>time_step</strong> &#8211; time step in seconds</li>
<li><strong>model_time_datetime</strong> &#8211; current model time as datetime object</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.RandomMover.model_step_is_done">
<tt class="descname">model_step_is_done</tt><big>(</big><em>sc=None</em><big>)</big><a class="headerlink" href="#gnome.movers.RandomMover.model_step_is_done" title="Permalink to this definition">¶</a></dt>
<dd><p>This method gets called by the model after everything else is done
in a time step, and is intended to perform any necessary clean-up
operations. Subclassed movers can override this method.</p>
</dd></dl>

<dl class="classmethod">
<dt id="gnome.movers.RandomMover.new_from_dict">
<em class="property">classmethod </em><tt class="descname">new_from_dict</tt><big>(</big><em>dict_</em><big>)</big><a class="headerlink" href="#gnome.movers.RandomMover.new_from_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>creates a new object from dictionary</p>
<p>This is base implementation and can be over-ridden by classes using mixin</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.RandomMover.obj_type_to_dict">
<tt class="descname">obj_type_to_dict</tt><big>(</big><big>)</big><a class="headerlink" href="#gnome.movers.RandomMover.obj_type_to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>returns object type to save in dict. This is base implementation and can be over-ridden</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.RandomMover.prepare_data_for_get_move">
<tt class="descname">prepare_data_for_get_move</tt><big>(</big><em>sc</em>, <em>model_time_datetime</em><big>)</big><a class="headerlink" href="#gnome.movers.RandomMover.prepare_data_for_get_move" title="Permalink to this definition">¶</a></dt>
<dd><p>organizes the spill object into inputs for calling with Cython
wrapper&#8217;s get_move(...)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>sc</strong> &#8211; an instance of gnome.spill_container.SpillContainer class</li>
<li><strong>model_time_datetime</strong> &#8211; current model time as datetime object</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.RandomMover.prepare_for_model_run">
<tt class="descname">prepare_for_model_run</tt><big>(</big><big>)</big><a class="headerlink" href="#gnome.movers.RandomMover.prepare_for_model_run" title="Permalink to this definition">¶</a></dt>
<dd><p>Calls the contained cython mover&#8217;s prepare_for_model_run()</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.RandomMover.prepare_for_model_step">
<tt class="descname">prepare_for_model_step</tt><big>(</big><em>sc</em>, <em>time_step</em>, <em>model_time_datetime</em><big>)</big><a class="headerlink" href="#gnome.movers.RandomMover.prepare_for_model_step" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Default implementation of prepare_for_model_step(...)</dt>
<dd><ul class="first last simple">
<li>Sets the mover&#8217;s active flag if time is within specified timespan
(done in base class Mover)</li>
<li>Invokes the cython mover&#8217;s prepare_for_model_step</li>
</ul>
</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>sc</strong> &#8211; an instance of gnome.spill_container.SpillContainer class</li>
<li><strong>time_step</strong> &#8211; time step in seconds</li>
<li><strong>model_time_datetime</strong> &#8211; current model time as datetime object</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Uses super to invoke Mover class prepare_for_model_step and does a
couple more things specific to CyMover.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.RandomMover.to_dict">
<tt class="descname">to_dict</tt><big>(</big><em>do='update'</em><big>)</big><a class="headerlink" href="#gnome.movers.RandomMover.to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>returns a dictionary containing the serialized representation of this
object. By default it converts the &#8216;update&#8217; list of the state object to dict;
however, do=&#8217;create&#8217; or do=&#8217;read&#8217; will return the dict with the corresponding
list.</p>
<p>For every field, if there is a method defined on the object such that
the method name is <cite>{field_name}_to_dict</cite>, use the return value of that
method as the field value.</p>
<p>Note: any field in <cite>list</cite> that does not exist on the
object and does not have a to_dict method will raise an AttributeError.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="gnome.movers.GridCurrentMover">
<em class="property">class </em><tt class="descclassname">gnome.movers.</tt><tt class="descname">GridCurrentMover</tt><big>(</big><em>filename</em>, <em>topology_file=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#gnome.movers.GridCurrentMover" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize a GridCurrentMover</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>filename</strong> &#8211; absolute or relative path to the data file: could be netcdf or filelist</li>
<li><strong>topology_file=None</strong> &#8211; absolute or relative path to topology file. If not given, the
GridCurrentMover will copmute the topology from the data file.</li>
<li><strong>active_start</strong> &#8211; datetime when the mover should be active</li>
<li><strong>active_stop</strong> &#8211; datetime after which the mover should be inactive</li>
<li><strong>current_scale</strong> &#8211; Value to scale current data</li>
<li><strong>uncertain_duration</strong> &#8211; how often does a given uncertain element gets reset</li>
<li><strong>uncertain_time_delay</strong> &#8211; when does the uncertainly kick in.</li>
<li><strong>uncertain_cross</strong> &#8211; Scale for uncertainty perpendicular to the flow</li>
<li><strong>uncertain_along</strong> &#8211; Scale for uncertainty parallel to the flow</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>uses super: super(GridCurrentMover,self).__init__(<a href="#id1"><span class="problematic" id="id2">**</span></a>kwargs)</p>
<dl class="method">
<dt id="gnome.movers.GridCurrentMover.datetime_to_seconds">
<tt class="descname">datetime_to_seconds</tt><big>(</big><em>model_time</em><big>)</big><a class="headerlink" href="#gnome.movers.GridCurrentMover.datetime_to_seconds" title="Permalink to this definition">¶</a></dt>
<dd><p>Put the time conversion call here - in case we decide to change it, it
only updates here</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridCurrentMover.export_topology">
<tt class="descname">export_topology</tt><big>(</big><em>topology_file</em><big>)</big><a class="headerlink" href="#gnome.movers.GridCurrentMover.export_topology" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>topology_file=None</strong> &#8211; absolute or relative path where topology file will be written.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridCurrentMover.from_dict">
<tt class="descname">from_dict</tt><big>(</big><em>data</em><big>)</big><a class="headerlink" href="#gnome.movers.GridCurrentMover.from_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>modifies state of the object using dictionary &#8216;data&#8217;. 
Only the self.state.update list contains properties that can me modified for existing object</p>
<p>Set the state of this object using the dictionary <tt class="docutils literal"><span class="pre">data</span></tt> by looking up
the value of each key in <tt class="docutils literal"><span class="pre">data</span></tt> that is also in  <cite>list_</cite>. Input <a href="#id17"><span class="problematic" id="id18">list_</span></a> 
contains the object&#8217;s attributes (or fields) updated with data</p>
<p>For every field, the choice of how to set the field is as follows:</p>
<p>If there is a method defined on the object such that the method name is
<cite>{field_name}_from_dict</cite>, call that method with the field&#8217;s data.</p>
<p>If the field on the object has a <tt class="docutils literal"><span class="pre">from_dict</span></tt> method, then use that
method instead.</p>
<p>If neither method exists, then set the field with the value from
<tt class="docutils literal"><span class="pre">data</span></tt> directly on the object.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridCurrentMover.get_move">
<tt class="descname">get_move</tt><big>(</big><em>sc</em>, <em>time_step</em>, <em>model_time_datetime</em><big>)</big><a class="headerlink" href="#gnome.movers.GridCurrentMover.get_move" title="Permalink to this definition">¶</a></dt>
<dd><p>Base implementation of Cython wrapped C++ movers
Override for things like the WindMover since it has a different
implementation</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>sc</strong> &#8211; spill_container.SpillContainer object</li>
<li><strong>time_step</strong> &#8211; time step in seconds</li>
<li><strong>model_time_datetime</strong> &#8211; current model time as datetime object</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridCurrentMover.model_step_is_done">
<tt class="descname">model_step_is_done</tt><big>(</big><em>sc=None</em><big>)</big><a class="headerlink" href="#gnome.movers.GridCurrentMover.model_step_is_done" title="Permalink to this definition">¶</a></dt>
<dd><p>This method gets called by the model after everything else is done
in a time step, and is intended to perform any necessary clean-up
operations. Subclassed movers can override this method.</p>
</dd></dl>

<dl class="classmethod">
<dt id="gnome.movers.GridCurrentMover.new_from_dict">
<em class="property">classmethod </em><tt class="descname">new_from_dict</tt><big>(</big><em>dict_</em><big>)</big><a class="headerlink" href="#gnome.movers.GridCurrentMover.new_from_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>creates a new object from dictionary</p>
<p>This is base implementation and can be over-ridden by classes using mixin</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridCurrentMover.obj_type_to_dict">
<tt class="descname">obj_type_to_dict</tt><big>(</big><big>)</big><a class="headerlink" href="#gnome.movers.GridCurrentMover.obj_type_to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>returns object type to save in dict. This is base implementation and can be over-ridden</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridCurrentMover.prepare_data_for_get_move">
<tt class="descname">prepare_data_for_get_move</tt><big>(</big><em>sc</em>, <em>model_time_datetime</em><big>)</big><a class="headerlink" href="#gnome.movers.GridCurrentMover.prepare_data_for_get_move" title="Permalink to this definition">¶</a></dt>
<dd><p>organizes the spill object into inputs for calling with Cython
wrapper&#8217;s get_move(...)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>sc</strong> &#8211; an instance of gnome.spill_container.SpillContainer class</li>
<li><strong>model_time_datetime</strong> &#8211; current model time as datetime object</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridCurrentMover.prepare_for_model_run">
<tt class="descname">prepare_for_model_run</tt><big>(</big><big>)</big><a class="headerlink" href="#gnome.movers.GridCurrentMover.prepare_for_model_run" title="Permalink to this definition">¶</a></dt>
<dd><p>Calls the contained cython mover&#8217;s prepare_for_model_run()</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridCurrentMover.prepare_for_model_step">
<tt class="descname">prepare_for_model_step</tt><big>(</big><em>sc</em>, <em>time_step</em>, <em>model_time_datetime</em><big>)</big><a class="headerlink" href="#gnome.movers.GridCurrentMover.prepare_for_model_step" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Default implementation of prepare_for_model_step(...)</dt>
<dd><ul class="first last simple">
<li>Sets the mover&#8217;s active flag if time is within specified timespan
(done in base class Mover)</li>
<li>Invokes the cython mover&#8217;s prepare_for_model_step</li>
</ul>
</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>sc</strong> &#8211; an instance of gnome.spill_container.SpillContainer class</li>
<li><strong>time_step</strong> &#8211; time step in seconds</li>
<li><strong>model_time_datetime</strong> &#8211; current model time as datetime object</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Uses super to invoke Mover class prepare_for_model_step and does a
couple more things specific to CyMover.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridCurrentMover.to_dict">
<tt class="descname">to_dict</tt><big>(</big><em>do='update'</em><big>)</big><a class="headerlink" href="#gnome.movers.GridCurrentMover.to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>returns a dictionary containing the serialized representation of this
object. By default it converts the &#8216;update&#8217; list of the state object to dict;
however, do=&#8217;create&#8217; or do=&#8217;read&#8217; will return the dict with the corresponding
list.</p>
<p>For every field, if there is a method defined on the object such that
the method name is <cite>{field_name}_to_dict</cite>, use the return value of that
method as the field value.</p>
<p>Note: any field in <cite>list</cite> that does not exist on the
object and does not have a to_dict method will raise an AttributeError.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="gnome.movers.WindMoversBase">
<em class="property">class </em><tt class="descclassname">gnome.movers.</tt><tt class="descname">WindMoversBase</tt><big>(</big><em>uncertain_duration=24</em>, <em>uncertain_time_delay=0</em>, <em>uncertain_speed_scale=2.0</em>, <em>uncertain_angle_scale=0.4</em>, <em>uncertain_angle_units='rad'</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#gnome.movers.WindMoversBase" title="Permalink to this definition">¶</a></dt>
<dd><p>This is simply a base class for WindMover and GridWindMover for the
common properties.</p>
<p>The classes that inherit from this should define the self.mover object
correctly so it has the required attributes.</p>
<p>Input args with defaults:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>uncertain_duration</strong> &#8211; (seconds) the randomly generated uncertainty
array gets recomputed based on &#8216;uncertain_duration&#8217;</li>
<li><strong>uncertain_time_delay</strong> &#8211; when does the uncertainly kick in.</li>
<li><strong>uncertain_speed_scale</strong> &#8211; Scale for uncertainty in wind speed
non-dimensional number</li>
<li><strong>uncertain_angle_scale</strong> &#8211; Scale for uncertainty in wind direction
&#8216;deg&#8217; or &#8216;rad&#8217;</li>
<li><strong>uncertain_angle_units</strong> &#8211; &#8216;rad&#8217; or &#8216;deg&#8217;. These are the units for
the uncertain_angle_scale.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>It calls super in the __init__ method and passes in the optional
parameters (kwargs)</p>
<dl class="method">
<dt id="gnome.movers.WindMoversBase.datetime_to_seconds">
<tt class="descname">datetime_to_seconds</tt><big>(</big><em>model_time</em><big>)</big><a class="headerlink" href="#gnome.movers.WindMoversBase.datetime_to_seconds" title="Permalink to this definition">¶</a></dt>
<dd><p>Put the time conversion call here - in case we decide to change it, it
only updates here</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.WindMoversBase.get_move">
<tt class="descname">get_move</tt><big>(</big><em>sc</em>, <em>time_step</em>, <em>model_time_datetime</em><big>)</big><a class="headerlink" href="#gnome.movers.WindMoversBase.get_move" title="Permalink to this definition">¶</a></dt>
<dd><p>Override base class functionality because mover has a different
get_move signature</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>sc</strong> &#8211; an instance of the gnome.SpillContainer class</li>
<li><strong>time_step</strong> &#8211; time step in seconds</li>
<li><strong>model_time_datetime</strong> &#8211; current time of the model as a date time
object</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.WindMoversBase.model_step_is_done">
<tt class="descname">model_step_is_done</tt><big>(</big><em>sc=None</em><big>)</big><a class="headerlink" href="#gnome.movers.WindMoversBase.model_step_is_done" title="Permalink to this definition">¶</a></dt>
<dd><p>This method gets called by the model after everything else is done
in a time step, and is intended to perform any necessary clean-up
operations. Subclassed movers can override this method.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.WindMoversBase.prepare_data_for_get_move">
<tt class="descname">prepare_data_for_get_move</tt><big>(</big><em>sc</em>, <em>model_time_datetime</em><big>)</big><a class="headerlink" href="#gnome.movers.WindMoversBase.prepare_data_for_get_move" title="Permalink to this definition">¶</a></dt>
<dd><p>organizes the spill object into inputs for calling with Cython
wrapper&#8217;s get_move(...)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>sc</strong> &#8211; an instance of gnome.spill_container.SpillContainer class</li>
<li><strong>model_time_datetime</strong> &#8211; current model time as datetime object</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.WindMoversBase.prepare_for_model_run">
<tt class="descname">prepare_for_model_run</tt><big>(</big><big>)</big><a class="headerlink" href="#gnome.movers.WindMoversBase.prepare_for_model_run" title="Permalink to this definition">¶</a></dt>
<dd><p>Calls the contained cython mover&#8217;s prepare_for_model_run()</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.WindMoversBase.prepare_for_model_step">
<tt class="descname">prepare_for_model_step</tt><big>(</big><em>sc</em>, <em>time_step</em>, <em>model_time_datetime</em><big>)</big><a class="headerlink" href="#gnome.movers.WindMoversBase.prepare_for_model_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Call base class method using super
Also updates windage for this timestep</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>sc</strong> &#8211; an instance of gnome.spill_container.SpillContainer class</li>
<li><strong>time_step</strong> &#8211; time step in seconds</li>
<li><strong>model_time_datetime</strong> &#8211; current time of model as a date time object</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.WindMoversBase.set_uncertain_angle">
<tt class="descname">set_uncertain_angle</tt><big>(</big><em>val</em>, <em>units</em><big>)</big><a class="headerlink" href="#gnome.movers.WindMoversBase.set_uncertain_angle" title="Permalink to this definition">¶</a></dt>
<dd><p>this must be a function because user must provide units with value</p>
</dd></dl>

<dl class="attribute">
<dt id="gnome.movers.WindMoversBase.uncertain_angle_scale">
<tt class="descname">uncertain_angle_scale</tt><a class="headerlink" href="#gnome.movers.WindMoversBase.uncertain_angle_scale" title="Permalink to this definition">¶</a></dt>
<dd><p>read only - this is set when set_uncertain_angle() is called
It returns the angle in &#8216;uncertain_angle_units&#8217;</p>
</dd></dl>

<dl class="attribute">
<dt id="gnome.movers.WindMoversBase.uncertain_angle_units">
<tt class="descname">uncertain_angle_units</tt><a class="headerlink" href="#gnome.movers.WindMoversBase.uncertain_angle_units" title="Permalink to this definition">¶</a></dt>
<dd><p>units specified by the user when setting the uncertain_angle:
set_uncertain_angle()</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="gnome.movers.WindMover">
<em class="property">class </em><tt class="descclassname">gnome.movers.</tt><tt class="descname">WindMover</tt><big>(</big><em>wind</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#gnome.movers.WindMover" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">gnome.movers.wind_movers.WindMoversBase</span></tt>, <tt class="xref py py-class docutils literal"><span class="pre">gnome.utilities.serializable.Serializable</span></tt></p>
<p>Python wrapper around the Cython wind_mover module.
This class inherits from CyMover and contains CyWindMover</p>
<p>The real work is done by the CyWindMover object.  CyMover
sets everything up that is common to all movers.</p>
<p>In addition to base class array_types.basic, also use the
array_types.windage dict since WindMover requires a windage array</p>
<p>Uses super to call CyMover base class __init__</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>wind</strong> &#8211; wind object &#8211; provides the wind time series for the mover</td>
</tr>
</tbody>
</table>
<p>Remaining kwargs are passed onto WindMoversBase __init__ using super.
See Mover documentation for remaining valid kwargs.</p>
<dl class="method">
<dt id="gnome.movers.WindMover.from_dict">
<tt class="descname">from_dict</tt><big>(</big><em>dict_</em><big>)</big><a class="headerlink" href="#gnome.movers.WindMover.from_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>For updating the object from dictionary</p>
<p>&#8216;wind&#8217; object is not part of the state since it is not serialized/
deserialized; however, user can still update the wind attribute with a
new Wind object. That must be poped out of the dict() here, then call
super to process the standard dict_</p>
</dd></dl>

<dl class="classmethod">
<dt id="gnome.movers.WindMover.new_from_dict">
<em class="property">classmethod </em><tt class="descname">new_from_dict</tt><big>(</big><em>dict_</em><big>)</big><a class="headerlink" href="#gnome.movers.WindMover.new_from_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>define in WindMover and check wind_id matches wind</p>
<p>invokes: super(WindMover,cls).new_from_dict(dict_)</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.WindMover.wind_id_to_dict">
<tt class="descname">wind_id_to_dict</tt><big>(</big><big>)</big><a class="headerlink" href="#gnome.movers.WindMover.wind_id_to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>used only for storing state so no wind_id_from_dict is defined. This
is not a read/write attribute. Only defined for serializable_state</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="gnome.movers.GridWindMover">
<em class="property">class </em><tt class="descclassname">gnome.movers.</tt><tt class="descname">GridWindMover</tt><big>(</big><em>wind_file</em>, <em>topology_file=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#gnome.movers.GridWindMover" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>wind_file</strong> &#8211; file containing wind data on a grid</li>
<li><strong>topology_file</strong> &#8211; Default is None. When exporting topology, it
is stored in this file</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Pass optional arguments to base class
uses super: super(GridWindMover,self).__init__(<a href="#id3"><span class="problematic" id="id4">**</span></a>kwargs)</p>
<dl class="method">
<dt id="gnome.movers.GridWindMover.datetime_to_seconds">
<tt class="descname">datetime_to_seconds</tt><big>(</big><em>model_time</em><big>)</big><a class="headerlink" href="#gnome.movers.GridWindMover.datetime_to_seconds" title="Permalink to this definition">¶</a></dt>
<dd><p>Put the time conversion call here - in case we decide to change it, it
only updates here</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridWindMover.export_topology">
<tt class="descname">export_topology</tt><big>(</big><em>topology_file</em><big>)</big><a class="headerlink" href="#gnome.movers.GridWindMover.export_topology" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>topology_file=None</strong> &#8211; absolute or relative path where topology</td>
</tr>
</tbody>
</table>
<p>file will be written.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridWindMover.from_dict">
<tt class="descname">from_dict</tt><big>(</big><em>data</em><big>)</big><a class="headerlink" href="#gnome.movers.GridWindMover.from_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>modifies state of the object using dictionary &#8216;data&#8217;. 
Only the self.state.update list contains properties that can me modified for existing object</p>
<p>Set the state of this object using the dictionary <tt class="docutils literal"><span class="pre">data</span></tt> by looking up
the value of each key in <tt class="docutils literal"><span class="pre">data</span></tt> that is also in  <cite>list_</cite>. Input <a href="#id19"><span class="problematic" id="id20">list_</span></a> 
contains the object&#8217;s attributes (or fields) updated with data</p>
<p>For every field, the choice of how to set the field is as follows:</p>
<p>If there is a method defined on the object such that the method name is
<cite>{field_name}_from_dict</cite>, call that method with the field&#8217;s data.</p>
<p>If the field on the object has a <tt class="docutils literal"><span class="pre">from_dict</span></tt> method, then use that
method instead.</p>
<p>If neither method exists, then set the field with the value from
<tt class="docutils literal"><span class="pre">data</span></tt> directly on the object.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridWindMover.get_move">
<tt class="descname">get_move</tt><big>(</big><em>sc</em>, <em>time_step</em>, <em>model_time_datetime</em><big>)</big><a class="headerlink" href="#gnome.movers.GridWindMover.get_move" title="Permalink to this definition">¶</a></dt>
<dd><p>Override base class functionality because mover has a different
get_move signature</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>sc</strong> &#8211; an instance of the gnome.SpillContainer class</li>
<li><strong>time_step</strong> &#8211; time step in seconds</li>
<li><strong>model_time_datetime</strong> &#8211; current time of the model as a date time
object</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridWindMover.model_step_is_done">
<tt class="descname">model_step_is_done</tt><big>(</big><em>sc=None</em><big>)</big><a class="headerlink" href="#gnome.movers.GridWindMover.model_step_is_done" title="Permalink to this definition">¶</a></dt>
<dd><p>This method gets called by the model after everything else is done
in a time step, and is intended to perform any necessary clean-up
operations. Subclassed movers can override this method.</p>
</dd></dl>

<dl class="classmethod">
<dt id="gnome.movers.GridWindMover.new_from_dict">
<em class="property">classmethod </em><tt class="descname">new_from_dict</tt><big>(</big><em>dict_</em><big>)</big><a class="headerlink" href="#gnome.movers.GridWindMover.new_from_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>creates a new object from dictionary</p>
<p>This is base implementation and can be over-ridden by classes using mixin</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridWindMover.obj_type_to_dict">
<tt class="descname">obj_type_to_dict</tt><big>(</big><big>)</big><a class="headerlink" href="#gnome.movers.GridWindMover.obj_type_to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>returns object type to save in dict. This is base implementation and can be over-ridden</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridWindMover.prepare_data_for_get_move">
<tt class="descname">prepare_data_for_get_move</tt><big>(</big><em>sc</em>, <em>model_time_datetime</em><big>)</big><a class="headerlink" href="#gnome.movers.GridWindMover.prepare_data_for_get_move" title="Permalink to this definition">¶</a></dt>
<dd><p>organizes the spill object into inputs for calling with Cython
wrapper&#8217;s get_move(...)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>sc</strong> &#8211; an instance of gnome.spill_container.SpillContainer class</li>
<li><strong>model_time_datetime</strong> &#8211; current model time as datetime object</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridWindMover.prepare_for_model_run">
<tt class="descname">prepare_for_model_run</tt><big>(</big><big>)</big><a class="headerlink" href="#gnome.movers.GridWindMover.prepare_for_model_run" title="Permalink to this definition">¶</a></dt>
<dd><p>Calls the contained cython mover&#8217;s prepare_for_model_run()</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridWindMover.prepare_for_model_step">
<tt class="descname">prepare_for_model_step</tt><big>(</big><em>sc</em>, <em>time_step</em>, <em>model_time_datetime</em><big>)</big><a class="headerlink" href="#gnome.movers.GridWindMover.prepare_for_model_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Call base class method using super
Also updates windage for this timestep</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>sc</strong> &#8211; an instance of gnome.spill_container.SpillContainer class</li>
<li><strong>time_step</strong> &#8211; time step in seconds</li>
<li><strong>model_time_datetime</strong> &#8211; current time of model as a date time object</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridWindMover.set_uncertain_angle">
<tt class="descname">set_uncertain_angle</tt><big>(</big><em>val</em>, <em>units</em><big>)</big><a class="headerlink" href="#gnome.movers.GridWindMover.set_uncertain_angle" title="Permalink to this definition">¶</a></dt>
<dd><p>this must be a function because user must provide units with value</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridWindMover.to_dict">
<tt class="descname">to_dict</tt><big>(</big><em>do='update'</em><big>)</big><a class="headerlink" href="#gnome.movers.GridWindMover.to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>returns a dictionary containing the serialized representation of this
object. By default it converts the &#8216;update&#8217; list of the state object to dict;
however, do=&#8217;create&#8217; or do=&#8217;read&#8217; will return the dict with the corresponding
list.</p>
<p>For every field, if there is a method defined on the object such that
the method name is <cite>{field_name}_to_dict</cite>, use the return value of that
method as the field value.</p>
<p>Note: any field in <cite>list</cite> that does not exist on the
object and does not have a to_dict method will raise an AttributeError.</p>
</dd></dl>

<dl class="attribute">
<dt id="gnome.movers.GridWindMover.uncertain_angle_scale">
<tt class="descname">uncertain_angle_scale</tt><a class="headerlink" href="#gnome.movers.GridWindMover.uncertain_angle_scale" title="Permalink to this definition">¶</a></dt>
<dd><p>read only - this is set when set_uncertain_angle() is called
It returns the angle in &#8216;uncertain_angle_units&#8217;</p>
</dd></dl>

<dl class="attribute">
<dt id="gnome.movers.GridWindMover.uncertain_angle_units">
<tt class="descname">uncertain_angle_units</tt><a class="headerlink" href="#gnome.movers.GridWindMover.uncertain_angle_units" title="Permalink to this definition">¶</a></dt>
<dd><p>units specified by the user when setting the uncertain_angle:
set_uncertain_angle()</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-gnome.environment">
<span id="gnome-weather-pygnome-environment-classes"></span><h2><tt class="docutils literal"><span class="pre">gnome.weather</span></tt> &#8211; pyGNOME environment classes<a class="headerlink" href="#module-gnome.environment" title="Permalink to this headline">¶</a></h2>
<p>module contains objects that contain weather related data. For example,
the Wind object defines the Wind conditions for the spill</p>
<dl class="function">
<dt id="gnome.environment.ConstantWind">
<tt class="descclassname">gnome.environment.</tt><tt class="descname">ConstantWind</tt><big>(</big><em>speed</em>, <em>direction</em>, <em>units='m/s'</em><big>)</big><a class="reference internal" href="_modules/gnome/environment.html#ConstantWind"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.environment.ConstantWind" title="Permalink to this definition">¶</a></dt>
<dd><p>utility to create a constant wind &#8220;timeseries&#8221;</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>speed</strong> &#8211; speed of wind</li>
<li><strong>direction</strong> &#8211; direction &#8211; degrees True, direction wind is from
(degrees True)</li>
<li><strong>unit=&#8217;m/s&#8217;</strong> &#8211; units for speed, as a string, i.e. &#8220;knots&#8221;, &#8220;m/s&#8221;,
&#8220;cm/s&#8221;, etc.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="gnome.environment.Environment">
<em class="property">class </em><tt class="descclassname">gnome.environment.</tt><tt class="descname">Environment</tt><big>(</big><em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/gnome/environment.html#Environment"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.environment.Environment" title="Permalink to this definition">¶</a></dt>
<dd><p>A base class for all classes in environment module</p>
<p>This is primarily to define a dtype such that the OrderedCollection
defined in the Model object requires it.</p>
<p>This base class just defines the id property</p>
<p>Base class - serves two purposes:
1) Defines the dtype for all objects that can be added to the Model&#8217;s</p>
<blockquote>
<div>environment OrderedCollection (Model.environment)</div></blockquote>
<ol class="arabic simple" start="2">
<li>Defines the &#8216;id&#8217; property used to uniquely identify an object</li>
</ol>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>id</strong> &#8211; Unique Id identifying the newly created mover
(a UUID as a string).
This is used when loading an object from a persisted model</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="gnome.environment.Tide">
<em class="property">class </em><tt class="descclassname">gnome.environment.</tt><tt class="descname">Tide</tt><big>(</big><em>filename=None</em>, <em>timeseries=None</em>, <em>yeardata='/Users/jasmine.sandhu/Documents/projects/GNOME2_github/py_gnome/gnome/data/yeardata'</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/gnome/environment.html#Tide"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.environment.Tide" title="Permalink to this definition">¶</a></dt>
<dd><p>todo: baseclass called ScaleTimeseries (or something like that)
ScaleCurrent
Define the tide for a spill</p>
<p>Currently, this internally defines and uses the CyShioTime object, which is
a cython wrapper around the C++ Shio object</p>
<p>Tide information can be obtained from a filename or set as a
timeseries (timeseries is NOT TESTED YET)</p>
<p>Invokes super(Tides,self).__init__(**kwargs) for parent class
initialization</p>
<dl class="docutils">
<dt>It requires one of the following to initialize:</dt>
<dd><ol class="first last arabic simple">
<li>&#8216;timeseries&#8217; assumed to be in &#8216;uv&#8217; format
(NOT TESTED/IMPLEMENTED OR USED YET)</li>
<li>a &#8216;filename&#8217; containing a header that defines units amongst
other meta data</li>
</ol>
</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>timeseries</strong> (<em>numpy.ndarray[basic_types.time_value_pair, ndim=1]</em>) &#8211; numpy array containing datetime_value_2d,
ts_format is always &#8216;uv&#8217;</li>
<li><strong>units</strong> &#8211; units associated with the timeseries data. If &#8216;filename&#8217;
is given, then units are read in from the filename.
unit_conversion - NOT IMPLEMENTED YET</li>
<li><strong>filename</strong> &#8211; path to a long wind filename from which to read
wind data</li>
<li><strong>yeardata</strong> &#8211; (Optional) path to yeardata used for Shio data
filenames. Default location is gnome/data/yeardata/</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Remaining kwargs (&#8216;id&#8217; if present) are passed onto Environment&#8217;s
__init__ using super.
See base class documentation for remaining valid kwargs.</p>
</dd></dl>

<dl class="class">
<dt id="gnome.environment.Wind">
<em class="property">class </em><tt class="descclassname">gnome.environment.</tt><tt class="descname">Wind</tt><big>(</big><em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/gnome/environment.html#Wind"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.environment.Wind" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines the Wind conditions for a spill</p>
<p>Initializes a wind object. It only takes keyword arguments as input,
these are defined below.</p>
<p>Invokes super(Wind,self).__init__(**kwargs) for parent class
initialization</p>
<dl class="docutils">
<dt>It requires one of the following to initialize:</dt>
<dd><ol class="first last arabic simple">
<li>&#8216;timeseries&#8217; along with &#8216;units&#8217; or</li>
<li>a &#8216;filename&#8217; containing a header that defines units amongst
other meta data</li>
</ol>
</dd>
</dl>
<p>All other keywords are optional.
Optional parameters (kwargs):</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>timeseries</strong> (<em>numpy.ndarray[basic_types.time_value_pair, ndim=1]</em>) &#8211; (Required) numpy array containing time_value_pair</li>
<li><strong>filename</strong> &#8211; path to a long wind file from which to read wind data</li>
<li><strong>units</strong> (<em>string, for example: &#8216;knot&#8217;, &#8216;meter per second&#8217;,
&#8216;mile per hour&#8217; etc.
Default units for input/output timeseries data</em>) &#8211; units associated with the timeseries data. If &#8216;filename&#8217;
is given, then units are read in from the file.
get_timeseries() will use these as default units to
output data, unless user specifies otherwise.
These units must be valid as defined in the hazpy
unit_conversion module:
unit_conversion.GetUnitNames(&#8216;Velocity&#8217;)</li>
<li><strong>format</strong> (<em>string &#8216;r-theta&#8217; or &#8216;uv&#8217;. Converts string to integer
defined by gnome.basic_types.ts_format.*
TODO: &#8216;format&#8217; is a python builtin keyword</em>) &#8211; (Optional) default timeseries format is
magnitude direction: &#8216;r-theta&#8217;</li>
<li><strong>name</strong> &#8211; (Optional) human readable string for wind object name.
Default is filename if data is from file or &#8220;Wind Object&#8221;</li>
<li><strong>source_type</strong> &#8211; <p>(Optional) Default is undefined, but can be one of
the following:</p>
<blockquote>
<div>[&#8216;buoy&#8217;, &#8216;manual&#8217;, &#8216;undefined&#8217;, &#8216;file&#8217;, &#8216;nws&#8217;]</div></blockquote>
<p>If data is read from file, then it is &#8216;file&#8217;</p>
</li>
<li><strong>latitude</strong> &#8211; (Optional) latitude of station or location where
wind data is obtained from NWS</li>
<li><strong>longitude</strong> &#8211; (Optional) longitude of station or location where
wind data is obtained from NWS</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Remaining kwargs (&#8216;id&#8217; if present) are passed onto Environment&#8217;s</dt>
<dd>__init__ using super.</dd>
</dl>
<p>See base class documentation for remaining valid kwargs.</p>
<dl class="method">
<dt id="gnome.environment.Wind.get_timeseries">
<tt class="descname">get_timeseries</tt><big>(</big><em>datetime=None</em>, <em>units=None</em>, <em>format='r-theta'</em><big>)</big><a class="reference internal" href="_modules/gnome/environment.html#Wind.get_timeseries"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.environment.Wind.get_timeseries" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the timeseries in the requested format. If datetime=None,
then the original timeseries that was entered is returned.
If datetime is a list containing datetime objects, then the wind value
for each of those date times is determined by the underlying
CyOSSMTime object and the timeseries is returned.</p>
<p>The output format is defined by the strings &#8216;r-theta&#8217;, &#8216;uv&#8217;</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>datetime</strong> (<em>datetime object</em>) &#8211; [optional] datetime object or list of datetime
objects for which the value is desired</li>
<li><strong>units</strong> (<em>string. Uses the hazpy.unit_conversion module.
hazpy.unit_conversion throws error for invalid units</em>) &#8211; [optional] outputs data in these units. Default is to
output data in units</li>
<li><strong>format</strong> (<em>either string or integer value defined by
basic_types.ts_format.* (see cy_basic_types.pyx)</em>) &#8211; output format for the times series:
either &#8216;r-theta&#8217; or &#8216;uv&#8217;</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">numpy array containing dtype=basic_types.datetime_value_2d.
Contains user specified datetime and the corresponding
values in user specified ts_format</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.environment.Wind.set_timeseries">
<tt class="descname">set_timeseries</tt><big>(</big><em>datetime_value_2d</em>, <em>units</em>, <em>format='r-theta'</em><big>)</big><a class="reference internal" href="_modules/gnome/environment.html#Wind.set_timeseries"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.environment.Wind.set_timeseries" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the timeseries of the Wind object to the new value given by
a numpy array.  The format for the input data defaults to
basic_types.format.magnitude_direction but can be changed by the user</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>datetime_value_2d</strong> (<em>numpy array of dtype
basic_types.datetime_value_2d</em>) &#8211; timeseries of wind data defined in a
numpy array</li>
<li><strong>units</strong> &#8211; units associated with the data. Valid units defined in
Wind.valid_vel_units list</li>
<li><strong>format</strong> (<em>either string or integer value defined by
basic_types.format.* (see cy_basic_types.pyx)</em>) &#8211; output format for the times series; as defined by
basic_types.format.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.environment.Wind.to_dict">
<tt class="descname">to_dict</tt><big>(</big><em>do='update'</em><big>)</big><a class="reference internal" href="_modules/gnome/environment.html#Wind.to_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.environment.Wind.to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Call base class to_dict using super</p>
<p>Then if to_dict is used to &#8216;create&#8217; a dict for a save file and
&#8216;filename&#8217; is given, then remove &#8216;timeseries&#8217; from the dict.
Only timeseries or filename need to be saved to recreate the original
object. If both are given, then &#8216;filename&#8217; takes precedence.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-gnome.outputter">
<span id="gnome-outputter-pygnome-outputter-classes"></span><h2><tt class="docutils literal"><span class="pre">gnome.outputter</span></tt> &#8211; pyGNOME outputter classes<a class="headerlink" href="#module-gnome.outputter" title="Permalink to this headline">¶</a></h2>
<p>outputters.py</p>
<dl class="docutils">
<dt>module to define classes for GNOME output:</dt>
<dd><ul class="first last simple">
<li>base class</li>
<li>saving to netcdf</li>
<li>saving to other formats ?</li>
</ul>
</dd>
</dl>
<dl class="class">
<dt id="gnome.outputter.Outputter">
<em class="property">class </em><tt class="descclassname">gnome.outputter.</tt><tt class="descname">Outputter</tt><big>(</big><em>cache=None</em>, <em>output_timestep=None</em>, <em>output_zero_step=True</em>, <em>output_last_step=True</em><big>)</big><a class="reference internal" href="_modules/gnome/outputter.html#Outputter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.outputter.Outputter" title="Permalink to this definition">¶</a></dt>
<dd><p>base class for all outputters</p>
<p>sets attributes for all outputters, like output_timestep, cache</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>cache</strong> &#8211; sets the cache object from which to read data. The model
will automatically set this param</li>
<li><strong>output_timestep</strong> (<em>timedelta object</em>) &#8211; default is None in which case everytime the
write_output is called, output is written. If set, then output is
written every output_timestep starting from model_start_time.</li>
<li><strong>output_zero_step</strong> (<em>boolean</em>) &#8211; default is True. If True then output for
initial step (showing initial release conditions) is written
regardless of output_timestep</li>
<li><strong>output_last_step</strong> (<em>boolean</em>) &#8211; default is True. If True then output for
final step is written regardless of output_timestep</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="gnome.outputter.Outputter.model_step_is_done">
<tt class="descname">model_step_is_done</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/gnome/outputter.html#Outputter.model_step_is_done"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.outputter.Outputter.model_step_is_done" title="Permalink to this definition">¶</a></dt>
<dd><p>This method gets called by the model when after everything else is done
in a time step. Put any code need for clean-up, etc.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.outputter.Outputter.prepare_for_model_run">
<tt class="descname">prepare_for_model_run</tt><big>(</big><em>model_start_time</em>, <em>num_time_steps</em>, <em>cache=None</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/gnome/outputter.html#Outputter.prepare_for_model_run"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.outputter.Outputter.prepare_for_model_run" title="Permalink to this definition">¶</a></dt>
<dd><p>This method gets called by the model at the beginning of a new run.
Do what you need to do to prepare.</p>
<p>Required arguments - if output_timestep is changed from None, these are
needed. Just make them required.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>model_start_time</strong> (<em>datetime.datetime object</em>) &#8211; (Required) start time of the model run. NetCDF
time units calculated with respect to this time.</li>
<li><strong>num_time_steps</strong> (<em>int</em>) &#8211; (Required) total number of time steps for the
run. Currently this is known and fixed.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Optional argument - incase cache needs to be updated</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>cache=None</strong> &#8211; Sets the cache object to be used for the data.
If None, it will use the one already set up.</td>
</tr>
</tbody>
</table>
<p>also added <a href="#id5"><span class="problematic" id="id6">**</span></a>kwargs since a derived class like NetCDFOutput could
require additional variables.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.outputter.Outputter.prepare_for_model_step">
<tt class="descname">prepare_for_model_step</tt><big>(</big><em>time_step</em>, <em>model_time</em><big>)</big><a class="reference internal" href="_modules/gnome/outputter.html#Outputter.prepare_for_model_step"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.outputter.Outputter.prepare_for_model_step" title="Permalink to this definition">¶</a></dt>
<dd><p>This method gets called by the model at the beginning of each time step
Do what you need to do to prepare for a new model step</p>
<p>base class method checks to see if data for model_time should be output
Set self._write_step flag to true if:</p>
<blockquote>
<div>model_time &lt; self._next_output_timestep &lt;= model_time + time_step</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>time_step</strong> &#8211; time step in seconds</li>
<li><strong>model_time</strong> &#8211; current model time as datetime object</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Note: If output_time_step is not set so every timestep is infact</dt>
<dd>written out, then there is no need to call prepare_for_model_step.
This is primarily only useful if user wants to write data post run
and write out every step_num saved in the model&#8217;s cache. In this
case, user can simply call prepare_for_model_run() followed by
write_output for every step_num in range(model.num_time_steps)</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="gnome.outputter.Outputter.rewind">
<tt class="descname">rewind</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/gnome/outputter.html#Outputter.rewind"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.outputter.Outputter.rewind" title="Permalink to this definition">¶</a></dt>
<dd><p>called by model.rewind()</p>
<p>reset variables set during prepare_for_model_run() to init conditions</p>
</dd></dl>

<dl class="method">
<dt id="gnome.outputter.Outputter.write_output">
<tt class="descname">write_output</tt><big>(</big><em>step_num</em><big>)</big><a class="reference internal" href="_modules/gnome/outputter.html#Outputter.write_output"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.outputter.Outputter.write_output" title="Permalink to this definition">¶</a></dt>
<dd><p>called by the model at the end of each time step
This is the last operation after model_step_is_done()</p>
</dd></dl>

</dd></dl>

<span class="target" id="module-gnome.renderer"></span><p>renderer.py</p>
<p>module to hold all teh map rendering code.</p>
<dl class="class">
<dt id="gnome.renderer.Renderer">
<em class="property">class </em><tt class="descclassname">gnome.renderer.</tt><tt class="descname">Renderer</tt><big>(</big><em>filename</em>, <em>images_dir</em>, <em>image_size=(800</em>, <em>600)</em>, <em>cache=None</em>, <em>output_timestep=None</em>, <em>output_zero_step=True</em>, <em>output_last_step=True</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/gnome/renderer.html#Renderer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.renderer.Renderer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#gnome.outputter.Outputter" title="gnome.outputter.Outputter"><tt class="xref py py-class docutils literal"><span class="pre">gnome.outputter.Outputter</span></tt></a>, <tt class="xref py py-class docutils literal"><span class="pre">gnome.utilities.map_canvas.MapCanvas</span></tt>, <tt class="xref py py-class docutils literal"><span class="pre">gnome.utilities.serializable.Serializable</span></tt></p>
<p>Map Renderer</p>
<dl class="docutils">
<dt>class that writes map images for GNOME results:</dt>
<dd>writes the frames for the LE &#8220;movies&#8221;, etc.</dd>
</dl>
<p>Init the image renderer.</p>
<p>Following args are passed to base class Outputter&#8217;s init:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>cache</strong> &#8211; sets the cache object from which to read data. The model
will automatically set this param</li>
<li><strong>output_timestep</strong> (<em>timedelta object</em>) &#8211; default is None in which case everytime the
write_output is called, output is written. If set, then output is
written every output_timestep starting from model_start_time.</li>
<li><strong>output_zero_step</strong> (<em>boolean</em>) &#8211; default is True. If True then output for
initial step (showing initial release conditions) is written
regardless of output_timestep</li>
<li><strong>output_last_step</strong> (<em>boolean</em>) &#8211; default is True. If True then output for
final step is written regardless of output_timestep</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Remaining kwargs are passed onto baseclass&#8217;s __init__ with a direct
call: MapCanvas.__init__(..)</p>
<p>Optional parameters (kwargs)
:param projection_class: gnome.utilities.projections class to use.</p>
<blockquote>
<div>Default is gnome.utilities.projections.FlatEarthProjection</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>map_BB</strong> &#8211; map bounding box. Default is to use
land_polygons.bounding_box. If land_polygons is None, then this is
the whole world, defined by ((-180,-90),(180, 90))</li>
<li><strong>viewport</strong> &#8211; viewport of map &#8211; what gets drawn and on what scale.
Default is to set viewport = map_BB</li>
<li><strong>image_mode</strong> &#8211; Image mode (&#8216;P&#8217; for palette or &#8216;L&#8217; for Black and
White image). BW_MapCanvas inherits from MapCanvas and sets the
mode to &#8216;L&#8217;. Default image_mode is &#8216;P&#8217;.</li>
<li><strong>id</strong> &#8211; unique identifier for a instance of this class (UUID given
as a string). This is used when loading an object from a persisted
model.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="classmethod">
<dt id="gnome.renderer.Renderer.new_from_dict">
<em class="property">classmethod </em><tt class="descname">new_from_dict</tt><big>(</big><em>dict_</em><big>)</big><a class="reference internal" href="_modules/gnome/renderer.html#Renderer.new_from_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.renderer.Renderer.new_from_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>change projection_type from string to correct type</p>
</dd></dl>

<dl class="method">
<dt id="gnome.renderer.Renderer.prepare_for_model_run">
<tt class="descname">prepare_for_model_run</tt><big>(</big><em>model_start_time</em>, <em>num_time_steps</em>, <em>cache=None</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/gnome/renderer.html#Renderer.prepare_for_model_run"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.renderer.Renderer.prepare_for_model_run" title="Permalink to this definition">¶</a></dt>
<dd><p>prepares the renderer for a model run.</p>
<dl class="docutils">
<dt>Parameters passed to base class:</dt>
<dd>model_start_time, num_time_steps, cache</dd>
</dl>
<p>In this case, it draws the background image and clears the previous
images. If you want to save the previous images, a new output dir
should be set.</p>
<p>Does not take any other input arguments; however, to keep the interface
the same for all outputters, define <a href="#id7"><span class="problematic" id="id8">**</span></a>kwargs for now.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.renderer.Renderer.projection_class_to_dict">
<tt class="descname">projection_class_to_dict</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/gnome/renderer.html#Renderer.projection_class_to_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.renderer.Renderer.projection_class_to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>store projection class as a string for now since that is all that
is required for persisting</p>
</dd></dl>

<dl class="method">
<dt id="gnome.renderer.Renderer.write_output">
<tt class="descname">write_output</tt><big>(</big><em>step_num</em><big>)</big><a class="reference internal" href="_modules/gnome/renderer.html#Renderer.write_output"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.renderer.Renderer.write_output" title="Permalink to this definition">¶</a></dt>
<dd><p>Render the map image, according to current parameters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>step_num</strong> &#8211; the model step number you want rendered.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A dict of info about this step number if this step
is to be output, None otherwise.<blockquote>
<div>&#8216;step_num&#8217;: step_num
&#8216;image_filename&#8217;: filename
&#8216;time_stamp&#8217;: time_stamp # as ISO string</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p>use super to call base class write_output method</p>
<p>If this is last step, then data is written; otherwise
prepare_for_model_step determines whether to write the output for
this step based on output_timestep</p>
</dd></dl>

</dd></dl>

<span class="target" id="module-gnome.netcdf_outputter"></span><p>NetCDF outputter - follows the interface defined by gnome.Outputter for a
NetCDF output writer</p>
<dl class="class">
<dt id="gnome.netcdf_outputter.NetCDFOutput">
<em class="property">class </em><tt class="descclassname">gnome.netcdf_outputter.</tt><tt class="descname">NetCDFOutput</tt><big>(</big><em>netcdf_filename</em>, <em>all_data=False</em>, <em>netcdf_format='NETCDF4'</em>, <em>compress=True</em>, <em>id=None</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/gnome/netcdf_outputter.html#NetCDFOutput"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.netcdf_outputter.NetCDFOutput" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#gnome.outputter.Outputter" title="gnome.outputter.Outputter"><tt class="xref py py-class docutils literal"><span class="pre">gnome.outputter.Outputter</span></tt></a>, <tt class="xref py py-class docutils literal"><span class="pre">gnome.utilities.serializable.Serializable</span></tt></p>
<p>A NetCDFOutput object is used to write the model&#8217;s data to a NetCDF file.
It inherits from Outputter class and implements the same interface.</p>
<p>This class is meant to be used within the Model, to be added to list of
outputters.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">gnome</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">Model</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="o">.</span><span class="n">outputters</span> <span class="o">+=</span> <span class="n">gnome</span><span class="o">.</span><span class="n">netcdf_outputter</span><span class="o">.</span><span class="n">NetCDFOutput</span><span class="p">(</span>
<span class="go">            os.path.join(base_dir,&#39;sample_model.nc&#39;), all_data=True)</span>
</pre></div>
</div>
<p>&#8216;all_data&#8217; flag is used to either output all the data arrays defined in
model.spills or only the standard data.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">cf_attributes and data_vars are static members. cf_attributes is a dict
that contains the global attributes per CF convention
data_vars is a dict used to define NetCDF variables.
There is also a list called &#8216;standard_data&#8217;. Since the names of the
netcdf variables are different from the names in the SpillContainer
data_arrays, this simply lists the names of data_arrays that are part of
standard data. When writing &#8216;all_data&#8217;, these data arrays are skipped.</p>
</div>
<dl class="function">
<dt>
<tt class="descname">__init__(netcdf_filename, cache=None, all_data=False,</tt></dt>
<dt>
<tt class="descname">id=None)</tt></dt>
<dd></dd></dl>

<p>Constructor for Net_CDFOutput object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>netcdf_filename</strong> (<em>str. or unicode</em>) &#8211; Required parameter. The filename in which to
store the NetCDF data.</li>
<li><strong>all_data</strong> (<em>bool</em>) &#8211; If true, write all data to NetCDF, otherwise write
only standard data. Default is False.</li>
<li><strong>id</strong> &#8211; Unique Id identifying the newly created mover (a UUID as a
string). This is used when loading an object from a persisted
state. User should never have to set this.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Optional arguments (kwargs):</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>cache</strong> &#8211; sets the cache object from which to read data. The model
will automatically set this param</li>
<li><strong>output_timestep</strong> (<em>timedelta object</em>) &#8211; default is None in which case everytime the
write_output is called, output is written. If set, then output is
written every output_timestep starting from model_start_time.</li>
<li><strong>output_zero_step</strong> (<em>boolean</em>) &#8211; default is True. If True then output for
initial step (showing initial release conditions) is written
regardless of output_timestep</li>
<li><strong>output_last_step</strong> (<em>boolean</em>) &#8211; default is True. If True then output for
final step is written regardless of output_timestep</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>use super to pass optional <a href="#id9"><span class="problematic" id="id10">**</span></a>kwargs to base class __init__ method</p>
<dl class="attribute">
<dt id="gnome.netcdf_outputter.NetCDFOutput.id">
<tt class="descname">id</tt><a class="reference internal" href="_modules/gnome/netcdf_outputter.html#NetCDFOutput.id"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.netcdf_outputter.NetCDFOutput.id" title="Permalink to this definition">¶</a></dt>
<dd><p>Function returns the unique id to identify the object,</p>
</dd></dl>

<dl class="classmethod">
<dt id="gnome.netcdf_outputter.NetCDFOutput.new_from_dict">
<em class="property">classmethod </em><tt class="descname">new_from_dict</tt><big>(</big><em>dict_</em><big>)</big><a class="reference internal" href="_modules/gnome/netcdf_outputter.html#NetCDFOutput.new_from_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.netcdf_outputter.NetCDFOutput.new_from_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>creates a new object from dictionary</p>
</dd></dl>

<dl class="method">
<dt id="gnome.netcdf_outputter.NetCDFOutput.prepare_for_model_run">
<tt class="descname">prepare_for_model_run</tt><big>(</big><em>model_start_time</em>, <em>num_time_steps</em>, <em>cache=None</em>, <em>uncertain=False</em>, <em>spills=None</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/gnome/netcdf_outputter.html#NetCDFOutput.prepare_for_model_run"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.netcdf_outputter.NetCDFOutput.prepare_for_model_run" title="Permalink to this definition">¶</a></dt>
<dd><dl class="function">
<dt>
<tt class="descname">prepare_for_model_run(model_start_time,</tt></dt>
<dt>
<tt class="descname">num_time_steps, cache=None, uncertain=False, spills=None,</tt></dt>
<dt>
<tt class="descname">**kwargs)</tt></dt>
<dd></dd></dl>

<p>Write global attributes and define dimensions and variables for NetCDF
file. This must be done in prepare_for_model_run because if model state
changes, it is rewound and re-run from the beginning.</p>
<p>This takes more than standard &#8216;cache&#8217; argument. Some of these are
required arguments - they contain None for defaults because non-default
argument cannot follow default argument. Since cache is already 2nd
positional argument for Renderer object, the required non-default
arguments must be defined following &#8216;cache&#8217;.</p>
<p>If uncertainty is on, then UncertainSpillPair object contains
identical _data_arrays in both certain and uncertain SpillContainer&#8217;s,
the data itself is different, but they contain the same type of data
arrays.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>uncertain</strong> (<em>bool</em>) &#8211; Default is False. Model automatically sets this based
on whether uncertainty is on or off. If this is True then a
uncertain data is written to netcdf_filename + &#8216;_uncertain.nc&#8217;</li>
<li><strong>spills</strong> (<em>gnome.spill_container.SpillContainerPair object.</em>) &#8211; If &#8216;all_data&#8217; flag is True, then model must provide the
model.spills object (SpillContainerPair object) so NetCDF variables
can be defined for the remaining data arrays. If spills is None,
but all_data flag is True, a ValueError will be raised. It does not
make sense to write &#8216;all_data&#8217; but not provide &#8216;model.spills&#8217;.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Does not take any other input arguments; however, to keep the interface</dt>
<dd>the same for all outputters, define <a href="#id11"><span class="problematic" id="id12">**</span></a>kwargs incase future
outputters require different arguments.</dd>
</dl>
<p>use super to pass model_start_time, num_time_steps, cache=None and
remaining <a href="#id13"><span class="problematic" id="id14">**</span></a>kwargs to base class method</p>
</dd></dl>

<dl class="staticmethod">
<dt id="gnome.netcdf_outputter.NetCDFOutput.read_data">
<em class="property">static </em><tt class="descname">read_data</tt><big>(</big><em>netcdf_file</em>, <em>index=0</em>, <em>all_data=False</em><big>)</big><a class="reference internal" href="_modules/gnome/netcdf_outputter.html#NetCDFOutput.read_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.netcdf_outputter.NetCDFOutput.read_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Read and create standard data arrays for a netcdf file that was created
with NetCDFOutput class. Make it a static method since it is
independent of an instance of the Outputter. The method is put with
this class because the NetCDF functionality for PyGnome data with CF
standard is captured here.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>netcdf_file</strong> (<em>str</em>) &#8211; Name of the NetCDF file from which to read the data</li>
<li><strong>index</strong> (<em>int</em>) &#8211; Index of the &#8216;time&#8217; variable (or time_step) for which
data is desired. Default is 0 so it returns data associated with
first timestamp.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a dict containing &#8216;positions&#8217;, &#8216;status_codes&#8217;, &#8216;spill_num&#8217;.
Currently, this is standard data.</p>
</td>
</tr>
</tbody>
</table>
<p>Standard data arrays are numpy arrays of size N, where N is number of
particles released at time step of interest:</p>
<blockquote>
<div><p>&#8216;current_time_stamp&#8217;: datetime object associated with this data
&#8216;positions&#8217;         : NX3 array. Corresponds with NetCDF variables</p>
<blockquote>
<div>&#8216;longitude&#8217;, &#8216;latitude&#8217;, &#8216;depth&#8217;</div></blockquote>
<dl class="docutils">
<dt>&#8216;status_codes&#8217; <span class="classifier-delimiter">:</span> <span class="classifier">NX1 array. Corresponds with NetCDF variable</span></dt>
<dd>&#8216;status&#8217;</dd>
<dt>&#8216;spill_num&#8217; <span class="classifier-delimiter">:</span> <span class="classifier">NX1 array. Corresponds with NetCDF variable</span></dt>
<dd>&#8216;id&#8217;</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="gnome.netcdf_outputter.NetCDFOutput.rewind">
<tt class="descname">rewind</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/gnome/netcdf_outputter.html#NetCDFOutput.rewind"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.netcdf_outputter.NetCDFOutput.rewind" title="Permalink to this definition">¶</a></dt>
<dd><p>if rewound, delete both the files and expect prepare_for_model_run to
be called since rewind means start from beginning.</p>
<p>Also call base class rewind to reset internal variables. Using super</p>
</dd></dl>

<dl class="method">
<dt id="gnome.netcdf_outputter.NetCDFOutput.write_output">
<tt class="descname">write_output</tt><big>(</big><em>step_num</em><big>)</big><a class="reference internal" href="_modules/gnome/netcdf_outputter.html#NetCDFOutput.write_output"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.netcdf_outputter.NetCDFOutput.write_output" title="Permalink to this definition">¶</a></dt>
<dd><p>write NetCDF output at the end of the step</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>step_num</strong> (<em>int</em>) &#8211; The model&#8217;s current timestep for which data is being
written. model.current_time_step</td>
</tr>
</tbody>
</table>
<p>use super to call base class write_output method</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-gnome.persist">
<span id="gnome-persist-pygnome-persistance-classes"></span><h2><tt class="docutils literal"><span class="pre">gnome.persist</span></tt> &#8211; pyGNOME persistance classes<a class="headerlink" href="#module-gnome.persist" title="Permalink to this headline">¶</a></h2>
<p>Default behavior:
Apply colander monkey patch by default</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#"><tt class="docutils literal"><span class="pre">pyGNOME</span></tt> Reference</a><ul>
<li><a class="reference internal" href="#basic-structure">Basic Structure</a></li>
<li><a class="reference internal" href="#module-gnome">Class Reference:</a></li>
<li><a class="reference internal" href="#module-gnome.model"><tt class="docutils literal"><span class="pre">gnome.model</span></tt> &#8211; the pyGNOME model class</a></li>
<li><a class="reference internal" href="#module-gnome.map"><tt class="docutils literal"><span class="pre">gnome.map</span></tt> &#8211; the pyGNOME map class</a></li>
<li><a class="reference internal" href="#module-gnome.spill"><tt class="docutils literal"><span class="pre">gnome.spill</span></tt> &#8211; the pyGNOME spill class</a></li>
<li><a class="reference internal" href="#module-gnome.movers"><tt class="docutils literal"><span class="pre">gnome.movers</span></tt> &#8211; pyGNOME mover classes</a></li>
<li><a class="reference internal" href="#module-gnome.environment"><tt class="docutils literal"><span class="pre">gnome.weather</span></tt> &#8211; pyGNOME environment classes</a></li>
<li><a class="reference internal" href="#module-gnome.outputter"><tt class="docutils literal"><span class="pre">gnome.outputter</span></tt> &#8211; pyGNOME outputter classes</a></li>
<li><a class="reference internal" href="#module-gnome.persist"><tt class="docutils literal"><span class="pre">gnome.persist</span></tt> &#8211; pyGNOME persistance classes</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="tutorial_2.html"
                        title="previous chapter">CATS currents</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="units.html"
                        title="next chapter">Units used in GNOME / PyGNOME</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/reference.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="units.html" title="Units used in GNOME / PyGNOME"
             >next</a> |</li>
        <li class="right" >
          <a href="tutorial_2.html" title="CATS currents"
             >previous</a> |</li>
        <li><a href="index.html">pyGNOME 0.1.1 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012, NOAA Emergecny Response Division.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>