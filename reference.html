<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>PyGnome Reference &mdash; pyGNOME 0.1.1 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.1.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://c328740.ssl.cf1.rackcdn.com/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="pyGNOME 0.1.1 documentation" href="index.html" />
    <link rel="next" title="Units used in GNOME / PyGNOME" href="units.html" />
    <link rel="prev" title="CATS currents" href="tutorial_2.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="units.html" title="Units used in GNOME / PyGNOME"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="tutorial_2.html" title="CATS currents"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">pyGNOME 0.1.1 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="pygnome-reference">
<span id="reference"></span><h1>PyGnome Reference<a class="headerlink" href="#pygnome-reference" title="Permalink to this headline">¶</a></h1>
<p>PyGnomeis a wrapper around a set of C++ libraries. THe C++ code is designed to
be used by itself, or from Python, though using it in Python is easier. The API
is perhaps a bit klunky &#8211; the C++ code was all orginally written as part of a
monolithic GUI program &#8211; we have separated the GUI parts, and cleaned up the
API so that the pieces can be used individually.</p>
<div class="section" id="basic-structure">
<h2>Basic Structure<a class="headerlink" href="#basic-structure" title="Permalink to this headline">¶</a></h2>
<p>There are a handlful of core base classes you need to use PyGnome for anything
useful:</p>
<dl class="docutils">
<dt>a model:</dt>
<dd>This is the main class that keeps track of all the pieces, runs the loop
through time, etc. The code comes with a full-featured version &#8211; you may
want a simpler one if you aren&#8217;t doing a full-on oil spill model.</dd>
<dt>movers:</dt>
<dd>These are classes that represent anything that moves a particle.  Or in fact,
alters a particle in any way (the name mover is a bit historical &#8211; they
used to only move particles...).  Examples include surface winds, currents
(from a variety of sources), weathering processes, etc. &#8211; this is where the
real work is done.  Each mover&#8217;s action is essentially linear superposed
with the others. i.e at each time step, the model loops through all the
movers, and passes the spill objects to be acted on.
At the C++ level, each mover has a <cite>get_move</cite> method that takes the current
time, model time step, and pointers to the arrays of particle properties it
needs.  At the Python level, the get_move method takes a spill object, and
the required arrays are extracted from the spill object &#8211; this lets us pass
to a mover only the data that it really needs, and lets us use Python for
the dynamic parts &#8211; making sure that the data needed exists.</dd>
<dt>spills:</dt>
<dd><p class="first">A spill class is a class that holds a set of particles and various
information about them. Each of the particle properties are stored as numpy
arrays (in a dict) &#8211; so that for a given model setup, the spill only needs
to have the properties required, and the properties used by a given mover
(and only those) can be passed in as a C pointer to the mover code.  At the
very least, each spill has a set of particle position arrays.</p>
<p>There may be multiple spills in a model set-up, but for efficiency&#8217;s sake,
each spill usually is a set of 1000 or so particles that share various
properties.</p>
<p class="last">Each spill is a composition of the type of substance spilled (ElementType)
and how elements are released (instantaneous, continuous, etc).</p>
</dd>
<dt>a map:</dt>
<dd>A map keeps track of where land and water are.  The simplest map is all the
earth with no land.  It has methods to ask if a location is on land, if a
location is &#8220;spillable&#8221;, etc.  The most commonly used map for surface oil
spills is intialized with a <cite>*.bna</cite> file describing polygons of land &#8211; this
is rasterized into a land-eater bitmap.  During the run, the model calls the
<cite>&#8216;beach_LEs</cite> method, which determines which particles have hit land in the
last time step, and sets those particles to &#8220;beached&#8221;.</dd>
</dl>
</div>
<div class="section" id="class-reference">
<h2>Class Reference:<a class="headerlink" href="#class-reference" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-gnome.model">
<span id="gnome-model-the-pygnome-model-class"></span><h2><code class="docutils literal"><span class="pre">gnome.model</span></code> &#8211; the PyGnome model class<a class="headerlink" href="#module-gnome.model" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="gnome.model.Model">
<em class="property">class </em><code class="descclassname">gnome.model.</code><code class="descname">Model</code><span class="sig-paren">(</span><em>time_step=None</em>, <em>start_time=datetime.datetime(2015</em>, <em>6</em>, <em>12</em>, <em>15</em>, <em>0)</em>, <em>duration=datetime.timedelta(1)</em>, <em>weathering_substeps=1</em>, <em>map=None</em>, <em>uncertain=False</em>, <em>cache_enabled=False</em>, <em>name=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/model.html#Model"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.model.Model" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#gnome.utilities.serializable.Serializable" title="gnome.utilities.serializable.Serializable"><code class="xref py py-class docutils literal"><span class="pre">gnome.utilities.serializable.Serializable</span></code></a></p>
<p>PyGnome Model Class</p>
<p>Initializes a model.
All arguments have a default.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>time_step=timedelta(minutes=15)</strong> &#8211; model time step in seconds
or as a timedelta object</li>
<li><strong>start_time=datetime.now()</strong> &#8211; start time of model, datetime
object. Rounded to the nearest hour.</li>
<li><strong>duration=timedelta(days=1)</strong> &#8211; How long to run the model,
a timedelta object.</li>
<li><strong>weathering_substeps=1</strong> (<em>int</em>) &#8211; How many weathering substeps to
run inside a single model time step.</li>
<li><strong>map=gnome.map.GnomeMap()</strong> &#8211; The land-water map.</li>
<li><strong>uncertain=False</strong> &#8211; Flag for setting uncertainty.</li>
<li><strong>cache_enabled=False</strong> &#8211; Flag for setting whether the model should
cache results to disk.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="classmethod">
<dt id="gnome.model.Model.new_from_dict">
<em class="property">classmethod </em><code class="descname">new_from_dict</code><span class="sig-paren">(</span><em>dict_</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/model.html#Model.new_from_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.model.Model.new_from_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Restore model from previously persisted _state</p>
</dd></dl>

<dl class="method">
<dt id="gnome.model.Model.reset">
<code class="descname">reset</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/model.html#Model.reset"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.model.Model.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Resets model to defaults &#8211; Caution &#8211; clears all movers, spills, etc.
Takes same keyword arguments as <code class="xref py py-meth docutils literal"><span class="pre">__init__()</span></code></p>
</dd></dl>

<dl class="method">
<dt id="gnome.model.Model.rewind">
<code class="descname">rewind</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/model.html#Model.rewind"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.model.Model.rewind" title="Permalink to this definition">¶</a></dt>
<dd><p>Rewinds the model to the beginning (start_time)</p>
</dd></dl>

<dl class="attribute">
<dt id="gnome.model.Model.uncertain">
<code class="descname">uncertain</code><a class="headerlink" href="#gnome.model.Model.uncertain" title="Permalink to this definition">¶</a></dt>
<dd><p>Uncertainty attribute of the model. If flag is toggled, rewind model</p>
</dd></dl>

<dl class="attribute">
<dt id="gnome.model.Model.cache_enabled">
<code class="descname">cache_enabled</code><a class="headerlink" href="#gnome.model.Model.cache_enabled" title="Permalink to this definition">¶</a></dt>
<dd><p>If True, then generated data is cached</p>
</dd></dl>

<dl class="attribute">
<dt id="gnome.model.Model.has_weathering_uncertainty">
<code class="descname">has_weathering_uncertainty</code><a class="headerlink" href="#gnome.model.Model.has_weathering_uncertainty" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="gnome.model.Model.start_time">
<code class="descname">start_time</code><a class="headerlink" href="#gnome.model.Model.start_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Start time of the simulation</p>
</dd></dl>

<dl class="attribute">
<dt id="gnome.model.Model.time_step">
<code class="descname">time_step</code><a class="headerlink" href="#gnome.model.Model.time_step" title="Permalink to this definition">¶</a></dt>
<dd><p>time step over which the dynamics is computed</p>
</dd></dl>

<dl class="attribute">
<dt id="gnome.model.Model.current_time_step">
<code class="descname">current_time_step</code><a class="headerlink" href="#gnome.model.Model.current_time_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Current timestep of the simulation</p>
</dd></dl>

<dl class="attribute">
<dt id="gnome.model.Model.duration">
<code class="descname">duration</code><a class="headerlink" href="#gnome.model.Model.duration" title="Permalink to this definition">¶</a></dt>
<dd><p>total duration of the model run</p>
</dd></dl>

<dl class="attribute">
<dt id="gnome.model.Model.map">
<code class="descname">map</code><a class="headerlink" href="#gnome.model.Model.map" title="Permalink to this definition">¶</a></dt>
<dd><p>land water map used for simulation</p>
</dd></dl>

<dl class="attribute">
<dt id="gnome.model.Model.num_time_steps">
<code class="descname">num_time_steps</code><a class="headerlink" href="#gnome.model.Model.num_time_steps" title="Permalink to this definition">¶</a></dt>
<dd><p>Read only attribute
computed number of timesteps based on py:attribute:<cite>duration</cite> and
py:attribute:<cite>time_step</cite></p>
</dd></dl>

<dl class="method">
<dt id="gnome.model.Model.contains_object">
<code class="descname">contains_object</code><span class="sig-paren">(</span><em>obj_id</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/model.html#Model.contains_object"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.model.Model.contains_object" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="gnome.model.Model.find_by_class">
<code class="descname">find_by_class</code><span class="sig-paren">(</span><em>obj</em>, <em>collection</em>, <em>ret_all=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/model.html#Model.find_by_class"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.model.Model.find_by_class" title="Permalink to this definition">¶</a></dt>
<dd><p>Look for an object that isinstance() of obj in specified colleciton.
By default, it will return the first object of this type.
To get all obects of this type, set ret_all to True</p>
</dd></dl>

<dl class="method">
<dt id="gnome.model.Model.find_by_attr">
<code class="descname">find_by_attr</code><span class="sig-paren">(</span><em>attr</em>, <em>value</em>, <em>collection</em>, <em>allitems=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/model.html#Model.find_by_attr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.model.Model.find_by_attr" title="Permalink to this definition">¶</a></dt>
<dd><p>find first object in collection where the &#8216;attr&#8217; attribute matches
&#8216;value&#8217;. This is primarily used to find &#8216;wind&#8217;, &#8216;water&#8217;, &#8216;waves&#8217;
objects in environment collection. Use the &#8216;_ref_as&#8217; attribute to
search.</p>
<p>Ignore AttributeError since all objects in collection may not contain
the attribute over which we are searching.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>attr</strong> (<em>str</em>) &#8211; attribute whose value must match</li>
<li><strong>value</strong> (<em>str</em>) &#8211; desired value of the attribute</li>
<li><strong>collection</strong> (<em>OrderedCollection</em>) &#8211; the ordered collection in which
to search</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.model.Model.setup_model_run">
<code class="descname">setup_model_run</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/model.html#Model.setup_model_run"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.model.Model.setup_model_run" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets up each mover for the model run</p>
</dd></dl>

<dl class="method">
<dt id="gnome.model.Model.setup_time_step">
<code class="descname">setup_time_step</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/model.html#Model.setup_time_step"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.model.Model.setup_time_step" title="Permalink to this definition">¶</a></dt>
<dd><p>sets up everything for the current time_step:</p>
</dd></dl>

<dl class="method">
<dt id="gnome.model.Model.move_elements">
<code class="descname">move_elements</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/model.html#Model.move_elements"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.model.Model.move_elements" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Moves elements:</dt>
<dd><ul class="first last simple">
<li>loops through all the movers. and moves the elements</li>
<li>sets new_position array for each spill</li>
<li>calls the beaching code to beach the elements that need beaching.</li>
<li>sets the new position</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="gnome.model.Model.weather_elements">
<code class="descname">weather_elements</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/model.html#Model.weather_elements"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.model.Model.weather_elements" title="Permalink to this definition">¶</a></dt>
<dd><p>Weathers elements:</p>
<ul class="simple">
<li>loops through all the weatherers, passing in the spill_container
and the time range</li>
<li>a weatherer modifies the data arrays in the spill container, so a
particular time range should not be run multiple times.  It is
expected that we are processing a sequence of contiguous time ranges.</li>
<li>Note: If there are multiple sequential weathering processes, some
inaccuracy could occur.  A proposed solution is to
&#8216;super-sample&#8217; the model time step so that it will be replaced
with many smaller time steps.  We&#8217;ll have to see if this pans
out in practice.</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="gnome.model.Model.step_is_done">
<code class="descname">step_is_done</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/model.html#Model.step_is_done"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.model.Model.step_is_done" title="Permalink to this definition">¶</a></dt>
<dd><p>Loop through movers and weatherers and call model_step_is_done</p>
<p>Remove elements that marked for removal</p>
<p>Output data</p>
</dd></dl>

<dl class="method">
<dt id="gnome.model.Model.write_output">
<code class="descname">write_output</code><span class="sig-paren">(</span><em>valid</em>, <em>messages=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/model.html#Model.write_output"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.model.Model.write_output" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="gnome.model.Model.step">
<code class="descname">step</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/model.html#Model.step"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.model.Model.step" title="Permalink to this definition">¶</a></dt>
<dd><p>Steps the model forward (or backward) in time. Needs testing for
hind casting.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.model.Model.next">
<code class="descname">next</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/model.html#Model.next"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.model.Model.next" title="Permalink to this definition">¶</a></dt>
<dd><p>(This method satisfies Python&#8217;s iterator and generator protocols)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">the step number</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.model.Model.full_run">
<code class="descname">full_run</code><span class="sig-paren">(</span><em>rewind=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/model.html#Model.full_run"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.model.Model.full_run" title="Permalink to this definition">¶</a></dt>
<dd><p>Do a full run of the model.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>rewind=True</strong> &#8211; whether to rewind the model first &#8211; if set to
false, model will be run from the current step to the end</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">list of outputter info dicts</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.model.Model.spills_to_dict">
<code class="descname">spills_to_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/model.html#Model.spills_to_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.model.Model.spills_to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>return the spills ordered collection for serialization</p>
</dd></dl>

<dl class="method">
<dt id="gnome.model.Model.spills_update_from_dict">
<code class="descname">spills_update_from_dict</code><span class="sig-paren">(</span><em>value</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/model.html#Model.spills_update_from_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.model.Model.spills_update_from_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>invoke SpillContainerPair().update_from_dict</p>
</dd></dl>

<dl class="method">
<dt id="gnome.model.Model.uncertain_spills_to_dict">
<code class="descname">uncertain_spills_to_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/model.html#Model.uncertain_spills_to_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.model.Model.uncertain_spills_to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>return the uncertain_spills ordered collection for serialization/save
files</p>
</dd></dl>

<dl class="method">
<dt id="gnome.model.Model.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>saveloc</em>, <em>references=None</em>, <em>name=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/model.html#Model.save"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.model.Model.save" title="Permalink to this definition">¶</a></dt>
<dd><p>save the model state in saveloc. If self.zipsave is True, then a
zip archive is created and model files are saved to the archive.</p>
<p>This overrides the base class save(). Model contains collections and
model must invoke save for each object in the collection. It must also
save the data in the SpillContainer&#8217;s if it is a mid-run save.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>saveloc</strong> (<em>A path as a string or unicode</em>) &#8211; zip archive or a valid directory. Model files are
either persisted here or a new model is re-created from the files
stored here. The files are clobbered when save() is called.</li>
<li><strong>name=None</strong> &#8211; If data is saved to zipfile (default behavior), then
this is name of zip file. For a zipfile, the model&#8217;s state is
always contained in Model.json. If zipsave is False, then model&#8217;s
json is stored in name.json</li>
<li><strong>references</strong> &#8211; dict of references mapping &#8216;id&#8217; to a string used for
the reference. The value could be a unique integer or it could be
a filename. It is upto the creator of the reference list to decide
how to reference a nested object.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">references</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.model.Model.serialize">
<code class="descname">serialize</code><span class="sig-paren">(</span><em>json_='webapi'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/model.html#Model.serialize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.model.Model.serialize" title="Permalink to this definition">¶</a></dt>
<dd><p>Serialize Model object
treat special-case attributes of Model.</p>
</dd></dl>

<dl class="classmethod">
<dt id="gnome.model.Model.deserialize">
<em class="property">classmethod </em><code class="descname">deserialize</code><span class="sig-paren">(</span><em>json_</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/model.html#Model.deserialize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.model.Model.deserialize" title="Permalink to this definition">¶</a></dt>
<dd><p>treat special-case attributes of Model.</p>
</dd></dl>

<dl class="classmethod">
<dt id="gnome.model.Model.loads">
<em class="property">classmethod </em><code class="descname">loads</code><span class="sig-paren">(</span><em>json_data</em>, <em>saveloc</em>, <em>references=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/model.html#Model.loads"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.model.Model.loads" title="Permalink to this definition">¶</a></dt>
<dd><p>loads a model from json_data</p>
<ul class="simple">
<li>load json for references from files</li>
<li>update paths of datafiles if needed</li>
<li>deserialize json_data</li>
<li>and create object with new_from_dict()</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>saveloc</strong> &#8211; location of data files</td>
</tr>
</tbody>
</table>
<p>Optional parameter</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>references</strong> &#8211; references object - if this is called by the Model,
it will pass a references object. It is not required.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.model.Model.merge">
<code class="descname">merge</code><span class="sig-paren">(</span><em>model</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/model.html#Model.merge"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.model.Model.merge" title="Permalink to this definition">¶</a></dt>
<dd><p>merge &#8216;model&#8217; into self</p>
</dd></dl>

<dl class="method">
<dt id="gnome.model.Model.validate">
<code class="descname">validate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/model.html#Model.validate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.model.Model.validate" title="Permalink to this definition">¶</a></dt>
<dd><p>invoke validate for all gnome objects contained in model
todo: should also check wind, water, waves are defined if weatherers
are defined</p>
</dd></dl>

<dl class="method">
<dt id="gnome.model.Model.set_make_default_refs">
<code class="descname">set_make_default_refs</code><span class="sig-paren">(</span><em>value</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/model.html#Model.set_make_default_refs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.model.Model.set_make_default_refs" title="Permalink to this definition">¶</a></dt>
<dd><p>make default refs for all items in (&#8216;weatherers&#8217;, &#8216;movers&#8217;,
&#8216;environment&#8217;) collections</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-gnome.map">
<span id="gnome-map-the-pygnome-map-class"></span><h2><code class="docutils literal"><span class="pre">gnome.map</span></code> &#8211; the PyGnome map class<a class="headerlink" href="#module-gnome.map" title="Permalink to this headline">¶</a></h2>
<p>An implementation of the GNOME land-water map.</p>
<p>This is a re-write of the C++ raster map approach</p>
<dl class="class">
<dt id="gnome.map.GnomeMap">
<em class="property">class </em><code class="descclassname">gnome.map.</code><code class="descname">GnomeMap</code><span class="sig-paren">(</span><em>map_bounds=None</em>, <em>spillable_area=None</em>, <em>name=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/map.html#GnomeMap"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.map.GnomeMap" title="Permalink to this definition">¶</a></dt>
<dd><p>The very simplest map for GNOME &#8211; all water
with only a bounding box for the map bounds.</p>
<p>This also serves as a description of the interface</p>
<p>This __init__ will be different for other implementations</p>
<p>Optional parameters (kwargs)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>map_bounds</strong> &#8211; The polygon bounding the map &#8211; could be larger
or smaller than the land raster</li>
<li><strong>spillable_area</strong> &#8211; The polygon bounding the spillable_area</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Note on &#8216;map_bounds&#8217;:</dt>
<dd>( (x1,y1), (x2,y2),(x3,y3),..)
An NX2 array of points that describe a polygon
if no map bounds is provided &#8211; the whole world is valid</dd>
</dl>
<dl class="method">
<dt id="gnome.map.GnomeMap.map_bounds_to_dict">
<code class="descname">map_bounds_to_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/map.html#GnomeMap.map_bounds_to_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.map.GnomeMap.map_bounds_to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>convert numpy array to a list for serializing</p>
</dd></dl>

<dl class="method">
<dt id="gnome.map.GnomeMap.map_bounds_update_from_dict">
<code class="descname">map_bounds_update_from_dict</code><span class="sig-paren">(</span><em>val</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/map.html#GnomeMap.map_bounds_update_from_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.map.GnomeMap.map_bounds_update_from_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>convert list of tuples back to numpy array</p>
</dd></dl>

<dl class="method">
<dt id="gnome.map.GnomeMap.spillable_area_to_dict">
<code class="descname">spillable_area_to_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/map.html#GnomeMap.spillable_area_to_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.map.GnomeMap.spillable_area_to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>convert numpy array to a list for serializing</p>
</dd></dl>

<dl class="method">
<dt id="gnome.map.GnomeMap.spillable_area_update_from_dict">
<code class="descname">spillable_area_update_from_dict</code><span class="sig-paren">(</span><em>val</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/map.html#GnomeMap.spillable_area_update_from_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.map.GnomeMap.spillable_area_update_from_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>convert list of tuples back to numpy array</p>
</dd></dl>

<dl class="method">
<dt id="gnome.map.GnomeMap.on_map">
<code class="descname">on_map</code><span class="sig-paren">(</span><em>coords</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/map.html#GnomeMap.on_map"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.map.GnomeMap.on_map" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>coords</strong> (<em>3-tuple of floats: (long, lat, depth) or a
NX3 numpy array</em>) &#8211; location for test.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">bool array: True if the location is on the map,
False otherwise</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Note:</dt>
<dd>coord is 3-d, but the concept of &#8220;on the map&#8221; is 2-d in this context,
so depth is ignored.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="gnome.map.GnomeMap.on_land">
<code class="descname">on_land</code><span class="sig-paren">(</span><em>coord</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/map.html#GnomeMap.on_land"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.map.GnomeMap.on_land" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>coord</strong> (<em>3-tuple of floats: (long, lat, depth)</em>) &#8211; location for test.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><ul class="simple">
<li>Always returns False&#8211; no land in this implementation</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.map.GnomeMap.in_water">
<code class="descname">in_water</code><span class="sig-paren">(</span><em>coords</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/map.html#GnomeMap.in_water"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.map.GnomeMap.in_water" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>coords</strong> (<em>3-tuple of floats: (long, lat, depth)
or an Nx3 array</em>) &#8211; location for test.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><ul class="simple">
<li>True if the point is in the water,</li>
<li>False if the point is on land (or off map?)</li>
</ul>
<p>This implementation has no land, so always True in on the map.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.map.GnomeMap.allowable_spill_position">
<code class="descname">allowable_spill_position</code><span class="sig-paren">(</span><em>coord</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/map.html#GnomeMap.allowable_spill_position"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.map.GnomeMap.allowable_spill_position" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>coord</strong> (<em>3-tuple of floats: (long, lat, depth)</em>) &#8211; location for test.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><ul class="simple">
<li>True if the point is an allowable spill position</li>
<li>False if the point is not an allowable spill position</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">it could be either off the map, or in a location that
spills aren&#8217;t allowed</p>
</div>
</dd></dl>

<dl class="method">
<dt id="gnome.map.GnomeMap.beach_elements">
<code class="descname">beach_elements</code><span class="sig-paren">(</span><em>spill</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/map.html#GnomeMap.beach_elements"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.map.GnomeMap.beach_elements" title="Permalink to this definition">¶</a></dt>
<dd><p>Determines which LEs were or weren&#8217;t beached or moved off_map.
status_code is changed to oil_status.off_maps if off the map.</p>
<p>Called by the model in the main time loop, after all movers have acted.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>spill</strong> (<code class="xref py py-class docutils literal"><span class="pre">gnome.spill_container.SpillContainer</span></code>) &#8211; current SpillContainer</td>
</tr>
</tbody>
</table>
<p>This map class has no land, so only the map check and
resurface_airborn elements is done: noting else changes.</p>
<p>subclasses that override this probably want to make sure that:</p>
<p>self.resurface_airborne_elements(spill)
self._set_off_map_status(spill)</p>
<p>are called.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.map.GnomeMap.refloat_elements">
<code class="descname">refloat_elements</code><span class="sig-paren">(</span><em>spill_container</em>, <em>time_step</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/map.html#GnomeMap.refloat_elements"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.map.GnomeMap.refloat_elements" title="Permalink to this definition">¶</a></dt>
<dd><p>This method performs the re-float logic &#8211; changing the element
status flag, and moving the element to the last known water position</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>spill_container</strong> (<code class="xref py py-class docutils literal"><span class="pre">gnome.spill_container.SpillContainer</span></code>) &#8211; current SpillContainer</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This map class has no land, and so is a no-op.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="gnome.map.GnomeMap.resurface_airborne_elements">
<code class="descname">resurface_airborne_elements</code><span class="sig-paren">(</span><em>spill_container</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/map.html#GnomeMap.resurface_airborne_elements"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.map.GnomeMap.resurface_airborne_elements" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes any elements that are left above the water surface (z &lt; 0.0)
and puts them on the surface (z == 0.0)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>spill_container</strong> (<code class="xref py py-class docutils literal"><span class="pre">gnome.spill_container.SpillContainer</span></code>) &#8211; current SpillContainer</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">While this shouldn&#8217;t occur according to the physics we&#8217;re modeling,
some movers may push elements up too high, or multiple movers may
add vertical movement that adds up to over the surface. e.g rise
velocity.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="gnome.map.RasterMap">
<em class="property">class </em><code class="descclassname">gnome.map.</code><code class="descname">RasterMap</code><span class="sig-paren">(</span><em>bitmap_array</em>, <em>projection</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/map.html#RasterMap"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.map.RasterMap" title="Permalink to this definition">¶</a></dt>
<dd><p>A land water map implemented as a raster</p>
<p>This one uses a numpy array of uint8, so there are 8 bits to choose from...</p>
<p>It requires a constant refloat half-life in hours</p>
<p>This will usually be initialized in a sub-class (from a BNA, etc)
NOTE: Nothing new added to _state attribute for serialization</p>
<p>create a new RasterMap</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>bitmap_array</strong> (<em>a (W,H) numpy array of type uint8</em>) &#8211; A numpy array that stores the land-water map</li>
<li><strong>projection</strong> (<code class="xref py py-class docutils literal"><span class="pre">gnome.map_canvas.Projection</span></code>) &#8211; A Projection object &#8211; used to convert from
lat-long to pixels in the array</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Optional arguments (kwargs)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>refloat_halflife</strong> (<em>float. Units are hours</em>) &#8211; The halflife for refloating off land
&#8211; assumed to be the same for all land.
0.0 means all refloat every time step
&lt; 0.0 means never re-float.</li>
<li><strong>map_bounds</strong> (<em>(N,2) numpy array of floats</em>) &#8211; The polygon bounding the map &#8211; could be larger
or smaller than the land raster</li>
<li><strong>spillable_area</strong> (<em>(N,2) numpy array of floats</em>) &#8211; The polygon bounding the spillable_area</li>
<li><strong>id</strong> (<em>string</em>) &#8211; unique ID of the object. Using UUID as a string.
This is only used when loading object from save file.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="gnome.map.RasterMap.save_as_image">
<code class="descname">save_as_image</code><span class="sig-paren">(</span><em>filename</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/map.html#RasterMap.save_as_image"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.map.RasterMap.save_as_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Save the land-water raster as a PNG save_as_image</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>filename</strong> &#8211; the name of the file to save to.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.map.RasterMap.on_land">
<code class="descname">on_land</code><span class="sig-paren">(</span><em>coord</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/map.html#RasterMap.on_land"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.map.RasterMap.on_land" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>coord</strong> (<em>3-tyuple of floats &#8211; (long, lat, depth)</em>) &#8211; (long, lat, depth) location &#8211; depth is ignored here.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><ul class="simple">
<li>1 if point on land</li>
<li>0 if not on land</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">to_pixel() converts to array of points...</p>
</div>
</dd></dl>

<dl class="method">
<dt id="gnome.map.RasterMap.in_water">
<code class="descname">in_water</code><span class="sig-paren">(</span><em>coord</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/map.html#RasterMap.in_water"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.map.RasterMap.in_water" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>checks if it&#8217;s on the map, first.</dt>
<dd>(depth is ignored in this version)</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>coord</strong> &#8211; (lon, lat, depth) coordinate</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">true if the point given by coord is in the water</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.map.RasterMap.beach_elements">
<code class="descname">beach_elements</code><span class="sig-paren">(</span><em>spill</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/map.html#RasterMap.beach_elements"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.map.RasterMap.beach_elements" title="Permalink to this definition">¶</a></dt>
<dd><p>Determines which elements were or weren&#8217;t beached.</p>
<p>Any that are beached have the beached flag set, and a
&#8220;last known water position&#8221; (lkwp) is computed</p>
<p>This version uses a modified Bresenham algorithm to find out
which pixels the LE may have crossed.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>spill</strong> (<code class="xref py py-class docutils literal"><span class="pre">gnome.spill_container.SpillContainer</span></code>
It must have the following data arrays:
(&#8216;prev_position&#8217;, &#8216;positions&#8217;, &#8216;last_water_pt&#8217;, &#8216;status_code&#8217;)) &#8211; the current spill container</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.map.RasterMap.refloat_elements">
<code class="descname">refloat_elements</code><span class="sig-paren">(</span><em>spill_container</em>, <em>time_step</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/map.html#RasterMap.refloat_elements"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.map.RasterMap.refloat_elements" title="Permalink to this definition">¶</a></dt>
<dd><p>This method performs the re-float logic &#8211; changing the element
status flag, and moving the element to the last known water position</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>spill_container</strong> (<code class="xref py py-class docutils literal"><span class="pre">gnome.spill_container.SpillContainer</span></code>) &#8211; the current spill container</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.map.RasterMap.allowable_spill_position">
<code class="descname">allowable_spill_position</code><span class="sig-paren">(</span><em>coord</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/map.html#RasterMap.allowable_spill_position"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.map.RasterMap.allowable_spill_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true is the spill position is in the allowable spill area</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This may not be the same as in_water!</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>coord</strong> &#8211; (lon, lat, depth) coordinate</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.map.RasterMap.to_pixel_array">
<code class="descname">to_pixel_array</code><span class="sig-paren">(</span><em>coords</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/map.html#RasterMap.to_pixel_array"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.map.RasterMap.to_pixel_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Projects an array of (lon, lat) tuples onto the bitmap,
and modifies it in place to hold the corresponding projected values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>coords</strong> &#8211; a numpy array of (lon, lat, depth) points</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">a numpy array of (x, y) pixel values</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="gnome.map.MapFromBNA">
<em class="property">class </em><code class="descclassname">gnome.map.</code><code class="descname">MapFromBNA</code><span class="sig-paren">(</span><em>filename</em>, <em>raster_size=1048576</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/map.html#MapFromBNA"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.map.MapFromBNA" title="Permalink to this definition">¶</a></dt>
<dd><p>A raster land-water map, created from a BNA file</p>
<p>Creates a GnomeMap (specifically a RasterMap) from a bna file.
It is expected that you will get the spillable area and map bounds
from the BNA &#8211; if they exist</p>
<p>Required arguments:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>bna_file</strong> &#8211; full path to a bna file</li>
<li><strong>refloat_halflife</strong> &#8211; the half-life (in hours) for the re-floating.</li>
<li><strong>raster_size</strong> &#8211; the total number of pixels (bytes) to make the
raster &#8211; the actual size will match the
aspect ratio of the bounding box of the land</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Optional arguments (kwargs):</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>map_bounds</strong> &#8211; The polygon bounding the map &#8211; could be larger or
smaller than the land raster</li>
<li><strong>spillable_area</strong> &#8211; The polygon bounding the spillable_area</li>
<li><strong>id</strong> (<em>string</em>) &#8211; unique ID of the object. Using UUID as a string.
This is only used when loading object from save file.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="gnome.map.map_from_rectangular_grid">
<code class="descclassname">gnome.map.</code><code class="descname">map_from_rectangular_grid</code><span class="sig-paren">(</span><em>mask</em>, <em>lon</em>, <em>lat</em>, <em>refine=1</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/map.html#map_from_rectangular_grid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.map.map_from_rectangular_grid" title="Permalink to this definition">¶</a></dt>
<dd><p>Suitable for a rectangular, but not fully regular, grid</p>
<p>Such that it can be described by single longitude and latitude vectors</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>mask</strong> &#8211; the land-water mask as a numpy array</li>
<li><strong>lon</strong> &#8211; longitude array</li>
<li><strong>lon</strong> &#8211; latitude array</li>
<li><strong>refine=1</strong> &#8211; amount to refine grid &#8211; 4 will give 4 times the resolution</li>
<li><strong>kwargs</strong> &#8211; Other keyword arguments are passed on to RasterMap</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="gnome.map.grid_from_nc">
<code class="descclassname">gnome.map.</code><code class="descname">grid_from_nc</code><span class="sig-paren">(</span><em>filename</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/map.html#grid_from_nc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.map.grid_from_nc" title="Permalink to this definition">¶</a></dt>
<dd><p>generates a grid_mask and lat lon from a conforming netcdf file</p>
</dd></dl>

<dl class="function">
<dt id="gnome.map.map_from_rectangular_grid_nc_file">
<code class="descclassname">gnome.map.</code><code class="descname">map_from_rectangular_grid_nc_file</code><span class="sig-paren">(</span><em>filename</em>, <em>refine=1</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/map.html#map_from_rectangular_grid_nc_file"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.map.map_from_rectangular_grid_nc_file" title="Permalink to this definition">¶</a></dt>
<dd><p>builds a raster map from a rectangular grid in a netcdf file</p>
<p>only tested with the HYCOM grid</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>filename</strong> (<em>string</em>) &#8211; the full path or opendap url for the netcdf file</li>
<li><strong>refine</strong> (<em>integer</em>) &#8211; how much to refine the grid. 1 means keep it as it is, otherwise is will scale</li>
<li><strong>kwargs</strong> &#8211; other key word arguemnts &#8211; passed on to RasterMap class constructor</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="gnome.map.refine_axis">
<code class="descclassname">gnome.map.</code><code class="descname">refine_axis</code><span class="sig-paren">(</span><em>old_axis</em>, <em>refine</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/map.html#refine_axis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.map.refine_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>refines the axis be interpolating points between each axis points</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>old_axis</strong> (<em>1-d numpy array of floats</em>) &#8211; the axis values</li>
<li><strong>refine</strong> (<em>integer</em>) &#8211; amount to refine grid &#8211; 4 will give 4 times the resolution</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="gnome.map.map_from_regular_grid">
<code class="descclassname">gnome.map.</code><code class="descname">map_from_regular_grid</code><span class="sig-paren">(</span><em>grid_mask</em>, <em>lon</em>, <em>lat</em>, <em>refine=4</em>, <em>refloat_halflife=6</em>, <em>map_bounds=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/map.html#map_from_regular_grid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.map.map_from_regular_grid" title="Permalink to this definition">¶</a></dt>
<dd><p>note: poorly tested &#8211; here to save it in case we need it in the future</p>
<p>makes a raster map from a regular grid: i.e delta_lon and delta-lat are constant.</p>
</dd></dl>

</div>
<div class="section" id="module-gnome.spill">
<span id="gnome-spill-classes-in-the-spill-module"></span><h2><code class="docutils literal"><span class="pre">gnome.spill</span></code> &#8211; classes in the spill module<a class="headerlink" href="#module-gnome.spill" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="gnome.spill.Spill">
<em class="property">class </em><code class="descclassname">gnome.spill.</code><code class="descname">Spill</code><span class="sig-paren">(</span><em>release</em>, <em>element_type=None</em>, <em>substance=None</em>, <em>on=True</em>, <em>amount=None</em>, <em>units=None</em>, <em>amount_uncertainty_scale=0.0</em>, <em>name='Spill'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/spill/spill.html#Spill"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.spill.Spill" title="Permalink to this definition">¶</a></dt>
<dd><p>Models a spill</p>
<p>Spills used by the gnome model. It contains a release object, which
releases elements. It also contains an element_type object which
contains the type of substance spilled and it initializes data arrays
to non-default values (non-zero).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>release</strong> (derived from <a class="reference internal" href="#gnome.spill.Release" title="gnome.spill.Release"><code class="xref py py-class docutils literal"><span class="pre">Release</span></code></a>) &#8211; an object defining how elements are to be released</td>
</tr>
</tbody>
</table>
<p><strong>Optional parameters (kwargs):</strong></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>element_type</strong> (<a class="reference internal" href="#gnome.spill.elements.element_type.ElementType" title="gnome.spill.elements.element_type.ElementType"><code class="xref py py-class docutils literal"><span class="pre">ElementType</span></code></a>) &#8211; ElementType object defining the type
of elements that are released. These are spill specific properties
of the elements.</li>
<li><strong>on=True</strong> (<em>bool</em>) &#8211; Toggles the spill on/off.</li>
<li><strong>amount=None</strong> (<em>float</em>) &#8211; mass or volume of oil spilled.</li>
<li><strong>units=None</strong> (<em>str</em>) &#8211; must provide units for amount spilled.</li>
<li><strong>name='Spill'</strong> (<em>str</em>) &#8211; a name for the spill.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Define either volume or mass in &#8216;amount&#8217; attribute and provide
appropriate &#8216;units&#8217;. Defines default element_type as floating
elements with mass if the Spill&#8217;s &#8216;amount&#8217; property is not None.
If amount property is None, then just floating elements
(ie. &#8216;windages&#8217;)</p>
</div>
<dl class="attribute">
<dt id="gnome.spill.Spill.amount_uncertainty_scale">
<code class="descname">amount_uncertainty_scale</code><em class="property"> = None</em><a class="headerlink" href="#gnome.spill.Spill.amount_uncertainty_scale" title="Permalink to this definition">¶</a></dt>
<dd><p>fraction of area covered by oil</p>
</dd></dl>

<dl class="attribute">
<dt id="gnome.spill.Spill.name">
<code class="descname">name</code><a class="headerlink" href="#gnome.spill.Spill.name" title="Permalink to this definition">¶</a></dt>
<dd><p>define as property in base class so all objects will have a name
by default</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.Spill.set">
<code class="descname">set</code><span class="sig-paren">(</span><em>prop</em>, <em>val</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/spill/spill.html#Spill.set"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.spill.Spill.set" title="Permalink to this definition">¶</a></dt>
<dd><p>sets an existing property. The property could be of one of the
contained objects like &#8216;Release&#8217; or &#8216;ElementType&#8217;
It can also be a property of one of the initializers contained in
the &#8216;ElementType&#8217; object.</p>
<p>If the property doesn&#8217;t exist for any of these, then an error is raised
since user cannot set a property that does not exist using this method</p>
<p>For example: set(&#8216;windage_range&#8217;, (0.4, 0.4)) sets the windage_range
assuming the element_type is floating</p>
<div class="admonition-todo admonition" id="index-0">
<p class="first admonition-title">Todo</p>
<p class="last">There is an issue in that if two initializers have the same
property - could be the case if they both define a &#8216;distribution&#8217;,
then it does not know which one to return</p>
</div>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.Spill.get">
<code class="descname">get</code><span class="sig-paren">(</span><em>prop=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/spill/spill.html#Spill.get"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.spill.Spill.get" title="Permalink to this definition">¶</a></dt>
<dd><p>for get(), return all properties of embedded release object and
element_type initializer objects. If &#8216;prop&#8217; is not None, then return
the property</p>
<p>For example: get(&#8216;windage_range&#8217;) returns the &#8216;windage_range&#8217; assuming
the element_type = floating()</p>
<div class="admonition-todo admonition" id="index-1">
<p class="first admonition-title">Todo</p>
<p class="last">There is an issue in that if two initializers have the same
property - could be the case if they both define a &#8216;distribution&#8217;,
then it does not know which one to return</p>
</div>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.Spill.get_initializer_by_name">
<code class="descname">get_initializer_by_name</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/spill/spill.html#Spill.get_initializer_by_name"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.spill.Spill.get_initializer_by_name" title="Permalink to this definition">¶</a></dt>
<dd><p>get first initializer in list whose name matches &#8216;name&#8217;</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.Spill.has_initializer">
<code class="descname">has_initializer</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/spill/spill.html#Spill.has_initializer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.spill.Spill.has_initializer" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if an initializer is present in the list which sets the
data_array corresponding with &#8216;name&#8217;, otherwise returns False</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.Spill.get_initializer">
<code class="descname">get_initializer</code><span class="sig-paren">(</span><em>name=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/spill/spill.html#Spill.get_initializer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.spill.Spill.get_initializer" title="Permalink to this definition">¶</a></dt>
<dd><p>if name is None, return list of all initializers else return initializer
that sets given &#8216;name&#8217;. &#8216;name&#8217; refers to the data_array initialized by
initializer. For instance, if name=&#8217;rise_vel&#8217;, function will look in
all initializers to find the one whose array_types contain &#8216;rise_vel&#8217;.</p>
<p>If multiple initializers set &#8216;name&#8217;, then return the first one in the
list. Although nothing prevents the user from having two initializers
for the same data_array, it doesn&#8217;t make much sense.</p>
<p>The default &#8216;name&#8217; of an initializer is the data_array that a mover
requires and that the initializer is setting. For instance,</p>
<blockquote>
<div>init = InitRiseVelFromDist()
init.name is &#8216;rise_vel&#8217; by default</div></blockquote>
<p>is an initializer that sets the &#8216;rise_vel&#8217; if a RiseVelocityMover is
included in the Model. User can change the name of the initializer</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.Spill.set_initializer">
<code class="descname">set_initializer</code><span class="sig-paren">(</span><em>init</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/spill/spill.html#Spill.set_initializer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.spill.Spill.set_initializer" title="Permalink to this definition">¶</a></dt>
<dd><p>set/add given initializer. Function looks for first initializer in list
with same array_types and replaces it if found else it appends this to
list of initializers.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">nothing prevents user from defining two initializers that
set the same data_arrays; however, there isn&#8217;t a use case for it</p>
</div>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.Spill.del_initializer">
<code class="descname">del_initializer</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/spill/spill.html#Spill.del_initializer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.spill.Spill.del_initializer" title="Permalink to this definition">¶</a></dt>
<dd><p>delete the initializer with given &#8216;name&#8217;</p>
<p>The default &#8216;name&#8217; of an initializer is the data_array that a mover
requires and that the initializer is setting. For instance,
the following is an initializer that sets the &#8216;rise_vel&#8217; if a
RiseVelocityMover is included in the Model.</p>
<blockquote>
<div>init = InitRiseVelFromDist()
init.name is &#8216;rise_vel&#8217; by default</div></blockquote>
<p>If name = &#8216;rise_vel&#8217;, all initializers with this name will be deleted</p>
</dd></dl>

<dl class="attribute">
<dt id="gnome.spill.Spill.units">
<code class="descname">units</code><a class="headerlink" href="#gnome.spill.Spill.units" title="Permalink to this definition">¶</a></dt>
<dd><p>Default units in which amount of oil spilled was entered by user.
The &#8216;amount&#8217; property is returned in these &#8216;units&#8217;</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.Spill.get_mass">
<code class="descname">get_mass</code><span class="sig-paren">(</span><em>units=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/spill/spill.html#Spill.get_mass"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.spill.Spill.get_mass" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the mass released during the spill.
User can also specify desired output units in the function.
If units are not specified, then return in &#8216;SI&#8217; units (&#8216;kg&#8217;)
If volume is given, then use density to find mass. Density is always
at 15degC, consistent with API definition</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.Spill.uncertain_copy">
<code class="descname">uncertain_copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/spill/spill.html#Spill.uncertain_copy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.spill.Spill.uncertain_copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a deepcopy of this spill for the uncertainty runs</p>
<p>The copy has everything the same, including the spill_num,
but it is a new object with a new id.</p>
<p>Not much to this method, but it could be overridden to do something
fancier in the future or a subclass.</p>
<p>There are a number of python objects that cannot be deepcopied.
- Logger objects</p>
<p>So we copy them temporarily to local variables before we deepcopy
our Spill object.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.Spill.set_amount_uncertainty">
<code class="descname">set_amount_uncertainty</code><span class="sig-paren">(</span><em>up_or_down=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/spill/spill.html#Spill.set_amount_uncertainty"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.spill.Spill.set_amount_uncertainty" title="Permalink to this definition">¶</a></dt>
<dd><p>This function shifts the spill amount based on a scale value
in the range [0.0 ... 1.0].  The maximum uncertainty scale value
is (2/3) * spill_amount.
We determine either an upper uncertainty or a lower uncertainty
multiplier.  Then we shift our spill amount value based on it.</p>
<p>Since we are irreversibly changing the spill amount value,
we should probably do this only once.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.Spill.rewind">
<code class="descname">rewind</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/spill/spill.html#Spill.rewind"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.spill.Spill.rewind" title="Permalink to this definition">¶</a></dt>
<dd><p>rewinds the release to original status (before anything has been
released).</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.Spill.num_elements_to_release">
<code class="descname">num_elements_to_release</code><span class="sig-paren">(</span><em>current_time</em>, <em>time_step</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/spill/spill.html#Spill.num_elements_to_release"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.spill.Spill.num_elements_to_release" title="Permalink to this definition">¶</a></dt>
<dd><p>Determines the number of elements to be released during:
current_time + time_step</p>
<p>It invokes the num_elements_to_release method for the the unerlying
release object: self.release.num_elements_to_release()</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>current_time</strong> (<em>datetime.datetime</em>) &#8211; current time</li>
<li><strong>time_step</strong> (<em>int</em>) &#8211; the time step, sometimes used to decide how many
should get released.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the number of elements that will be released. This is taken
by SpillContainer to initialize all data_arrays.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.Spill.attr_to_dict">
<code class="descname">attr_to_dict</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.Spill.attr_to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>refactor to_dict&#8217;s functionality so child classes can convert a
single attribute to_dict instead of doing a whole list of fields</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.Spill.deserialize_oc">
<code class="descname">deserialize_oc</code><span class="sig-paren">(</span><em>json_</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.Spill.deserialize_oc" title="Permalink to this definition">¶</a></dt>
<dd><p>check contents of orderered collections to figure out what schema to
use.
Basically, the json serialized ordered collection looks like a regular
list.</p>
</dd></dl>

<dl class="attribute">
<dt id="gnome.spill.Spill.id">
<code class="descname">id</code><a class="headerlink" href="#gnome.spill.Spill.id" title="Permalink to this definition">¶</a></dt>
<dd><p>Override this method for more exotic forms of identification.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a unique ID assigned during construction</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.Spill.is_sparse">
<code class="descname">is_sparse</code><span class="sig-paren">(</span><em>json_</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.Spill.is_sparse" title="Permalink to this definition">¶</a></dt>
<dd><p>Sparse means that we have a previously created object,
and we are receiving a reference to the object using just
an obj_type and an id.  This is a valid payload that the
Web Client will send.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.Spill.loads">
<code class="descname">loads</code><span class="sig-paren">(</span><em>json_data</em>, <em>saveloc=None</em>, <em>references=None</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.Spill.loads" title="Permalink to this definition">¶</a></dt>
<dd><p>loads object from json_data</p>
<ul class="simple">
<li>load json for references from files</li>
<li>update paths of datafiles if needed</li>
<li>deserialize json_data</li>
<li>and create object with new_from_dict()</li>
</ul>
<dl class="docutils">
<dt>json_data: dict containing json data. It has been parsed through the</dt>
<dd>json.loads() command. The json will be valided here when it gets
deserialized. Its references and datafile paths will be recreated
here prior to calling new_from_dict()</dd>
</dl>
<p>Optional parameter</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>saveloc</strong> &#8211; location of data files or <a href="#id1"><span class="problematic" id="id2">*</span></a>.json files for objects
stored as references. If object requires no datafiles and does not
need to read references from a <a href="#id3"><span class="problematic" id="id4">*</span></a>.json file in saveloc, then this
can be None.</li>
<li><strong>references</strong> &#8211; references object - if this is called by the Model,
it will pass a references object. It is not required.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">object constructed from json_data.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="gnome.spill.Spill.logger">
<code class="descname">logger</code><a class="headerlink" href="#gnome.spill.Spill.logger" title="Permalink to this definition">¶</a></dt>
<dd><p>define attribute &#8216;_log&#8217;. If it doesn&#8217;t exist, define it here.
This is so we don&#8217;t have to add it to all PyGnome classes - this
property makes the logger available to each object.
- default log_level is INFO</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.Spill.new_from_dict">
<code class="descname">new_from_dict</code><span class="sig-paren">(</span><em>dict_</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.Spill.new_from_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>creates a new object from dictionary</p>
<p>This is base implementation and can be over-ridden by classes using
this mixin</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.Spill.obj_type_to_dict">
<code class="descname">obj_type_to_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.Spill.obj_type_to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>returns object type to save in dict.
This is base implementation and can be over-ridden</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.Spill.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>saveloc</em>, <em>references=None</em>, <em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.Spill.save" title="Permalink to this definition">¶</a></dt>
<dd><p>save object state as json to user specified saveloc</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>saveloc</strong> (<em>A path as a string or unicode</em>) &#8211; zip archive or a valid directory. Model files are
either persisted here or a new model is re-created from the files
stored here. The files are clobbered when save() is called.</li>
<li><strong>name=None</strong> &#8211; filename to store json. If None, default name is:
&#8220;{0}.json&#8221;.format(self.__class__.__name__). If saveloc is zipfile,
this is the name of archive in which json for self is stored.</li>
<li><strong>references</strong> &#8211; dict of references mapping &#8216;id&#8217; to a string used for
the reference. The value could be a unique integer or it could be
a filename. It is upto the creator of the reference list to decide
how to reference a nested object.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.Spill.serialize_oc">
<code class="descname">serialize_oc</code><span class="sig-paren">(</span><em>coll</em>, <em>json_='webapi'</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.Spill.serialize_oc" title="Permalink to this definition">¶</a></dt>
<dd><p>Serialize Model attributes of type ordered collection or list - an
iterable containing serializable objects</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.Spill.set_newparticle_values">
<code class="descname">set_newparticle_values</code><span class="sig-paren">(</span><em>num_new_particles</em>, <em>current_time</em>, <em>time_step</em>, <em>data_arrays</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/spill/spill.html#Spill.set_newparticle_values"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.spill.Spill.set_newparticle_values" title="Permalink to this definition">¶</a></dt>
<dd><p>SpillContainer will release elements and initialize all data_arrays
to default initial value. The SpillContainer gets passed as input and
the data_arrays for &#8216;position&#8217; get initialized correctly by the release
object: self.release.set_newparticle_positions()</p>
<p>If a Spill Amount is given, the Spill object also sets the &#8216;mass&#8217; data
array; else &#8216;mass&#8217; array remains &#8216;0&#8217;</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>num_new_particles</strong> (<em>int</em>) &#8211; number of new particles that were added.
Always greater than 0</li>
<li><strong>current_time</strong> (<em>datetime.datetime</em>) &#8211; current time</li>
<li><strong>time_step</strong> (<em>integer seconds</em>) &#8211; the time step, sometimes used to decide how many
should get released.</li>
<li><strong>data_arrays</strong> (<em>dict containing numpy arrays for values</em>) &#8211; dict of data_arrays provided by the SpillContainer.
Look for &#8216;positions&#8217; array in the dict and update positions for
latest num_new_particles that are released</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Also, the set_newparticle_values() method for all element_type gets
called so each element_type sets the values for its own data correctly</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.Spill.to_dict">
<code class="descname">to_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.Spill.to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>returns a dictionary containing the serialized representation of this
object.</p>
<p>For every field, if there is a method defined on the object such that
the method name is <cite>{field_name}_to_dict</cite>, use the return value of that
method as the field value.</p>
<p>Note: any field in <cite>list</cite> that does not exist on the
object and does not have a to_dict method will raise an AttributeError.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>json_='webapi'</strong> &#8211; return the attributes for json payload for
webapi.
The other option is &#8216;save&#8217; corresponding with
json for save files.</td>
</tr>
</tbody>
</table>
<p>NOTE: add the json_=&#8217;webapi&#8217; key to be serialized so we know what the
serialization is for</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.Spill.to_serialize">
<code class="descname">to_serialize</code><span class="sig-paren">(</span><em>json_='webapi'</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.Spill.to_serialize" title="Permalink to this definition">¶</a></dt>
<dd><p>invoke to_dict() which converts all attributes defined in _state to
dict. If json_=&#8217;save&#8217;, it subselects the Fields with save=True. If
json_=&#8217;webapi&#8217;, it subselects Fields with (update=True, read=True)</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.Spill.update_attr">
<code class="descname">update_attr</code><span class="sig-paren">(</span><em>name</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.Spill.update_attr" title="Permalink to this definition">¶</a></dt>
<dd><p>update the attribute defined by &#8216;name&#8217; with given &#8216;value&#8217;</p>
<p>If there is a method defined on the object such that the method name is
<cite>{name}_from_dict</cite>, call that method with the field&#8217;s data.</p>
<p>If neither method exists, then set the field with the value from
<code class="docutils literal"><span class="pre">data</span></code> directly on the object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> (<em>str</em>) &#8211; name of attribute to be updated</li>
<li><strong>value</strong> (<em>depends on each attribute being updated</em>) &#8211; the new value of the attribute</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.Spill.update_from_dict">
<code class="descname">update_from_dict</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.Spill.update_from_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the attributes of this object using the dictionary <code class="docutils literal"><span class="pre">data</span></code> by
looking up the value of each key in <code class="docutils literal"><span class="pre">data</span></code>.
The fields in self._state that have update=True are modified. The
remaining keys in &#8216;data&#8217; are ignored. The object&#8217;s _state attribute
defines what fields can be updated</p>
<p>If an attribute has changed, then call &#8216;update_attr&#8217; to update its
value.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>data</strong> (<em>dict</em>) &#8211; dict containing state of object per the client</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">True if something changed, False otherwise</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">bool</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Does not do updates on nested objects. If the attribute references
another Serializable object, then the value is not a dict but
rather the updated object. For instance, WindMover will receive:</p>
<blockquote>
<div>{..., &#8216;wind&#8217;: &lt;Wind object&gt;}</div></blockquote>
<p class="last">as opposed to a nested dict of the &#8216;wind&#8217; object. It is expected
that the &#8216;wind&#8217; object was updated by calling its own
update_from_dict then added to this dict as the updated object.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.Spill.validate">
<code class="descname">validate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.Spill.validate" title="Permalink to this definition">¶</a></dt>
<dd><p>All pygnome objects should be able to validate themselves. Many
py_gnome objects reference other objects like wind, water, waves. These
may not be defined when object is created so they can be None at
construction time; however, they should reference valid objects
when running model. If make_default_refs is True, then object isvalid
because model will set these up at runtime. To raise exception
for missing references at runtime, directly call
validate_refs(level=&#8217;error&#8217;)</p>
<p>&#8216;wind&#8217;, &#8216;water&#8217;, &#8216;waves&#8217; attributes also have special meaning. An
object containing this attribute references the corresponding object.</p>
<p>Logs warnings
:returns: a tuple of length two containing:</p>
<blockquote>
<div>(a list of messages that were logged, isvalid bool)
If any references are missing and make_default_refs is False,
object is not valid</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.Spill.validate_refs">
<code class="descname">validate_refs</code><span class="sig-paren">(</span><em>refs=['wind', 'water', 'waves']</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.Spill.validate_refs" title="Permalink to this definition">¶</a></dt>
<dd><p>level is the logging level to use for messages. Default is &#8216;warning&#8217;
but if called from prepare_for_model_run, we want to use error and
raise exception.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.Spill.serialize">
<code class="descname">serialize</code><span class="sig-paren">(</span><em>json_='webapi'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/spill/spill.html#Spill.serialize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.spill.Spill.serialize" title="Permalink to this definition">¶</a></dt>
<dd><p>override base serialize implementation
Need to add node for release object and element_type object</p>
</dd></dl>

<dl class="classmethod">
<dt id="gnome.spill.Spill.deserialize">
<em class="property">classmethod </em><code class="descname">deserialize</code><span class="sig-paren">(</span><em>json_</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/spill/spill.html#Spill.deserialize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.spill.Spill.deserialize" title="Permalink to this definition">¶</a></dt>
<dd><p>Instead of creating schema dynamically for Spill() before
deserialization, call nested object&#8217;s serialize/deserialize methods</p>
<p>We also need to accept sparse json objects, in which case we will
not treat them, but just send them back.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="gnome.spill.Release">
<em class="property">class </em><code class="descclassname">gnome.spill.</code><code class="descname">Release</code><span class="sig-paren">(</span><em>release_time</em>, <em>num_elements=0</em>, <em>name=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/spill/release.html#Release"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.spill.Release" title="Permalink to this definition">¶</a></dt>
<dd><p>base class for Release classes.</p>
<p>It contains interface for Release objects</p>
<dl class="method">
<dt id="gnome.spill.Release.num_elements_to_release">
<code class="descname">num_elements_to_release</code><span class="sig-paren">(</span><em>current_time</em>, <em>time_step</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/spill/release.html#Release.num_elements_to_release"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.spill.Release.num_elements_to_release" title="Permalink to this definition">¶</a></dt>
<dd><p>Determines the number of elements to be released during:
current_time + time_step. Base class has partial (incomplete)
implementation.</p>
<p>This base class method checks if current_time in first step
is valid and toggles the self.start_time_invalid flag if it is valid.
If current_time &lt;= self.release_time the first time this is called,
then toggle start_time_invalid to True.</p>
<p>Subclasses should define the complete implementation and return number
of new particles to be released once this check passes. Be sure to call
the base class method first if start_time_invalid flag should be
checked.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>current_time</strong> (<em>datetime.datetime</em>) &#8211; current time</li>
<li><strong>time_step</strong> (<em>integer seconds</em>) &#8211; the time step, sometimes used to decide how many
should get released.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the number of elements that will be released. This is taken
by SpillContainer to initialize all data_arrays.</p>
</td>
</tr>
</tbody>
</table>
<p>self.num_released is updated after self.set_newparticle_values is
called. Particles are considered released after the values are set.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.Release.set_newparticle_positions">
<code class="descname">set_newparticle_positions</code><span class="sig-paren">(</span><em>num_new_particles</em>, <em>current_time</em>, <em>time_step</em>, <em>data_arrays</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/spill/release.html#Release.set_newparticle_positions"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.spill.Release.set_newparticle_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>derived object should set the &#8216;positions&#8217; array for the data_arrays
base class has no implementation</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.Release.rewind">
<code class="descname">rewind</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/spill/release.html#Release.rewind"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.spill.Release.rewind" title="Permalink to this definition">¶</a></dt>
<dd><p>rewinds the Release to original status (before anything has been
released).</p>
<p>Base class sets &#8216;num_released&#8217;=0 and &#8216;start_time_invalid&#8217;=True
properties to original _state.
Subclasses should overload for additional functions required to reset
_state.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.Release.serialize">
<code class="descname">serialize</code><span class="sig-paren">(</span><em>json_='webapi'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/spill/release.html#Release.serialize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.spill.Release.serialize" title="Permalink to this definition">¶</a></dt>
<dd><p>define schema based on type of desired output</p>
</dd></dl>

<dl class="attribute">
<dt id="gnome.spill.Release.release_duration">
<code class="descname">release_duration</code><a class="headerlink" href="#gnome.spill.Release.release_duration" title="Permalink to this definition">¶</a></dt>
<dd><p>returns a timedelta object defining the time over which the particles
are released. The default is 0; derived classes like PointLineRelease
must over-ride</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="gnome.spill.PointLineRelease">
<em class="property">class </em><code class="descclassname">gnome.spill.</code><code class="descname">PointLineRelease</code><span class="sig-paren">(</span><em>release_time</em>, <em>start_position</em>, <em>num_elements=None</em>, <em>num_per_timestep=None</em>, <em>end_release_time=None</em>, <em>end_position=None</em>, <em>name=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/spill/release.html#PointLineRelease"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.spill.PointLineRelease" title="Permalink to this definition">¶</a></dt>
<dd><p>The primary spill source class  &#8211;  a release of floating
non-weathering particles, can be instantaneous or continuous, and be
released at a single point, or over a line.</p>
<p>Required Arguments:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>release_time</strong> (<em>datetime.datetime</em>) &#8211; time the LEs are released (datetime object)</li>
<li><strong>start_position</strong> (<em>3-tuple of floats (long, lat, z)</em>) &#8211; initial location the elements are released</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Optional arguments:</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Either num_elements or num_per_timestep must be given. If
both are None, then it defaults to num_elements=1000. If both are
given a TypeError is raised because user can only specify one or
the other, not both.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>num_elements</strong> (<em>integer</em>) &#8211; total number of elements to be released</li>
<li><strong>num_per_timestep</strong> &#8211; fixed number of LEs released at each timestep</li>
<li><strong>end_release_time=None</strong> &#8211; optional &#8211; for a time varying release,
the end release time. If None, then release is instantaneous</li>
<li><strong>end_position=None</strong> &#8211; optional. For moving source, the end position
If None, then release from a point source</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>num_elements and release_time passed to base class __init__ using super
See base <a class="reference internal" href="#gnome.spill.Release" title="gnome.spill.Release"><code class="xref py py-class docutils literal"><span class="pre">Release</span></code></a> documentation</p>
<dl class="attribute">
<dt id="gnome.spill.PointLineRelease.is_pointsource">
<code class="descname">is_pointsource</code><a class="headerlink" href="#gnome.spill.PointLineRelease.is_pointsource" title="Permalink to this definition">¶</a></dt>
<dd><p>if end_position - start_position == 0, point source
otherwise it is a line source</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">True if point source, false otherwise</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="gnome.spill.PointLineRelease.release_duration">
<code class="descname">release_duration</code><a class="headerlink" href="#gnome.spill.PointLineRelease.release_duration" title="Permalink to this definition">¶</a></dt>
<dd><p>duration over which particles are released in seconds</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.PointLineRelease.set_newparticle_positions">
<code class="descname">set_newparticle_positions</code><span class="sig-paren">(</span><em>num_new_particles</em>, <em>current_time</em>, <em>time_step</em>, <em>data_arrays</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/spill/release.html#PointLineRelease.set_newparticle_positions"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.spill.PointLineRelease.set_newparticle_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>sets positions for newly released particles. It evenly spaces the
particles using numpy.linespace. Set (start_postion, end_position)
depending on whether it is a point source, a line release
an instantaneous release or a time varying release.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.PointLineRelease.rewind">
<code class="descname">rewind</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/spill/release.html#PointLineRelease.rewind"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.spill.PointLineRelease.rewind" title="Permalink to this definition">¶</a></dt>
<dd><p>Rewind to initial conditions &#8211; i.e. nothing released.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.PointLineRelease.attr_to_dict">
<code class="descname">attr_to_dict</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.PointLineRelease.attr_to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>refactor to_dict&#8217;s functionality so child classes can convert a
single attribute to_dict instead of doing a whole list of fields</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.PointLineRelease.deserialize_oc">
<code class="descname">deserialize_oc</code><span class="sig-paren">(</span><em>json_</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.PointLineRelease.deserialize_oc" title="Permalink to this definition">¶</a></dt>
<dd><p>check contents of orderered collections to figure out what schema to
use.
Basically, the json serialized ordered collection looks like a regular
list.</p>
</dd></dl>

<dl class="attribute">
<dt id="gnome.spill.PointLineRelease.id">
<code class="descname">id</code><a class="headerlink" href="#gnome.spill.PointLineRelease.id" title="Permalink to this definition">¶</a></dt>
<dd><p>Override this method for more exotic forms of identification.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a unique ID assigned during construction</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.PointLineRelease.is_sparse">
<code class="descname">is_sparse</code><span class="sig-paren">(</span><em>json_</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.PointLineRelease.is_sparse" title="Permalink to this definition">¶</a></dt>
<dd><p>Sparse means that we have a previously created object,
and we are receiving a reference to the object using just
an obj_type and an id.  This is a valid payload that the
Web Client will send.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.PointLineRelease.loads">
<code class="descname">loads</code><span class="sig-paren">(</span><em>json_data</em>, <em>saveloc=None</em>, <em>references=None</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.PointLineRelease.loads" title="Permalink to this definition">¶</a></dt>
<dd><p>loads object from json_data</p>
<ul class="simple">
<li>load json for references from files</li>
<li>update paths of datafiles if needed</li>
<li>deserialize json_data</li>
<li>and create object with new_from_dict()</li>
</ul>
<dl class="docutils">
<dt>json_data: dict containing json data. It has been parsed through the</dt>
<dd>json.loads() command. The json will be valided here when it gets
deserialized. Its references and datafile paths will be recreated
here prior to calling new_from_dict()</dd>
</dl>
<p>Optional parameter</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>saveloc</strong> &#8211; location of data files or <a href="#id5"><span class="problematic" id="id6">*</span></a>.json files for objects
stored as references. If object requires no datafiles and does not
need to read references from a <a href="#id7"><span class="problematic" id="id8">*</span></a>.json file in saveloc, then this
can be None.</li>
<li><strong>references</strong> &#8211; references object - if this is called by the Model,
it will pass a references object. It is not required.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">object constructed from json_data.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="gnome.spill.PointLineRelease.logger">
<code class="descname">logger</code><a class="headerlink" href="#gnome.spill.PointLineRelease.logger" title="Permalink to this definition">¶</a></dt>
<dd><p>define attribute &#8216;_log&#8217;. If it doesn&#8217;t exist, define it here.
This is so we don&#8217;t have to add it to all PyGnome classes - this
property makes the logger available to each object.
- default log_level is INFO</p>
</dd></dl>

<dl class="attribute">
<dt id="gnome.spill.PointLineRelease.name">
<code class="descname">name</code><a class="headerlink" href="#gnome.spill.PointLineRelease.name" title="Permalink to this definition">¶</a></dt>
<dd><p>define as property in base class so all objects will have a name
by default</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.PointLineRelease.new_from_dict">
<code class="descname">new_from_dict</code><span class="sig-paren">(</span><em>dict_</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.PointLineRelease.new_from_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>creates a new object from dictionary</p>
<p>This is base implementation and can be over-ridden by classes using
this mixin</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.PointLineRelease.num_elements_to_release">
<code class="descname">num_elements_to_release</code><span class="sig-paren">(</span><em>current_time</em>, <em>time_step</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.PointLineRelease.num_elements_to_release" title="Permalink to this definition">¶</a></dt>
<dd><p>Determines the number of elements to be released during:
current_time + time_step. Base class has partial (incomplete)
implementation.</p>
<p>This base class method checks if current_time in first step
is valid and toggles the self.start_time_invalid flag if it is valid.
If current_time &lt;= self.release_time the first time this is called,
then toggle start_time_invalid to True.</p>
<p>Subclasses should define the complete implementation and return number
of new particles to be released once this check passes. Be sure to call
the base class method first if start_time_invalid flag should be
checked.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>current_time</strong> (<em>datetime.datetime</em>) &#8211; current time</li>
<li><strong>time_step</strong> (<em>integer seconds</em>) &#8211; the time step, sometimes used to decide how many
should get released.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the number of elements that will be released. This is taken
by SpillContainer to initialize all data_arrays.</p>
</td>
</tr>
</tbody>
</table>
<p>self.num_released is updated after self.set_newparticle_values is
called. Particles are considered released after the values are set.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.PointLineRelease.obj_type_to_dict">
<code class="descname">obj_type_to_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.PointLineRelease.obj_type_to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>returns object type to save in dict.
This is base implementation and can be over-ridden</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.PointLineRelease.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>saveloc</em>, <em>references=None</em>, <em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.PointLineRelease.save" title="Permalink to this definition">¶</a></dt>
<dd><p>save object state as json to user specified saveloc</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>saveloc</strong> (<em>A path as a string or unicode</em>) &#8211; zip archive or a valid directory. Model files are
either persisted here or a new model is re-created from the files
stored here. The files are clobbered when save() is called.</li>
<li><strong>name=None</strong> &#8211; filename to store json. If None, default name is:
&#8220;{0}.json&#8221;.format(self.__class__.__name__). If saveloc is zipfile,
this is the name of archive in which json for self is stored.</li>
<li><strong>references</strong> &#8211; dict of references mapping &#8216;id&#8217; to a string used for
the reference. The value could be a unique integer or it could be
a filename. It is upto the creator of the reference list to decide
how to reference a nested object.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.PointLineRelease.serialize">
<code class="descname">serialize</code><span class="sig-paren">(</span><em>json_='webapi'</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.PointLineRelease.serialize" title="Permalink to this definition">¶</a></dt>
<dd><p>define schema based on type of desired output</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.PointLineRelease.serialize_oc">
<code class="descname">serialize_oc</code><span class="sig-paren">(</span><em>coll</em>, <em>json_='webapi'</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.PointLineRelease.serialize_oc" title="Permalink to this definition">¶</a></dt>
<dd><p>Serialize Model attributes of type ordered collection or list - an
iterable containing serializable objects</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.PointLineRelease.to_dict">
<code class="descname">to_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.PointLineRelease.to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>returns a dictionary containing the serialized representation of this
object.</p>
<p>For every field, if there is a method defined on the object such that
the method name is <cite>{field_name}_to_dict</cite>, use the return value of that
method as the field value.</p>
<p>Note: any field in <cite>list</cite> that does not exist on the
object and does not have a to_dict method will raise an AttributeError.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>json_='webapi'</strong> &#8211; return the attributes for json payload for
webapi.
The other option is &#8216;save&#8217; corresponding with
json for save files.</td>
</tr>
</tbody>
</table>
<p>NOTE: add the json_=&#8217;webapi&#8217; key to be serialized so we know what the
serialization is for</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.PointLineRelease.to_serialize">
<code class="descname">to_serialize</code><span class="sig-paren">(</span><em>json_='webapi'</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.PointLineRelease.to_serialize" title="Permalink to this definition">¶</a></dt>
<dd><p>invoke to_dict() which converts all attributes defined in _state to
dict. If json_=&#8217;save&#8217;, it subselects the Fields with save=True. If
json_=&#8217;webapi&#8217;, it subselects Fields with (update=True, read=True)</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.PointLineRelease.update_attr">
<code class="descname">update_attr</code><span class="sig-paren">(</span><em>name</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.PointLineRelease.update_attr" title="Permalink to this definition">¶</a></dt>
<dd><p>update the attribute defined by &#8216;name&#8217; with given &#8216;value&#8217;</p>
<p>If there is a method defined on the object such that the method name is
<cite>{name}_from_dict</cite>, call that method with the field&#8217;s data.</p>
<p>If neither method exists, then set the field with the value from
<code class="docutils literal"><span class="pre">data</span></code> directly on the object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> (<em>str</em>) &#8211; name of attribute to be updated</li>
<li><strong>value</strong> (<em>depends on each attribute being updated</em>) &#8211; the new value of the attribute</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.PointLineRelease.update_from_dict">
<code class="descname">update_from_dict</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.PointLineRelease.update_from_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the attributes of this object using the dictionary <code class="docutils literal"><span class="pre">data</span></code> by
looking up the value of each key in <code class="docutils literal"><span class="pre">data</span></code>.
The fields in self._state that have update=True are modified. The
remaining keys in &#8216;data&#8217; are ignored. The object&#8217;s _state attribute
defines what fields can be updated</p>
<p>If an attribute has changed, then call &#8216;update_attr&#8217; to update its
value.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>data</strong> (<em>dict</em>) &#8211; dict containing state of object per the client</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">True if something changed, False otherwise</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">bool</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Does not do updates on nested objects. If the attribute references
another Serializable object, then the value is not a dict but
rather the updated object. For instance, WindMover will receive:</p>
<blockquote>
<div>{..., &#8216;wind&#8217;: &lt;Wind object&gt;}</div></blockquote>
<p class="last">as opposed to a nested dict of the &#8216;wind&#8217; object. It is expected
that the &#8216;wind&#8217; object was updated by calling its own
update_from_dict then added to this dict as the updated object.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.PointLineRelease.validate">
<code class="descname">validate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.PointLineRelease.validate" title="Permalink to this definition">¶</a></dt>
<dd><p>All pygnome objects should be able to validate themselves. Many
py_gnome objects reference other objects like wind, water, waves. These
may not be defined when object is created so they can be None at
construction time; however, they should reference valid objects
when running model. If make_default_refs is True, then object isvalid
because model will set these up at runtime. To raise exception
for missing references at runtime, directly call
validate_refs(level=&#8217;error&#8217;)</p>
<p>&#8216;wind&#8217;, &#8216;water&#8217;, &#8216;waves&#8217; attributes also have special meaning. An
object containing this attribute references the corresponding object.</p>
<p>Logs warnings
:returns: a tuple of length two containing:</p>
<blockquote>
<div>(a list of messages that were logged, isvalid bool)
If any references are missing and make_default_refs is False,
object is not valid</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.PointLineRelease.validate_refs">
<code class="descname">validate_refs</code><span class="sig-paren">(</span><em>refs=['wind', 'water', 'waves']</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.PointLineRelease.validate_refs" title="Permalink to this definition">¶</a></dt>
<dd><p>level is the logging level to use for messages. Default is &#8216;warning&#8217;
but if called from prepare_for_model_run, we want to use error and
raise exception.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="gnome.spill.SpatialRelease">
<em class="property">class </em><code class="descclassname">gnome.spill.</code><code class="descname">SpatialRelease</code><span class="sig-paren">(</span><em>release_time</em>, <em>start_position</em>, <em>name=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/spill/release.html#SpatialRelease"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.spill.SpatialRelease" title="Permalink to this definition">¶</a></dt>
<dd><p>A simple release class  &#8211;  a release of floating non-weathering particles,
with their initial positions pre-specified</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>release_time</strong> (<em>datetime.datetime</em>) &#8211; time the LEs are released</li>
<li><strong>start_positions</strong> (<em>(num_elements, 3) numpy array of float64
&#8211; (long, lat, z)</em>) &#8211; locations the LEs are released</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>num_elements and release_time passed to base class __init__ using super
See base <a class="reference internal" href="#gnome.spill.Release" title="gnome.spill.Release"><code class="xref py py-class docutils literal"><span class="pre">Release</span></code></a> documentation</p>
<dl class="classmethod">
<dt id="gnome.spill.SpatialRelease.new_from_dict">
<em class="property">classmethod </em><code class="descname">new_from_dict</code><span class="sig-paren">(</span><em>dict_</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/spill/release.html#SpatialRelease.new_from_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.spill.SpatialRelease.new_from_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Custom new_from_dict() functionality for SpatialRelease</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.SpatialRelease.num_elements_to_release">
<code class="descname">num_elements_to_release</code><span class="sig-paren">(</span><em>current_time</em>, <em>time_step</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/spill/release.html#SpatialRelease.num_elements_to_release"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.spill.SpatialRelease.num_elements_to_release" title="Permalink to this definition">¶</a></dt>
<dd><p>return number of particles released in current_time + time_step</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.SpatialRelease.set_newparticle_positions">
<code class="descname">set_newparticle_positions</code><span class="sig-paren">(</span><em>num_new_particles</em>, <em>current_time</em>, <em>time_step</em>, <em>data_arrays</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/spill/release.html#SpatialRelease.set_newparticle_positions"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.spill.SpatialRelease.set_newparticle_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>set positions for new elements added by the SpillContainer</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">this releases all the elements at their initial positions at
the release_time</p>
</div>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.SpatialRelease.attr_to_dict">
<code class="descname">attr_to_dict</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.SpatialRelease.attr_to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>refactor to_dict&#8217;s functionality so child classes can convert a
single attribute to_dict instead of doing a whole list of fields</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.SpatialRelease.deserialize_oc">
<code class="descname">deserialize_oc</code><span class="sig-paren">(</span><em>json_</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.SpatialRelease.deserialize_oc" title="Permalink to this definition">¶</a></dt>
<dd><p>check contents of orderered collections to figure out what schema to
use.
Basically, the json serialized ordered collection looks like a regular
list.</p>
</dd></dl>

<dl class="attribute">
<dt id="gnome.spill.SpatialRelease.id">
<code class="descname">id</code><a class="headerlink" href="#gnome.spill.SpatialRelease.id" title="Permalink to this definition">¶</a></dt>
<dd><p>Override this method for more exotic forms of identification.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a unique ID assigned during construction</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.SpatialRelease.is_sparse">
<code class="descname">is_sparse</code><span class="sig-paren">(</span><em>json_</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.SpatialRelease.is_sparse" title="Permalink to this definition">¶</a></dt>
<dd><p>Sparse means that we have a previously created object,
and we are receiving a reference to the object using just
an obj_type and an id.  This is a valid payload that the
Web Client will send.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.SpatialRelease.loads">
<code class="descname">loads</code><span class="sig-paren">(</span><em>json_data</em>, <em>saveloc=None</em>, <em>references=None</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.SpatialRelease.loads" title="Permalink to this definition">¶</a></dt>
<dd><p>loads object from json_data</p>
<ul class="simple">
<li>load json for references from files</li>
<li>update paths of datafiles if needed</li>
<li>deserialize json_data</li>
<li>and create object with new_from_dict()</li>
</ul>
<dl class="docutils">
<dt>json_data: dict containing json data. It has been parsed through the</dt>
<dd>json.loads() command. The json will be valided here when it gets
deserialized. Its references and datafile paths will be recreated
here prior to calling new_from_dict()</dd>
</dl>
<p>Optional parameter</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>saveloc</strong> &#8211; location of data files or <a href="#id9"><span class="problematic" id="id10">*</span></a>.json files for objects
stored as references. If object requires no datafiles and does not
need to read references from a <a href="#id11"><span class="problematic" id="id12">*</span></a>.json file in saveloc, then this
can be None.</li>
<li><strong>references</strong> &#8211; references object - if this is called by the Model,
it will pass a references object. It is not required.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">object constructed from json_data.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="gnome.spill.SpatialRelease.logger">
<code class="descname">logger</code><a class="headerlink" href="#gnome.spill.SpatialRelease.logger" title="Permalink to this definition">¶</a></dt>
<dd><p>define attribute &#8216;_log&#8217;. If it doesn&#8217;t exist, define it here.
This is so we don&#8217;t have to add it to all PyGnome classes - this
property makes the logger available to each object.
- default log_level is INFO</p>
</dd></dl>

<dl class="attribute">
<dt id="gnome.spill.SpatialRelease.name">
<code class="descname">name</code><a class="headerlink" href="#gnome.spill.SpatialRelease.name" title="Permalink to this definition">¶</a></dt>
<dd><p>define as property in base class so all objects will have a name
by default</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.SpatialRelease.obj_type_to_dict">
<code class="descname">obj_type_to_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.SpatialRelease.obj_type_to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>returns object type to save in dict.
This is base implementation and can be over-ridden</p>
</dd></dl>

<dl class="attribute">
<dt id="gnome.spill.SpatialRelease.release_duration">
<code class="descname">release_duration</code><a class="headerlink" href="#gnome.spill.SpatialRelease.release_duration" title="Permalink to this definition">¶</a></dt>
<dd><p>returns a timedelta object defining the time over which the particles
are released. The default is 0; derived classes like PointLineRelease
must over-ride</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.SpatialRelease.rewind">
<code class="descname">rewind</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.SpatialRelease.rewind" title="Permalink to this definition">¶</a></dt>
<dd><p>rewinds the Release to original status (before anything has been
released).</p>
<p>Base class sets &#8216;num_released&#8217;=0 and &#8216;start_time_invalid&#8217;=True
properties to original _state.
Subclasses should overload for additional functions required to reset
_state.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.SpatialRelease.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>saveloc</em>, <em>references=None</em>, <em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.SpatialRelease.save" title="Permalink to this definition">¶</a></dt>
<dd><p>save object state as json to user specified saveloc</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>saveloc</strong> (<em>A path as a string or unicode</em>) &#8211; zip archive or a valid directory. Model files are
either persisted here or a new model is re-created from the files
stored here. The files are clobbered when save() is called.</li>
<li><strong>name=None</strong> &#8211; filename to store json. If None, default name is:
&#8220;{0}.json&#8221;.format(self.__class__.__name__). If saveloc is zipfile,
this is the name of archive in which json for self is stored.</li>
<li><strong>references</strong> &#8211; dict of references mapping &#8216;id&#8217; to a string used for
the reference. The value could be a unique integer or it could be
a filename. It is upto the creator of the reference list to decide
how to reference a nested object.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.SpatialRelease.serialize">
<code class="descname">serialize</code><span class="sig-paren">(</span><em>json_='webapi'</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.SpatialRelease.serialize" title="Permalink to this definition">¶</a></dt>
<dd><p>define schema based on type of desired output</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.SpatialRelease.serialize_oc">
<code class="descname">serialize_oc</code><span class="sig-paren">(</span><em>coll</em>, <em>json_='webapi'</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.SpatialRelease.serialize_oc" title="Permalink to this definition">¶</a></dt>
<dd><p>Serialize Model attributes of type ordered collection or list - an
iterable containing serializable objects</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.SpatialRelease.to_dict">
<code class="descname">to_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.SpatialRelease.to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>returns a dictionary containing the serialized representation of this
object.</p>
<p>For every field, if there is a method defined on the object such that
the method name is <cite>{field_name}_to_dict</cite>, use the return value of that
method as the field value.</p>
<p>Note: any field in <cite>list</cite> that does not exist on the
object and does not have a to_dict method will raise an AttributeError.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>json_='webapi'</strong> &#8211; return the attributes for json payload for
webapi.
The other option is &#8216;save&#8217; corresponding with
json for save files.</td>
</tr>
</tbody>
</table>
<p>NOTE: add the json_=&#8217;webapi&#8217; key to be serialized so we know what the
serialization is for</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.SpatialRelease.to_serialize">
<code class="descname">to_serialize</code><span class="sig-paren">(</span><em>json_='webapi'</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.SpatialRelease.to_serialize" title="Permalink to this definition">¶</a></dt>
<dd><p>invoke to_dict() which converts all attributes defined in _state to
dict. If json_=&#8217;save&#8217;, it subselects the Fields with save=True. If
json_=&#8217;webapi&#8217;, it subselects Fields with (update=True, read=True)</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.SpatialRelease.update_attr">
<code class="descname">update_attr</code><span class="sig-paren">(</span><em>name</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.SpatialRelease.update_attr" title="Permalink to this definition">¶</a></dt>
<dd><p>update the attribute defined by &#8216;name&#8217; with given &#8216;value&#8217;</p>
<p>If there is a method defined on the object such that the method name is
<cite>{name}_from_dict</cite>, call that method with the field&#8217;s data.</p>
<p>If neither method exists, then set the field with the value from
<code class="docutils literal"><span class="pre">data</span></code> directly on the object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> (<em>str</em>) &#8211; name of attribute to be updated</li>
<li><strong>value</strong> (<em>depends on each attribute being updated</em>) &#8211; the new value of the attribute</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.SpatialRelease.update_from_dict">
<code class="descname">update_from_dict</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.SpatialRelease.update_from_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the attributes of this object using the dictionary <code class="docutils literal"><span class="pre">data</span></code> by
looking up the value of each key in <code class="docutils literal"><span class="pre">data</span></code>.
The fields in self._state that have update=True are modified. The
remaining keys in &#8216;data&#8217; are ignored. The object&#8217;s _state attribute
defines what fields can be updated</p>
<p>If an attribute has changed, then call &#8216;update_attr&#8217; to update its
value.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>data</strong> (<em>dict</em>) &#8211; dict containing state of object per the client</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">True if something changed, False otherwise</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">bool</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Does not do updates on nested objects. If the attribute references
another Serializable object, then the value is not a dict but
rather the updated object. For instance, WindMover will receive:</p>
<blockquote>
<div>{..., &#8216;wind&#8217;: &lt;Wind object&gt;}</div></blockquote>
<p class="last">as opposed to a nested dict of the &#8216;wind&#8217; object. It is expected
that the &#8216;wind&#8217; object was updated by calling its own
update_from_dict then added to this dict as the updated object.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.SpatialRelease.validate">
<code class="descname">validate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.SpatialRelease.validate" title="Permalink to this definition">¶</a></dt>
<dd><p>All pygnome objects should be able to validate themselves. Many
py_gnome objects reference other objects like wind, water, waves. These
may not be defined when object is created so they can be None at
construction time; however, they should reference valid objects
when running model. If make_default_refs is True, then object isvalid
because model will set these up at runtime. To raise exception
for missing references at runtime, directly call
validate_refs(level=&#8217;error&#8217;)</p>
<p>&#8216;wind&#8217;, &#8216;water&#8217;, &#8216;waves&#8217; attributes also have special meaning. An
object containing this attribute references the corresponding object.</p>
<p>Logs warnings
:returns: a tuple of length two containing:</p>
<blockquote>
<div>(a list of messages that were logged, isvalid bool)
If any references are missing and make_default_refs is False,
object is not valid</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.SpatialRelease.validate_refs">
<code class="descname">validate_refs</code><span class="sig-paren">(</span><em>refs=['wind', 'water', 'waves']</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.SpatialRelease.validate_refs" title="Permalink to this definition">¶</a></dt>
<dd><p>level is the logging level to use for messages. Default is &#8216;warning&#8217;
but if called from prepare_for_model_run, we want to use error and
raise exception.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="gnome.spill.VerticalPlumeRelease">
<em class="property">class </em><code class="descclassname">gnome.spill.</code><code class="descname">VerticalPlumeRelease</code><span class="sig-paren">(</span><em>release_time</em>, <em>num_elements</em>, <em>start_position</em>, <em>plume_data</em>, <em>end_release_time</em>, <em>name=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/spill/release.html#VerticalPlumeRelease"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.spill.VerticalPlumeRelease" title="Permalink to this definition">¶</a></dt>
<dd><p>An Underwater Plume spill class &#8211; a continuous release of particles,
controlled by a contained spill generator object.
- plume model generator will have an iteration method.  This will provide
flexible looping and list comprehension behavior.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>num_elements</strong> (<em>integer</em>) &#8211; total number of elements to be released</li>
<li><strong>start_position</strong> (<em>3-tuple of floats (long, lat, z)</em>) &#8211; initial location the elements are released</li>
<li><strong>release_time</strong> (<em>datetime.datetime</em>) &#8211; time the LEs are released</li>
<li><strong>start_positions</strong> (<em>(num_elements, 3) numpy array of float64
&#8211; (long, lat, z)</em>) &#8211; locations the LEs are released</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="gnome.spill.VerticalPlumeRelease.num_elements_to_release">
<code class="descname">num_elements_to_release</code><span class="sig-paren">(</span><em>current_time</em>, <em>time_step</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/spill/release.html#VerticalPlumeRelease.num_elements_to_release"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.spill.VerticalPlumeRelease.num_elements_to_release" title="Permalink to this definition">¶</a></dt>
<dd><p>Return number of particles released in current_time + time_step</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.VerticalPlumeRelease.set_newparticle_positions">
<code class="descname">set_newparticle_positions</code><span class="sig-paren">(</span><em>num_new_particles</em>, <em>current_time</em>, <em>time_step</em>, <em>data_arrays</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/spill/release.html#VerticalPlumeRelease.set_newparticle_positions"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.spill.VerticalPlumeRelease.set_newparticle_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Set positions for new elements added by the SpillContainer</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.VerticalPlumeRelease.attr_to_dict">
<code class="descname">attr_to_dict</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.VerticalPlumeRelease.attr_to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>refactor to_dict&#8217;s functionality so child classes can convert a
single attribute to_dict instead of doing a whole list of fields</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.VerticalPlumeRelease.deserialize_oc">
<code class="descname">deserialize_oc</code><span class="sig-paren">(</span><em>json_</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.VerticalPlumeRelease.deserialize_oc" title="Permalink to this definition">¶</a></dt>
<dd><p>check contents of orderered collections to figure out what schema to
use.
Basically, the json serialized ordered collection looks like a regular
list.</p>
</dd></dl>

<dl class="attribute">
<dt id="gnome.spill.VerticalPlumeRelease.id">
<code class="descname">id</code><a class="headerlink" href="#gnome.spill.VerticalPlumeRelease.id" title="Permalink to this definition">¶</a></dt>
<dd><p>Override this method for more exotic forms of identification.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a unique ID assigned during construction</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.VerticalPlumeRelease.is_sparse">
<code class="descname">is_sparse</code><span class="sig-paren">(</span><em>json_</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.VerticalPlumeRelease.is_sparse" title="Permalink to this definition">¶</a></dt>
<dd><p>Sparse means that we have a previously created object,
and we are receiving a reference to the object using just
an obj_type and an id.  This is a valid payload that the
Web Client will send.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.VerticalPlumeRelease.loads">
<code class="descname">loads</code><span class="sig-paren">(</span><em>json_data</em>, <em>saveloc=None</em>, <em>references=None</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.VerticalPlumeRelease.loads" title="Permalink to this definition">¶</a></dt>
<dd><p>loads object from json_data</p>
<ul class="simple">
<li>load json for references from files</li>
<li>update paths of datafiles if needed</li>
<li>deserialize json_data</li>
<li>and create object with new_from_dict()</li>
</ul>
<dl class="docutils">
<dt>json_data: dict containing json data. It has been parsed through the</dt>
<dd>json.loads() command. The json will be valided here when it gets
deserialized. Its references and datafile paths will be recreated
here prior to calling new_from_dict()</dd>
</dl>
<p>Optional parameter</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>saveloc</strong> &#8211; location of data files or <a href="#id13"><span class="problematic" id="id14">*</span></a>.json files for objects
stored as references. If object requires no datafiles and does not
need to read references from a <a href="#id15"><span class="problematic" id="id16">*</span></a>.json file in saveloc, then this
can be None.</li>
<li><strong>references</strong> &#8211; references object - if this is called by the Model,
it will pass a references object. It is not required.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">object constructed from json_data.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="gnome.spill.VerticalPlumeRelease.logger">
<code class="descname">logger</code><a class="headerlink" href="#gnome.spill.VerticalPlumeRelease.logger" title="Permalink to this definition">¶</a></dt>
<dd><p>define attribute &#8216;_log&#8217;. If it doesn&#8217;t exist, define it here.
This is so we don&#8217;t have to add it to all PyGnome classes - this
property makes the logger available to each object.
- default log_level is INFO</p>
</dd></dl>

<dl class="attribute">
<dt id="gnome.spill.VerticalPlumeRelease.name">
<code class="descname">name</code><a class="headerlink" href="#gnome.spill.VerticalPlumeRelease.name" title="Permalink to this definition">¶</a></dt>
<dd><p>define as property in base class so all objects will have a name
by default</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.VerticalPlumeRelease.new_from_dict">
<code class="descname">new_from_dict</code><span class="sig-paren">(</span><em>dict_</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.VerticalPlumeRelease.new_from_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>creates a new object from dictionary</p>
<p>This is base implementation and can be over-ridden by classes using
this mixin</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.VerticalPlumeRelease.obj_type_to_dict">
<code class="descname">obj_type_to_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.VerticalPlumeRelease.obj_type_to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>returns object type to save in dict.
This is base implementation and can be over-ridden</p>
</dd></dl>

<dl class="attribute">
<dt id="gnome.spill.VerticalPlumeRelease.release_duration">
<code class="descname">release_duration</code><a class="headerlink" href="#gnome.spill.VerticalPlumeRelease.release_duration" title="Permalink to this definition">¶</a></dt>
<dd><p>returns a timedelta object defining the time over which the particles
are released. The default is 0; derived classes like PointLineRelease
must over-ride</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.VerticalPlumeRelease.rewind">
<code class="descname">rewind</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.VerticalPlumeRelease.rewind" title="Permalink to this definition">¶</a></dt>
<dd><p>rewinds the Release to original status (before anything has been
released).</p>
<p>Base class sets &#8216;num_released&#8217;=0 and &#8216;start_time_invalid&#8217;=True
properties to original _state.
Subclasses should overload for additional functions required to reset
_state.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.VerticalPlumeRelease.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>saveloc</em>, <em>references=None</em>, <em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.VerticalPlumeRelease.save" title="Permalink to this definition">¶</a></dt>
<dd><p>save object state as json to user specified saveloc</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>saveloc</strong> (<em>A path as a string or unicode</em>) &#8211; zip archive or a valid directory. Model files are
either persisted here or a new model is re-created from the files
stored here. The files are clobbered when save() is called.</li>
<li><strong>name=None</strong> &#8211; filename to store json. If None, default name is:
&#8220;{0}.json&#8221;.format(self.__class__.__name__). If saveloc is zipfile,
this is the name of archive in which json for self is stored.</li>
<li><strong>references</strong> &#8211; dict of references mapping &#8216;id&#8217; to a string used for
the reference. The value could be a unique integer or it could be
a filename. It is upto the creator of the reference list to decide
how to reference a nested object.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.VerticalPlumeRelease.serialize">
<code class="descname">serialize</code><span class="sig-paren">(</span><em>json_='webapi'</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.VerticalPlumeRelease.serialize" title="Permalink to this definition">¶</a></dt>
<dd><p>define schema based on type of desired output</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.VerticalPlumeRelease.serialize_oc">
<code class="descname">serialize_oc</code><span class="sig-paren">(</span><em>coll</em>, <em>json_='webapi'</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.VerticalPlumeRelease.serialize_oc" title="Permalink to this definition">¶</a></dt>
<dd><p>Serialize Model attributes of type ordered collection or list - an
iterable containing serializable objects</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.VerticalPlumeRelease.to_dict">
<code class="descname">to_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.VerticalPlumeRelease.to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>returns a dictionary containing the serialized representation of this
object.</p>
<p>For every field, if there is a method defined on the object such that
the method name is <cite>{field_name}_to_dict</cite>, use the return value of that
method as the field value.</p>
<p>Note: any field in <cite>list</cite> that does not exist on the
object and does not have a to_dict method will raise an AttributeError.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>json_='webapi'</strong> &#8211; return the attributes for json payload for
webapi.
The other option is &#8216;save&#8217; corresponding with
json for save files.</td>
</tr>
</tbody>
</table>
<p>NOTE: add the json_=&#8217;webapi&#8217; key to be serialized so we know what the
serialization is for</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.VerticalPlumeRelease.to_serialize">
<code class="descname">to_serialize</code><span class="sig-paren">(</span><em>json_='webapi'</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.VerticalPlumeRelease.to_serialize" title="Permalink to this definition">¶</a></dt>
<dd><p>invoke to_dict() which converts all attributes defined in _state to
dict. If json_=&#8217;save&#8217;, it subselects the Fields with save=True. If
json_=&#8217;webapi&#8217;, it subselects Fields with (update=True, read=True)</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.VerticalPlumeRelease.update_attr">
<code class="descname">update_attr</code><span class="sig-paren">(</span><em>name</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.VerticalPlumeRelease.update_attr" title="Permalink to this definition">¶</a></dt>
<dd><p>update the attribute defined by &#8216;name&#8217; with given &#8216;value&#8217;</p>
<p>If there is a method defined on the object such that the method name is
<cite>{name}_from_dict</cite>, call that method with the field&#8217;s data.</p>
<p>If neither method exists, then set the field with the value from
<code class="docutils literal"><span class="pre">data</span></code> directly on the object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> (<em>str</em>) &#8211; name of attribute to be updated</li>
<li><strong>value</strong> (<em>depends on each attribute being updated</em>) &#8211; the new value of the attribute</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.VerticalPlumeRelease.update_from_dict">
<code class="descname">update_from_dict</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.VerticalPlumeRelease.update_from_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the attributes of this object using the dictionary <code class="docutils literal"><span class="pre">data</span></code> by
looking up the value of each key in <code class="docutils literal"><span class="pre">data</span></code>.
The fields in self._state that have update=True are modified. The
remaining keys in &#8216;data&#8217; are ignored. The object&#8217;s _state attribute
defines what fields can be updated</p>
<p>If an attribute has changed, then call &#8216;update_attr&#8217; to update its
value.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>data</strong> (<em>dict</em>) &#8211; dict containing state of object per the client</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">True if something changed, False otherwise</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">bool</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Does not do updates on nested objects. If the attribute references
another Serializable object, then the value is not a dict but
rather the updated object. For instance, WindMover will receive:</p>
<blockquote>
<div>{..., &#8216;wind&#8217;: &lt;Wind object&gt;}</div></blockquote>
<p class="last">as opposed to a nested dict of the &#8216;wind&#8217; object. It is expected
that the &#8216;wind&#8217; object was updated by calling its own
update_from_dict then added to this dict as the updated object.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.VerticalPlumeRelease.validate">
<code class="descname">validate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.VerticalPlumeRelease.validate" title="Permalink to this definition">¶</a></dt>
<dd><p>All pygnome objects should be able to validate themselves. Many
py_gnome objects reference other objects like wind, water, waves. These
may not be defined when object is created so they can be None at
construction time; however, they should reference valid objects
when running model. If make_default_refs is True, then object isvalid
because model will set these up at runtime. To raise exception
for missing references at runtime, directly call
validate_refs(level=&#8217;error&#8217;)</p>
<p>&#8216;wind&#8217;, &#8216;water&#8217;, &#8216;waves&#8217; attributes also have special meaning. An
object containing this attribute references the corresponding object.</p>
<p>Logs warnings
:returns: a tuple of length two containing:</p>
<blockquote>
<div>(a list of messages that were logged, isvalid bool)
If any references are missing and make_default_refs is False,
object is not valid</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.VerticalPlumeRelease.validate_refs">
<code class="descname">validate_refs</code><span class="sig-paren">(</span><em>refs=['wind', 'water', 'waves']</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.VerticalPlumeRelease.validate_refs" title="Permalink to this definition">¶</a></dt>
<dd><p>level is the logging level to use for messages. Default is &#8216;warning&#8217;
but if called from prepare_for_model_run, we want to use error and
raise exception.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-gnome.spill.elements.element_type">
<span id="gnome-spill-elements-classes-in-the-elements-module"></span><h2><code class="docutils literal"><span class="pre">gnome.spill.elements</span></code> &#8211; classes in the elements module<a class="headerlink" href="#module-gnome.spill.elements.element_type" title="Permalink to this headline">¶</a></h2>
<p>Types of elements that a spill can expect
These are properties that are spill specific like:</p>
<blockquote>
<div>&#8216;floating&#8217; element_types would contain windage_range, windage_persist
&#8216;subsurface_dist&#8217; element_types would contain rise velocity distribution info
&#8216;nonweathering&#8217; element_types would set use_droplet_size flag to False
&#8216;weathering&#8217; element_types would use droplet_size, densities, mass?</div></blockquote>
<dl class="class">
<dt id="gnome.spill.elements.element_type.ElementType">
<em class="property">class </em><code class="descclassname">gnome.spill.elements.element_type.</code><code class="descname">ElementType</code><span class="sig-paren">(</span><em>initializers=[]</em>, <em>substance=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/spill/elements/element_type.html#ElementType"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.spill.elements.element_type.ElementType" title="Permalink to this definition">¶</a></dt>
<dd><p>Define initializers for the type of elements.
The default element_type has a substance with density of water
(1000 kg/m^3). This is labeled as &#8216;oil_conservaitve&#8217;, same as in
original gnome. This is currently one of the mock (&#8220;fake&#8221;) oil objects,
used primarily to help integrate weathering processes. It doesn&#8217;t mean
weathering is off - if there are no weatherers, then oil doesn&#8217;t
weather.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>initializers</strong> (<em>iterbale</em>) &#8211; a list/tuple of initializer classes used
to initialize these data arrays upon release. If this is not an
iterable, then just append &#8216;initializer&#8217; to list of initializers
assuming it is just a single initializer object</li>
<li><strong>substance=None</strong> &#8211; Type of oil spilled. If this is a
string, then use get_oil_props to get the OilProps object, else
assume it is an OilProps object. If it is None, then assume there
is no weathering.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="gnome.spill.elements.element_type.ElementType.substance_to_dict">
<code class="descname">substance_to_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/spill/elements/element_type.html#ElementType.substance_to_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.spill.elements.element_type.ElementType.substance_to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Call the tojson() method on substance
- An Oil object that has been queried from the database</p>
<blockquote>
<div>contains a lot of unnecessary relationships that we do not
want to represent in our JSON output,
So we prune them by first constructing an Oil object from the
JSON payload of the queried Oil object.
This creates an Oil object in memory that does not have any
database links.
Then we output the JSON from the unlinked object.</div></blockquote>
</dd></dl>

<dl class="attribute">
<dt id="gnome.spill.elements.element_type.ElementType.array_types">
<code class="descname">array_types</code><a class="headerlink" href="#gnome.spill.elements.element_type.ElementType.array_types" title="Permalink to this definition">¶</a></dt>
<dd><p>compile/return dict of array_types set by all initializers contained
by ElementType object</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.elements.element_type.ElementType.set_newparticle_values">
<code class="descname">set_newparticle_values</code><span class="sig-paren">(</span><em>num_new_particles</em>, <em>spill</em>, <em>data_arrays</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/spill/elements/element_type.html#ElementType.set_newparticle_values"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.spill.elements.element_type.ElementType.set_newparticle_values" title="Permalink to this definition">¶</a></dt>
<dd><p>call all initializers. This will set the initial values for all
data_arrays.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.elements.element_type.ElementType.to_dict">
<code class="descname">to_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/spill/elements/element_type.html#ElementType.to_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.spill.elements.element_type.ElementType.to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>call the to_dict method on each object in the initializers dict. Store
results in dict and return.</p>
<p>todo: the standard to_dict doesn&#8217;t seem to fit well in this case. It
works but perhaps can/should be revisited to make it simpler</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.elements.element_type.ElementType.initializers_to_dict">
<code class="descname">initializers_to_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/spill/elements/element_type.html#ElementType.initializers_to_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.spill.elements.element_type.ElementType.initializers_to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>just return the initializers</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.elements.element_type.ElementType.serialize">
<code class="descname">serialize</code><span class="sig-paren">(</span><em>json_='webapi'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/spill/elements/element_type.html#ElementType.serialize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.spill.elements.element_type.ElementType.serialize" title="Permalink to this definition">¶</a></dt>
<dd><p>serialize each object in &#8216;initializers&#8217; dict, then add it to the json
for the ElementType object.</p>
<p>Note: the to_dict() method returns a dict of initializers as well;
however, the schemas associated with the initializers are dynamic
(eg initializers that contain a distribution). It is easier to call the
initializer&#8217;s serialize() method instead of adding the initializer&#8217;s
schemas to the ElementType schema since they are not known ahead of
time.</p>
</dd></dl>

<dl class="classmethod">
<dt id="gnome.spill.elements.element_type.ElementType.deserialize">
<em class="property">classmethod </em><code class="descname">deserialize</code><span class="sig-paren">(</span><em>json_</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/spill/elements/element_type.html#ElementType.deserialize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.spill.elements.element_type.ElementType.deserialize" title="Permalink to this definition">¶</a></dt>
<dd><p>deserialize each object in the &#8216;initializers&#8217; dict, then add it to
deserialized ElementType dict</p>
<p>We also need to accept sparse json objects, in which case we will
not treat them, but just send them back.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.elements.element_type.ElementType.attr_to_dict">
<code class="descname">attr_to_dict</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.elements.element_type.ElementType.attr_to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>refactor to_dict&#8217;s functionality so child classes can convert a
single attribute to_dict instead of doing a whole list of fields</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.elements.element_type.ElementType.deserialize_oc">
<code class="descname">deserialize_oc</code><span class="sig-paren">(</span><em>json_</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.elements.element_type.ElementType.deserialize_oc" title="Permalink to this definition">¶</a></dt>
<dd><p>check contents of orderered collections to figure out what schema to
use.
Basically, the json serialized ordered collection looks like a regular
list.</p>
</dd></dl>

<dl class="attribute">
<dt id="gnome.spill.elements.element_type.ElementType.id">
<code class="descname">id</code><a class="headerlink" href="#gnome.spill.elements.element_type.ElementType.id" title="Permalink to this definition">¶</a></dt>
<dd><p>Override this method for more exotic forms of identification.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a unique ID assigned during construction</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.elements.element_type.ElementType.is_sparse">
<code class="descname">is_sparse</code><span class="sig-paren">(</span><em>json_</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.elements.element_type.ElementType.is_sparse" title="Permalink to this definition">¶</a></dt>
<dd><p>Sparse means that we have a previously created object,
and we are receiving a reference to the object using just
an obj_type and an id.  This is a valid payload that the
Web Client will send.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.elements.element_type.ElementType.loads">
<code class="descname">loads</code><span class="sig-paren">(</span><em>json_data</em>, <em>saveloc=None</em>, <em>references=None</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.elements.element_type.ElementType.loads" title="Permalink to this definition">¶</a></dt>
<dd><p>loads object from json_data</p>
<ul class="simple">
<li>load json for references from files</li>
<li>update paths of datafiles if needed</li>
<li>deserialize json_data</li>
<li>and create object with new_from_dict()</li>
</ul>
<dl class="docutils">
<dt>json_data: dict containing json data. It has been parsed through the</dt>
<dd>json.loads() command. The json will be valided here when it gets
deserialized. Its references and datafile paths will be recreated
here prior to calling new_from_dict()</dd>
</dl>
<p>Optional parameter</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>saveloc</strong> &#8211; location of data files or <a href="#id17"><span class="problematic" id="id18">*</span></a>.json files for objects
stored as references. If object requires no datafiles and does not
need to read references from a <a href="#id19"><span class="problematic" id="id20">*</span></a>.json file in saveloc, then this
can be None.</li>
<li><strong>references</strong> &#8211; references object - if this is called by the Model,
it will pass a references object. It is not required.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">object constructed from json_data.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="gnome.spill.elements.element_type.ElementType.logger">
<code class="descname">logger</code><a class="headerlink" href="#gnome.spill.elements.element_type.ElementType.logger" title="Permalink to this definition">¶</a></dt>
<dd><p>define attribute &#8216;_log&#8217;. If it doesn&#8217;t exist, define it here.
This is so we don&#8217;t have to add it to all PyGnome classes - this
property makes the logger available to each object.
- default log_level is INFO</p>
</dd></dl>

<dl class="attribute">
<dt id="gnome.spill.elements.element_type.ElementType.name">
<code class="descname">name</code><a class="headerlink" href="#gnome.spill.elements.element_type.ElementType.name" title="Permalink to this definition">¶</a></dt>
<dd><p>define as property in base class so all objects will have a name
by default</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.elements.element_type.ElementType.new_from_dict">
<code class="descname">new_from_dict</code><span class="sig-paren">(</span><em>dict_</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.elements.element_type.ElementType.new_from_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>creates a new object from dictionary</p>
<p>This is base implementation and can be over-ridden by classes using
this mixin</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.elements.element_type.ElementType.obj_type_to_dict">
<code class="descname">obj_type_to_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.elements.element_type.ElementType.obj_type_to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>returns object type to save in dict.
This is base implementation and can be over-ridden</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.elements.element_type.ElementType.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>saveloc</em>, <em>references=None</em>, <em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.elements.element_type.ElementType.save" title="Permalink to this definition">¶</a></dt>
<dd><p>save object state as json to user specified saveloc</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>saveloc</strong> (<em>A path as a string or unicode</em>) &#8211; zip archive or a valid directory. Model files are
either persisted here or a new model is re-created from the files
stored here. The files are clobbered when save() is called.</li>
<li><strong>name=None</strong> &#8211; filename to store json. If None, default name is:
&#8220;{0}.json&#8221;.format(self.__class__.__name__). If saveloc is zipfile,
this is the name of archive in which json for self is stored.</li>
<li><strong>references</strong> &#8211; dict of references mapping &#8216;id&#8217; to a string used for
the reference. The value could be a unique integer or it could be
a filename. It is upto the creator of the reference list to decide
how to reference a nested object.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.elements.element_type.ElementType.serialize_oc">
<code class="descname">serialize_oc</code><span class="sig-paren">(</span><em>coll</em>, <em>json_='webapi'</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.elements.element_type.ElementType.serialize_oc" title="Permalink to this definition">¶</a></dt>
<dd><p>Serialize Model attributes of type ordered collection or list - an
iterable containing serializable objects</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.elements.element_type.ElementType.to_serialize">
<code class="descname">to_serialize</code><span class="sig-paren">(</span><em>json_='webapi'</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.elements.element_type.ElementType.to_serialize" title="Permalink to this definition">¶</a></dt>
<dd><p>invoke to_dict() which converts all attributes defined in _state to
dict. If json_=&#8217;save&#8217;, it subselects the Fields with save=True. If
json_=&#8217;webapi&#8217;, it subselects Fields with (update=True, read=True)</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.elements.element_type.ElementType.update_attr">
<code class="descname">update_attr</code><span class="sig-paren">(</span><em>name</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.elements.element_type.ElementType.update_attr" title="Permalink to this definition">¶</a></dt>
<dd><p>update the attribute defined by &#8216;name&#8217; with given &#8216;value&#8217;</p>
<p>If there is a method defined on the object such that the method name is
<cite>{name}_from_dict</cite>, call that method with the field&#8217;s data.</p>
<p>If neither method exists, then set the field with the value from
<code class="docutils literal"><span class="pre">data</span></code> directly on the object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> (<em>str</em>) &#8211; name of attribute to be updated</li>
<li><strong>value</strong> (<em>depends on each attribute being updated</em>) &#8211; the new value of the attribute</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.elements.element_type.ElementType.update_from_dict">
<code class="descname">update_from_dict</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.elements.element_type.ElementType.update_from_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the attributes of this object using the dictionary <code class="docutils literal"><span class="pre">data</span></code> by
looking up the value of each key in <code class="docutils literal"><span class="pre">data</span></code>.
The fields in self._state that have update=True are modified. The
remaining keys in &#8216;data&#8217; are ignored. The object&#8217;s _state attribute
defines what fields can be updated</p>
<p>If an attribute has changed, then call &#8216;update_attr&#8217; to update its
value.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>data</strong> (<em>dict</em>) &#8211; dict containing state of object per the client</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">True if something changed, False otherwise</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">bool</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Does not do updates on nested objects. If the attribute references
another Serializable object, then the value is not a dict but
rather the updated object. For instance, WindMover will receive:</p>
<blockquote>
<div>{..., &#8216;wind&#8217;: &lt;Wind object&gt;}</div></blockquote>
<p class="last">as opposed to a nested dict of the &#8216;wind&#8217; object. It is expected
that the &#8216;wind&#8217; object was updated by calling its own
update_from_dict then added to this dict as the updated object.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.elements.element_type.ElementType.validate">
<code class="descname">validate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.elements.element_type.ElementType.validate" title="Permalink to this definition">¶</a></dt>
<dd><p>All pygnome objects should be able to validate themselves. Many
py_gnome objects reference other objects like wind, water, waves. These
may not be defined when object is created so they can be None at
construction time; however, they should reference valid objects
when running model. If make_default_refs is True, then object isvalid
because model will set these up at runtime. To raise exception
for missing references at runtime, directly call
validate_refs(level=&#8217;error&#8217;)</p>
<p>&#8216;wind&#8217;, &#8216;water&#8217;, &#8216;waves&#8217; attributes also have special meaning. An
object containing this attribute references the corresponding object.</p>
<p>Logs warnings
:returns: a tuple of length two containing:</p>
<blockquote>
<div>(a list of messages that were logged, isvalid bool)
If any references are missing and make_default_refs is False,
object is not valid</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.elements.element_type.ElementType.validate_refs">
<code class="descname">validate_refs</code><span class="sig-paren">(</span><em>refs=['wind', 'water', 'waves']</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.elements.element_type.ElementType.validate_refs" title="Permalink to this definition">¶</a></dt>
<dd><p>level is the logging level to use for messages. Default is &#8216;warning&#8217;
but if called from prepare_for_model_run, we want to use error and
raise exception.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="gnome.spill.elements.element_type.floating">
<code class="descclassname">gnome.spill.elements.element_type.</code><code class="descname">floating</code><span class="sig-paren">(</span><em>windage_range=(0.01</em>, <em>0.04)</em>, <em>windage_persist=900</em>, <em>substance=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/spill/elements/element_type.html#floating"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.spill.elements.element_type.floating" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function returns an ElementType object containing following
initializers:</p>
<p>1. InitWindages(): for initializing &#8216;windages&#8217; with user specified
windage_range and windage_persist.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>substance='oil_conservative'</strong> &#8211; Type of oil spilled. Passed onto
ElementType constructor</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="gnome.spill.elements.element_type.plume">
<code class="descclassname">gnome.spill.elements.element_type.</code><code class="descname">plume</code><span class="sig-paren">(</span><em>distribution_type='droplet_size'</em>, <em>distribution='weibull'</em>, <em>windage_range=(0.01</em>, <em>0.04)</em>, <em>windage_persist=900</em>, <em>substance_name=None</em>, <em>density=None</em>, <em>density_units='kg/m^3'</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/spill/elements/element_type.html#plume"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.spill.elements.element_type.plume" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Helper function returns an ElementType object containing &#8216;rise_vel&#8217;
and &#8216;windages&#8217;
initializer with user specified parameters for distribution.</p>
<p>See below docs for details on the parameters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">param str distribution_type:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><p class="first">default &#8216;droplet_size&#8217; available options:</p>
<p>1. &#8216;droplet_size&#8217;: Droplet size is samples from the specified
distribution. Rise velocity is calculated.</p>
<p>2.&#8217;rise_velocity&#8217;: rise velocity is directly sampled from the specified
distribution. No droplet size is computed.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">param distribution=&#8217;weibull&#8217;:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"></td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">param windage_range=(.01, .04):</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"></td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">param windage_persist=900:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"></td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">param substance_name=&#8217;oil_conservative&#8217;:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"></td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">param float density = None:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"></td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">param str density_units=&#8217;kg/m^3&#8217;:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>Documentation of InitRiseVelFromDropletSizeFromDist:</p>
<blockquote>
<div><p>Set the droplet size from a distribution. Use the C++ get_rise_velocity
function exposed via cython (rise_velocity_from_drop_size) to obtain
rise_velocity from droplet size. Even though the droplet size is not
changing over time, it is still stored in data array, as it can be
useful for post-processing (called &#8216;droplet_diameter&#8217;)</p>
<p>Use distribution to define rise_vel</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">param distribution:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><p class="first">An object capable of generating a probability
distribution.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">type distribution:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><dl class="first docutils">
<dt>Right now, we have:</dt>
<dd><ul class="first last simple">
<li>UniformDistribution</li>
<li>NormalDistribution</li>
<li>LogNormalDistribution</li>
<li>WeibullDistribution</li>
</ul>
</dd>
</dl>
<p>New distribution classes could be made.  The only
requirement is they need to have a set_values()
method which accepts a NumPy array.
(presumably, this function will also modify</p>
<blockquote>
<div><p>the array in some way)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">param water_density:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><p class="first">1020.0 [kg/m3]</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">type water_density:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><p class="first">float</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">param water_viscosity:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><p class="first">1.0e-6 [m^2/s]</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">type water_viscosity:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><p class="first last">float</p>
</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>Documentation of InitRiseVelFromDist:</p>
<blockquote>
<div><p>Set the rise velocity parameters to be sampled from a distribution.</p>
<p>Use distribution to define rise_vel</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">param distribution:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><p class="first">An object capable of generating a probability
distribution.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">type distribution:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><dl class="first docutils">
<dt>Right now, we have:</dt>
<dd><ul class="first last simple">
<li>UniformDistribution</li>
<li>NormalDistribution</li>
<li>LogNormalDistribution</li>
<li>WeibullDistribution</li>
</ul>
</dd>
</dl>
<p>New distribution classes could be made.  The only
requirement is they need to have a set_values()
method which accepts a NumPy array.
(presumably, this function will also modify</p>
<blockquote class="last">
<div><p>the array in some way)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>Documentation of InitWindages:</p>
<blockquote>
<div><p>Initializes the windages, windage_range, windage_persist data arrays.
Initial values for windages use infinite persistence. These are updated
by the WindMover for particles with non-zero persistence.</p>
<p>Optional arguments:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">param windage_range=(0.01, 0.04):</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body">the windage range of the elements
default is (0.01, 0.04) from 1% to 4%.</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">type windage_range:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body">tuple: (min, max)</td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">param windage_persist=-1:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body">Default is 900s, so windage is updated every
900 sec. -1 means the persistence is infinite so it is only set at
the beginning of the run.</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">type windage_persist:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body">integer seconds</td>
</tr>
</tbody>
</table>
</div></blockquote>
</dd></dl>

</div>
<div class="section" id="module-gnome.movers">
<span id="gnome-movers-pygnome-mover-classes"></span><h2><code class="docutils literal"><span class="pre">gnome.movers</span></code> &#8211; PyGnome mover classes<a class="headerlink" href="#module-gnome.movers" title="Permalink to this headline">¶</a></h2>
<p>__init__.py for the gnome package</p>
<dl class="class">
<dt id="gnome.movers.Mover">
<em class="property">class </em><code class="descclassname">gnome.movers.</code><code class="descname">Mover</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/movers/movers.html#Mover"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.movers.Mover" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize default Mover/Weatherer parameters</p>
<p>All parameters are optional (kwargs)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>on</strong> &#8211; boolean as to whether the object is on or not. Default is on</li>
<li><strong>active_start</strong> &#8211; datetime when the mover should be active</li>
<li><strong>active_stop</strong> &#8211; datetime after which the mover should be inactive</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="gnome.movers.Mover.get_move">
<code class="descname">get_move</code><span class="sig-paren">(</span><em>sc</em>, <em>time_step</em>, <em>model_time_datetime</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/movers/movers.html#Mover.get_move"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.movers.Mover.get_move" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the move in (long,lat,z) space. It returns the delta move
for each element of the spill as a numpy array of size
(number_elements X 3) and dtype = gnome.basic_types.world_point_type</p>
<p>Base class returns an array of numpy.nan for delta to indicate the
get_move is not implemented yet.</p>
<p>Each class derived from Mover object must implement it&#8217;s own get_move</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>sc</strong> &#8211; an instance of gnome.spill_container.SpillContainer class</li>
<li><strong>time_step</strong> &#8211; time step in seconds</li>
<li><strong>model_time_datetime</strong> &#8211; current model time as datetime object</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>All movers must implement get_move() since that&#8217;s what the model calls</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="gnome.movers.CyMover">
<em class="property">class </em><code class="descclassname">gnome.movers.</code><code class="descname">CyMover</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/movers/movers.html#CyMover"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.movers.CyMover" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class for python wrappers around cython movers.
Uses super(CyMover,self).__init__(**kwargs) to call Mover class
__init__ method</p>
<p>All cython movers (CyWindMover, CyRandomMover) are instantiated by a
derived class, and then contained by this class in the member &#8216;movers&#8217;.
They will need to extract info from spill object.</p>
<p>We assumes any derived class will instantiate a &#8216;mover&#8217; object that
has methods like: prepare_for_model_run, prepare_for_model_step,</p>
<p>All kwargs passed on to super class</p>
<dl class="method">
<dt id="gnome.movers.CyMover.prepare_for_model_run">
<code class="descname">prepare_for_model_run</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/movers/movers.html#CyMover.prepare_for_model_run"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.movers.CyMover.prepare_for_model_run" title="Permalink to this definition">¶</a></dt>
<dd><p>Calls the contained cython mover&#8217;s prepare_for_model_run()</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.CyMover.prepare_for_model_step">
<code class="descname">prepare_for_model_step</code><span class="sig-paren">(</span><em>sc</em>, <em>time_step</em>, <em>model_time_datetime</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/movers/movers.html#CyMover.prepare_for_model_step"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.movers.CyMover.prepare_for_model_step" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Default implementation of prepare_for_model_step(...)</dt>
<dd><ul class="first last simple">
<li>Sets the mover&#8217;s active flag if time is within specified timespan
(done in base class Mover)</li>
<li>Invokes the cython mover&#8217;s prepare_for_model_step</li>
</ul>
</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>sc</strong> &#8211; an instance of gnome.spill_container.SpillContainer class</li>
<li><strong>time_step</strong> &#8211; time step in seconds</li>
<li><strong>model_time_datetime</strong> &#8211; current model time as datetime object</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Uses super to invoke Mover class prepare_for_model_step and does a
couple more things specific to CyMover.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.CyMover.get_move">
<code class="descname">get_move</code><span class="sig-paren">(</span><em>sc</em>, <em>time_step</em>, <em>model_time_datetime</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/movers/movers.html#CyMover.get_move"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.movers.CyMover.get_move" title="Permalink to this definition">¶</a></dt>
<dd><p>Base implementation of Cython wrapped C++ movers
Override for things like the WindMover since it has a different
implementation</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>sc</strong> &#8211; spill_container.SpillContainer object</li>
<li><strong>time_step</strong> &#8211; time step in seconds</li>
<li><strong>model_time_datetime</strong> &#8211; current model time as datetime object</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.CyMover.prepare_data_for_get_move">
<code class="descname">prepare_data_for_get_move</code><span class="sig-paren">(</span><em>sc</em>, <em>model_time_datetime</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/movers/movers.html#CyMover.prepare_data_for_get_move"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.movers.CyMover.prepare_data_for_get_move" title="Permalink to this definition">¶</a></dt>
<dd><p>organizes the spill object into inputs for calling with Cython
wrapper&#8217;s get_move(...)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>sc</strong> &#8211; an instance of gnome.spill_container.SpillContainer class</li>
<li><strong>model_time_datetime</strong> &#8211; current model time as datetime object</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.CyMover.model_step_is_done">
<code class="descname">model_step_is_done</code><span class="sig-paren">(</span><em>sc=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/movers/movers.html#CyMover.model_step_is_done"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.movers.CyMover.model_step_is_done" title="Permalink to this definition">¶</a></dt>
<dd><p>This method gets called by the model after everything else is done
in a time step, and is intended to perform any necessary clean-up
operations. Subclassed movers can override this method.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="gnome.movers.RandomMover">
<em class="property">class </em><code class="descclassname">gnome.movers.</code><code class="descname">RandomMover</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/movers/random_movers.html#RandomMover"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.movers.RandomMover" title="Permalink to this definition">¶</a></dt>
<dd><p>This mover class inherits from CyMover and contains CyRandomMover</p>
<p>The real work is done by CyRandomMover.
CyMover sets everything up that is common to all movers.</p>
<p>Uses super to invoke base class __init__ method.</p>
<p>Optional parameters (kwargs)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>diffusion_coef</strong> &#8211; Diffusion coefficient for random diffusion.
Default is 100,000 cm2/sec</li>
<li><strong>uncertain_factor</strong> &#8211; Uncertainty factor. Default is 2</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Remaining kwargs are passed onto <a class="reference internal" href="#gnome.movers.Mover" title="gnome.movers.Mover"><code class="xref py py-class docutils literal"><span class="pre">gnome.movers.Mover</span></code></a> __init__
using super.  See Mover documentation for remaining valid kwargs.</p>
<dl class="method">
<dt id="gnome.movers.RandomMover.attr_to_dict">
<code class="descname">attr_to_dict</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.RandomMover.attr_to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>refactor to_dict&#8217;s functionality so child classes can convert a
single attribute to_dict instead of doing a whole list of fields</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.RandomMover.datetime_to_seconds">
<code class="descname">datetime_to_seconds</code><span class="sig-paren">(</span><em>model_time</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.RandomMover.datetime_to_seconds" title="Permalink to this definition">¶</a></dt>
<dd><p>Put the time conversion call here - in case we decide to change it, it
only updates here</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.RandomMover.deserialize">
<code class="descname">deserialize</code><span class="sig-paren">(</span><em>json_</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.RandomMover.deserialize" title="Permalink to this definition">¶</a></dt>
<dd><p>classmethod takes json structure as input, deserializes it using a
colander schema then invokes the new_from_dict method to create an
instance of the object described by the json schema.</p>
<p>We also need to accept sparse json objects, in which case we will
not treat them, but just send them back.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.RandomMover.deserialize_oc">
<code class="descname">deserialize_oc</code><span class="sig-paren">(</span><em>json_</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.RandomMover.deserialize_oc" title="Permalink to this definition">¶</a></dt>
<dd><p>check contents of orderered collections to figure out what schema to
use.
Basically, the json serialized ordered collection looks like a regular
list.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.RandomMover.get_move">
<code class="descname">get_move</code><span class="sig-paren">(</span><em>sc</em>, <em>time_step</em>, <em>model_time_datetime</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.RandomMover.get_move" title="Permalink to this definition">¶</a></dt>
<dd><p>Base implementation of Cython wrapped C++ movers
Override for things like the WindMover since it has a different
implementation</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>sc</strong> &#8211; spill_container.SpillContainer object</li>
<li><strong>time_step</strong> &#8211; time step in seconds</li>
<li><strong>model_time_datetime</strong> &#8211; current model time as datetime object</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="gnome.movers.RandomMover.id">
<code class="descname">id</code><a class="headerlink" href="#gnome.movers.RandomMover.id" title="Permalink to this definition">¶</a></dt>
<dd><p>Override this method for more exotic forms of identification.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a unique ID assigned during construction</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.RandomMover.is_sparse">
<code class="descname">is_sparse</code><span class="sig-paren">(</span><em>json_</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.RandomMover.is_sparse" title="Permalink to this definition">¶</a></dt>
<dd><p>Sparse means that we have a previously created object,
and we are receiving a reference to the object using just
an obj_type and an id.  This is a valid payload that the
Web Client will send.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.RandomMover.loads">
<code class="descname">loads</code><span class="sig-paren">(</span><em>json_data</em>, <em>saveloc=None</em>, <em>references=None</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.RandomMover.loads" title="Permalink to this definition">¶</a></dt>
<dd><p>loads object from json_data</p>
<ul class="simple">
<li>load json for references from files</li>
<li>update paths of datafiles if needed</li>
<li>deserialize json_data</li>
<li>and create object with new_from_dict()</li>
</ul>
<dl class="docutils">
<dt>json_data: dict containing json data. It has been parsed through the</dt>
<dd>json.loads() command. The json will be valided here when it gets
deserialized. Its references and datafile paths will be recreated
here prior to calling new_from_dict()</dd>
</dl>
<p>Optional parameter</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>saveloc</strong> &#8211; location of data files or <a href="#id21"><span class="problematic" id="id22">*</span></a>.json files for objects
stored as references. If object requires no datafiles and does not
need to read references from a <a href="#id23"><span class="problematic" id="id24">*</span></a>.json file in saveloc, then this
can be None.</li>
<li><strong>references</strong> &#8211; references object - if this is called by the Model,
it will pass a references object. It is not required.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">object constructed from json_data.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="gnome.movers.RandomMover.logger">
<code class="descname">logger</code><a class="headerlink" href="#gnome.movers.RandomMover.logger" title="Permalink to this definition">¶</a></dt>
<dd><p>define attribute &#8216;_log&#8217;. If it doesn&#8217;t exist, define it here.
This is so we don&#8217;t have to add it to all PyGnome classes - this
property makes the logger available to each object.
- default log_level is INFO</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.RandomMover.model_step_is_done">
<code class="descname">model_step_is_done</code><span class="sig-paren">(</span><em>sc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.RandomMover.model_step_is_done" title="Permalink to this definition">¶</a></dt>
<dd><p>This method gets called by the model after everything else is done
in a time step, and is intended to perform any necessary clean-up
operations. Subclassed movers can override this method.</p>
</dd></dl>

<dl class="attribute">
<dt id="gnome.movers.RandomMover.name">
<code class="descname">name</code><a class="headerlink" href="#gnome.movers.RandomMover.name" title="Permalink to this definition">¶</a></dt>
<dd><p>define as property in base class so all objects will have a name
by default</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.RandomMover.new_from_dict">
<code class="descname">new_from_dict</code><span class="sig-paren">(</span><em>dict_</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.RandomMover.new_from_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>creates a new object from dictionary</p>
<p>This is base implementation and can be over-ridden by classes using
this mixin</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.RandomMover.obj_type_to_dict">
<code class="descname">obj_type_to_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.RandomMover.obj_type_to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>returns object type to save in dict.
This is base implementation and can be over-ridden</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.RandomMover.prepare_data_for_get_move">
<code class="descname">prepare_data_for_get_move</code><span class="sig-paren">(</span><em>sc</em>, <em>model_time_datetime</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.RandomMover.prepare_data_for_get_move" title="Permalink to this definition">¶</a></dt>
<dd><p>organizes the spill object into inputs for calling with Cython
wrapper&#8217;s get_move(...)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>sc</strong> &#8211; an instance of gnome.spill_container.SpillContainer class</li>
<li><strong>model_time_datetime</strong> &#8211; current model time as datetime object</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.RandomMover.prepare_for_model_run">
<code class="descname">prepare_for_model_run</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.RandomMover.prepare_for_model_run" title="Permalink to this definition">¶</a></dt>
<dd><p>Calls the contained cython mover&#8217;s prepare_for_model_run()</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.RandomMover.prepare_for_model_step">
<code class="descname">prepare_for_model_step</code><span class="sig-paren">(</span><em>sc</em>, <em>time_step</em>, <em>model_time_datetime</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.RandomMover.prepare_for_model_step" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Default implementation of prepare_for_model_step(...)</dt>
<dd><ul class="first last simple">
<li>Sets the mover&#8217;s active flag if time is within specified timespan
(done in base class Mover)</li>
<li>Invokes the cython mover&#8217;s prepare_for_model_step</li>
</ul>
</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>sc</strong> &#8211; an instance of gnome.spill_container.SpillContainer class</li>
<li><strong>time_step</strong> &#8211; time step in seconds</li>
<li><strong>model_time_datetime</strong> &#8211; current model time as datetime object</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Uses super to invoke Mover class prepare_for_model_step and does a
couple more things specific to CyMover.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.RandomMover.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>saveloc</em>, <em>references=None</em>, <em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.RandomMover.save" title="Permalink to this definition">¶</a></dt>
<dd><p>save object state as json to user specified saveloc</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>saveloc</strong> (<em>A path as a string or unicode</em>) &#8211; zip archive or a valid directory. Model files are
either persisted here or a new model is re-created from the files
stored here. The files are clobbered when save() is called.</li>
<li><strong>name=None</strong> &#8211; filename to store json. If None, default name is:
&#8220;{0}.json&#8221;.format(self.__class__.__name__). If saveloc is zipfile,
this is the name of archive in which json for self is stored.</li>
<li><strong>references</strong> &#8211; dict of references mapping &#8216;id&#8217; to a string used for
the reference. The value could be a unique integer or it could be
a filename. It is upto the creator of the reference list to decide
how to reference a nested object.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.RandomMover.serialize">
<code class="descname">serialize</code><span class="sig-paren">(</span><em>json_='webapi'</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.RandomMover.serialize" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the dict returned by object&#8217;s to_dict method to valid json
format via colander schema</p>
<p>It uses the modules_dict defined in gnome.persist to find the correct
schema module.</p>
<ol class="arabic">
<li><dl class="first docutils">
<dt>adds &#8216;obj_type&#8217; field to _state for &#8216;save&#8217; attribute so it is</dt>
<dd><p class="first last">contained in serialized data. todo: check if this is needed</p>
</dd>
</dl>
</li>
<li><p class="first">do serialization and return json</p>
</li>
</ol>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>do</strong> &#8211; tells object where serialization is for update or for
creating a new object</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">json format of serialized data</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Note: creating a new object versus &#8216;update&#8217; or &#8216;read&#8217; has a different</dt>
<dd>set of fields for serialization so &#8216;do&#8217; is required.
todo: revisit this to see if it still makes sense to have different
attributes for different operations like &#8216;update&#8217;, &#8216;save&#8217;, &#8216;read&#8217;</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.RandomMover.serialize_oc">
<code class="descname">serialize_oc</code><span class="sig-paren">(</span><em>coll</em>, <em>json_='webapi'</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.RandomMover.serialize_oc" title="Permalink to this definition">¶</a></dt>
<dd><p>Serialize Model attributes of type ordered collection or list - an
iterable containing serializable objects</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.RandomMover.to_dict">
<code class="descname">to_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.RandomMover.to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>returns a dictionary containing the serialized representation of this
object.</p>
<p>For every field, if there is a method defined on the object such that
the method name is <cite>{field_name}_to_dict</cite>, use the return value of that
method as the field value.</p>
<p>Note: any field in <cite>list</cite> that does not exist on the
object and does not have a to_dict method will raise an AttributeError.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>json_='webapi'</strong> &#8211; return the attributes for json payload for
webapi.
The other option is &#8216;save&#8217; corresponding with
json for save files.</td>
</tr>
</tbody>
</table>
<p>NOTE: add the json_=&#8217;webapi&#8217; key to be serialized so we know what the
serialization is for</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.RandomMover.to_serialize">
<code class="descname">to_serialize</code><span class="sig-paren">(</span><em>json_='webapi'</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.RandomMover.to_serialize" title="Permalink to this definition">¶</a></dt>
<dd><p>invoke to_dict() which converts all attributes defined in _state to
dict. If json_=&#8217;save&#8217;, it subselects the Fields with save=True. If
json_=&#8217;webapi&#8217;, it subselects Fields with (update=True, read=True)</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.RandomMover.update_attr">
<code class="descname">update_attr</code><span class="sig-paren">(</span><em>name</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.RandomMover.update_attr" title="Permalink to this definition">¶</a></dt>
<dd><p>update the attribute defined by &#8216;name&#8217; with given &#8216;value&#8217;</p>
<p>If there is a method defined on the object such that the method name is
<cite>{name}_from_dict</cite>, call that method with the field&#8217;s data.</p>
<p>If neither method exists, then set the field with the value from
<code class="docutils literal"><span class="pre">data</span></code> directly on the object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> (<em>str</em>) &#8211; name of attribute to be updated</li>
<li><strong>value</strong> (<em>depends on each attribute being updated</em>) &#8211; the new value of the attribute</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.RandomMover.update_from_dict">
<code class="descname">update_from_dict</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.RandomMover.update_from_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the attributes of this object using the dictionary <code class="docutils literal"><span class="pre">data</span></code> by
looking up the value of each key in <code class="docutils literal"><span class="pre">data</span></code>.
The fields in self._state that have update=True are modified. The
remaining keys in &#8216;data&#8217; are ignored. The object&#8217;s _state attribute
defines what fields can be updated</p>
<p>If an attribute has changed, then call &#8216;update_attr&#8217; to update its
value.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>data</strong> (<em>dict</em>) &#8211; dict containing state of object per the client</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">True if something changed, False otherwise</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">bool</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Does not do updates on nested objects. If the attribute references
another Serializable object, then the value is not a dict but
rather the updated object. For instance, WindMover will receive:</p>
<blockquote>
<div>{..., &#8216;wind&#8217;: &lt;Wind object&gt;}</div></blockquote>
<p class="last">as opposed to a nested dict of the &#8216;wind&#8217; object. It is expected
that the &#8216;wind&#8217; object was updated by calling its own
update_from_dict then added to this dict as the updated object.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.RandomMover.validate">
<code class="descname">validate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.RandomMover.validate" title="Permalink to this definition">¶</a></dt>
<dd><p>All pygnome objects should be able to validate themselves. Many
py_gnome objects reference other objects like wind, water, waves. These
may not be defined when object is created so they can be None at
construction time; however, they should reference valid objects
when running model. If make_default_refs is True, then object isvalid
because model will set these up at runtime. To raise exception
for missing references at runtime, directly call
validate_refs(level=&#8217;error&#8217;)</p>
<p>&#8216;wind&#8217;, &#8216;water&#8217;, &#8216;waves&#8217; attributes also have special meaning. An
object containing this attribute references the corresponding object.</p>
<p>Logs warnings
:returns: a tuple of length two containing:</p>
<blockquote>
<div>(a list of messages that were logged, isvalid bool)
If any references are missing and make_default_refs is False,
object is not valid</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.RandomMover.validate_refs">
<code class="descname">validate_refs</code><span class="sig-paren">(</span><em>refs=['wind', 'water', 'waves']</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.RandomMover.validate_refs" title="Permalink to this definition">¶</a></dt>
<dd><p>level is the logging level to use for messages. Default is &#8216;warning&#8217;
but if called from prepare_for_model_run, we want to use error and
raise exception.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="gnome.movers.GridCurrentMover">
<em class="property">class </em><code class="descclassname">gnome.movers.</code><code class="descname">GridCurrentMover</code><span class="sig-paren">(</span><em>filename</em>, <em>topology_file=None</em>, <em>extrapolate=False</em>, <em>time_offset=0</em>, <em>current_scale=1</em>, <em>uncertain_along=0.5</em>, <em>uncertain_across=0.25</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/movers/current_movers.html#GridCurrentMover"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.movers.GridCurrentMover" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize a GridCurrentMover</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>filename</strong> &#8211; absolute or relative path to the data file:
could be netcdf or filelist</li>
<li><strong>topology_file=None</strong> &#8211; absolute or relative path to topology file.
If not given, the GridCurrentMover will
compute the topology from the data file.</li>
<li><strong>active_start</strong> &#8211; datetime when the mover should be active</li>
<li><strong>active_stop</strong> &#8211; datetime after which the mover should be inactive</li>
<li><strong>current_scale</strong> &#8211; Value to scale current data</li>
<li><strong>uncertain_duration</strong> &#8211; how often does a given uncertain element
get reset</li>
<li><strong>uncertain_time_delay</strong> &#8211; when does the uncertainly kick in.</li>
<li><strong>uncertain_cross</strong> &#8211; Scale for uncertainty perpendicular to the flow</li>
<li><strong>uncertain_along</strong> &#8211; Scale for uncertainty parallel to the flow</li>
<li><strong>extrapolate</strong> &#8211; Allow current data to be extrapolated
before and after file data</li>
<li><strong>time_offset</strong> &#8211; Time zone shift if data is in GMT</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>uses super, super(GridCurrentMover,self).__init__(**kwargs)</p>
<dl class="method">
<dt id="gnome.movers.GridCurrentMover.get_scaled_velocities">
<code class="descname">get_scaled_velocities</code><span class="sig-paren">(</span><em>time</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/movers/current_movers.html#GridCurrentMover.get_scaled_velocities"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.movers.GridCurrentMover.get_scaled_velocities" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>model_time=0</strong> &#8211; </td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridCurrentMover.export_topology">
<code class="descname">export_topology</code><span class="sig-paren">(</span><em>topology_file</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/movers/current_movers.html#GridCurrentMover.export_topology"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.movers.GridCurrentMover.export_topology" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>topology_file=None</strong> &#8211; absolute or relative path where
topology file will be written.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridCurrentMover.extrapolate_in_time">
<code class="descname">extrapolate_in_time</code><span class="sig-paren">(</span><em>extrapolate</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/movers/current_movers.html#GridCurrentMover.extrapolate_in_time"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.movers.GridCurrentMover.extrapolate_in_time" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>extrapolate=false</strong> &#8211; allow current data to be extrapolated
before and after file data.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridCurrentMover.offset_time">
<code class="descname">offset_time</code><span class="sig-paren">(</span><em>time_offset</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/movers/current_movers.html#GridCurrentMover.offset_time"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.movers.GridCurrentMover.offset_time" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>offset_time=0</strong> &#8211; allow data to be in GMT with a time zone offset
(hours).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridCurrentMover.get_offset_time">
<code class="descname">get_offset_time</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/movers/current_movers.html#GridCurrentMover.get_offset_time"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.movers.GridCurrentMover.get_offset_time" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>offset_time=0</strong> &#8211; allow data to be in GMT with a time zone offset
(hours).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridCurrentMover.attr_to_dict">
<code class="descname">attr_to_dict</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.GridCurrentMover.attr_to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>refactor to_dict&#8217;s functionality so child classes can convert a
single attribute to_dict instead of doing a whole list of fields</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridCurrentMover.datetime_to_seconds">
<code class="descname">datetime_to_seconds</code><span class="sig-paren">(</span><em>model_time</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.GridCurrentMover.datetime_to_seconds" title="Permalink to this definition">¶</a></dt>
<dd><p>Put the time conversion call here - in case we decide to change it, it
only updates here</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridCurrentMover.deserialize">
<code class="descname">deserialize</code><span class="sig-paren">(</span><em>json_</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.GridCurrentMover.deserialize" title="Permalink to this definition">¶</a></dt>
<dd><p>classmethod takes json structure as input, deserializes it using a
colander schema then invokes the new_from_dict method to create an
instance of the object described by the json schema.</p>
<p>We also need to accept sparse json objects, in which case we will
not treat them, but just send them back.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridCurrentMover.deserialize_oc">
<code class="descname">deserialize_oc</code><span class="sig-paren">(</span><em>json_</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.GridCurrentMover.deserialize_oc" title="Permalink to this definition">¶</a></dt>
<dd><p>check contents of orderered collections to figure out what schema to
use.
Basically, the json serialized ordered collection looks like a regular
list.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridCurrentMover.get_move">
<code class="descname">get_move</code><span class="sig-paren">(</span><em>sc</em>, <em>time_step</em>, <em>model_time_datetime</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.GridCurrentMover.get_move" title="Permalink to this definition">¶</a></dt>
<dd><p>Base implementation of Cython wrapped C++ movers
Override for things like the WindMover since it has a different
implementation</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>sc</strong> &#8211; spill_container.SpillContainer object</li>
<li><strong>time_step</strong> &#8211; time step in seconds</li>
<li><strong>model_time_datetime</strong> &#8211; current model time as datetime object</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="gnome.movers.GridCurrentMover.id">
<code class="descname">id</code><a class="headerlink" href="#gnome.movers.GridCurrentMover.id" title="Permalink to this definition">¶</a></dt>
<dd><p>Override this method for more exotic forms of identification.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a unique ID assigned during construction</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridCurrentMover.is_sparse">
<code class="descname">is_sparse</code><span class="sig-paren">(</span><em>json_</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.GridCurrentMover.is_sparse" title="Permalink to this definition">¶</a></dt>
<dd><p>Sparse means that we have a previously created object,
and we are receiving a reference to the object using just
an obj_type and an id.  This is a valid payload that the
Web Client will send.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridCurrentMover.loads">
<code class="descname">loads</code><span class="sig-paren">(</span><em>json_data</em>, <em>saveloc=None</em>, <em>references=None</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.GridCurrentMover.loads" title="Permalink to this definition">¶</a></dt>
<dd><p>loads object from json_data</p>
<ul class="simple">
<li>load json for references from files</li>
<li>update paths of datafiles if needed</li>
<li>deserialize json_data</li>
<li>and create object with new_from_dict()</li>
</ul>
<dl class="docutils">
<dt>json_data: dict containing json data. It has been parsed through the</dt>
<dd>json.loads() command. The json will be valided here when it gets
deserialized. Its references and datafile paths will be recreated
here prior to calling new_from_dict()</dd>
</dl>
<p>Optional parameter</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>saveloc</strong> &#8211; location of data files or <a href="#id25"><span class="problematic" id="id26">*</span></a>.json files for objects
stored as references. If object requires no datafiles and does not
need to read references from a <a href="#id27"><span class="problematic" id="id28">*</span></a>.json file in saveloc, then this
can be None.</li>
<li><strong>references</strong> &#8211; references object - if this is called by the Model,
it will pass a references object. It is not required.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">object constructed from json_data.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="gnome.movers.GridCurrentMover.logger">
<code class="descname">logger</code><a class="headerlink" href="#gnome.movers.GridCurrentMover.logger" title="Permalink to this definition">¶</a></dt>
<dd><p>define attribute &#8216;_log&#8217;. If it doesn&#8217;t exist, define it here.
This is so we don&#8217;t have to add it to all PyGnome classes - this
property makes the logger available to each object.
- default log_level is INFO</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridCurrentMover.model_step_is_done">
<code class="descname">model_step_is_done</code><span class="sig-paren">(</span><em>sc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.GridCurrentMover.model_step_is_done" title="Permalink to this definition">¶</a></dt>
<dd><p>This method gets called by the model after everything else is done
in a time step, and is intended to perform any necessary clean-up
operations. Subclassed movers can override this method.</p>
</dd></dl>

<dl class="attribute">
<dt id="gnome.movers.GridCurrentMover.name">
<code class="descname">name</code><a class="headerlink" href="#gnome.movers.GridCurrentMover.name" title="Permalink to this definition">¶</a></dt>
<dd><p>define as property in base class so all objects will have a name
by default</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridCurrentMover.new_from_dict">
<code class="descname">new_from_dict</code><span class="sig-paren">(</span><em>dict_</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.GridCurrentMover.new_from_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>creates a new object from dictionary</p>
<p>This is base implementation and can be over-ridden by classes using
this mixin</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridCurrentMover.obj_type_to_dict">
<code class="descname">obj_type_to_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.GridCurrentMover.obj_type_to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>returns object type to save in dict.
This is base implementation and can be over-ridden</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridCurrentMover.prepare_data_for_get_move">
<code class="descname">prepare_data_for_get_move</code><span class="sig-paren">(</span><em>sc</em>, <em>model_time_datetime</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.GridCurrentMover.prepare_data_for_get_move" title="Permalink to this definition">¶</a></dt>
<dd><p>organizes the spill object into inputs for calling with Cython
wrapper&#8217;s get_move(...)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>sc</strong> &#8211; an instance of gnome.spill_container.SpillContainer class</li>
<li><strong>model_time_datetime</strong> &#8211; current model time as datetime object</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridCurrentMover.prepare_for_model_run">
<code class="descname">prepare_for_model_run</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.GridCurrentMover.prepare_for_model_run" title="Permalink to this definition">¶</a></dt>
<dd><p>Calls the contained cython mover&#8217;s prepare_for_model_run()</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridCurrentMover.prepare_for_model_step">
<code class="descname">prepare_for_model_step</code><span class="sig-paren">(</span><em>sc</em>, <em>time_step</em>, <em>model_time_datetime</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.GridCurrentMover.prepare_for_model_step" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Default implementation of prepare_for_model_step(...)</dt>
<dd><ul class="first last simple">
<li>Sets the mover&#8217;s active flag if time is within specified timespan
(done in base class Mover)</li>
<li>Invokes the cython mover&#8217;s prepare_for_model_step</li>
</ul>
</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>sc</strong> &#8211; an instance of gnome.spill_container.SpillContainer class</li>
<li><strong>time_step</strong> &#8211; time step in seconds</li>
<li><strong>model_time_datetime</strong> &#8211; current model time as datetime object</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Uses super to invoke Mover class prepare_for_model_step and does a
couple more things specific to CyMover.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridCurrentMover.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>saveloc</em>, <em>references=None</em>, <em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.GridCurrentMover.save" title="Permalink to this definition">¶</a></dt>
<dd><p>save object state as json to user specified saveloc</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>saveloc</strong> (<em>A path as a string or unicode</em>) &#8211; zip archive or a valid directory. Model files are
either persisted here or a new model is re-created from the files
stored here. The files are clobbered when save() is called.</li>
<li><strong>name=None</strong> &#8211; filename to store json. If None, default name is:
&#8220;{0}.json&#8221;.format(self.__class__.__name__). If saveloc is zipfile,
this is the name of archive in which json for self is stored.</li>
<li><strong>references</strong> &#8211; dict of references mapping &#8216;id&#8217; to a string used for
the reference. The value could be a unique integer or it could be
a filename. It is upto the creator of the reference list to decide
how to reference a nested object.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridCurrentMover.serialize">
<code class="descname">serialize</code><span class="sig-paren">(</span><em>json_='webapi'</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.GridCurrentMover.serialize" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the dict returned by object&#8217;s to_dict method to valid json
format via colander schema</p>
<p>It uses the modules_dict defined in gnome.persist to find the correct
schema module.</p>
<ol class="arabic">
<li><dl class="first docutils">
<dt>adds &#8216;obj_type&#8217; field to _state for &#8216;save&#8217; attribute so it is</dt>
<dd><p class="first last">contained in serialized data. todo: check if this is needed</p>
</dd>
</dl>
</li>
<li><p class="first">do serialization and return json</p>
</li>
</ol>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>do</strong> &#8211; tells object where serialization is for update or for
creating a new object</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">json format of serialized data</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Note: creating a new object versus &#8216;update&#8217; or &#8216;read&#8217; has a different</dt>
<dd>set of fields for serialization so &#8216;do&#8217; is required.
todo: revisit this to see if it still makes sense to have different
attributes for different operations like &#8216;update&#8217;, &#8216;save&#8217;, &#8216;read&#8217;</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridCurrentMover.serialize_oc">
<code class="descname">serialize_oc</code><span class="sig-paren">(</span><em>coll</em>, <em>json_='webapi'</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.GridCurrentMover.serialize_oc" title="Permalink to this definition">¶</a></dt>
<dd><p>Serialize Model attributes of type ordered collection or list - an
iterable containing serializable objects</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridCurrentMover.to_dict">
<code class="descname">to_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.GridCurrentMover.to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>returns a dictionary containing the serialized representation of this
object.</p>
<p>For every field, if there is a method defined on the object such that
the method name is <cite>{field_name}_to_dict</cite>, use the return value of that
method as the field value.</p>
<p>Note: any field in <cite>list</cite> that does not exist on the
object and does not have a to_dict method will raise an AttributeError.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>json_='webapi'</strong> &#8211; return the attributes for json payload for
webapi.
The other option is &#8216;save&#8217; corresponding with
json for save files.</td>
</tr>
</tbody>
</table>
<p>NOTE: add the json_=&#8217;webapi&#8217; key to be serialized so we know what the
serialization is for</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridCurrentMover.to_serialize">
<code class="descname">to_serialize</code><span class="sig-paren">(</span><em>json_='webapi'</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.GridCurrentMover.to_serialize" title="Permalink to this definition">¶</a></dt>
<dd><p>invoke to_dict() which converts all attributes defined in _state to
dict. If json_=&#8217;save&#8217;, it subselects the Fields with save=True. If
json_=&#8217;webapi&#8217;, it subselects Fields with (update=True, read=True)</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridCurrentMover.update_attr">
<code class="descname">update_attr</code><span class="sig-paren">(</span><em>name</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.GridCurrentMover.update_attr" title="Permalink to this definition">¶</a></dt>
<dd><p>update the attribute defined by &#8216;name&#8217; with given &#8216;value&#8217;</p>
<p>If there is a method defined on the object such that the method name is
<cite>{name}_from_dict</cite>, call that method with the field&#8217;s data.</p>
<p>If neither method exists, then set the field with the value from
<code class="docutils literal"><span class="pre">data</span></code> directly on the object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> (<em>str</em>) &#8211; name of attribute to be updated</li>
<li><strong>value</strong> (<em>depends on each attribute being updated</em>) &#8211; the new value of the attribute</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridCurrentMover.update_from_dict">
<code class="descname">update_from_dict</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.GridCurrentMover.update_from_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the attributes of this object using the dictionary <code class="docutils literal"><span class="pre">data</span></code> by
looking up the value of each key in <code class="docutils literal"><span class="pre">data</span></code>.
The fields in self._state that have update=True are modified. The
remaining keys in &#8216;data&#8217; are ignored. The object&#8217;s _state attribute
defines what fields can be updated</p>
<p>If an attribute has changed, then call &#8216;update_attr&#8217; to update its
value.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>data</strong> (<em>dict</em>) &#8211; dict containing state of object per the client</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">True if something changed, False otherwise</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">bool</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Does not do updates on nested objects. If the attribute references
another Serializable object, then the value is not a dict but
rather the updated object. For instance, WindMover will receive:</p>
<blockquote>
<div>{..., &#8216;wind&#8217;: &lt;Wind object&gt;}</div></blockquote>
<p class="last">as opposed to a nested dict of the &#8216;wind&#8217; object. It is expected
that the &#8216;wind&#8217; object was updated by calling its own
update_from_dict then added to this dict as the updated object.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridCurrentMover.validate">
<code class="descname">validate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.GridCurrentMover.validate" title="Permalink to this definition">¶</a></dt>
<dd><p>All pygnome objects should be able to validate themselves. Many
py_gnome objects reference other objects like wind, water, waves. These
may not be defined when object is created so they can be None at
construction time; however, they should reference valid objects
when running model. If make_default_refs is True, then object isvalid
because model will set these up at runtime. To raise exception
for missing references at runtime, directly call
validate_refs(level=&#8217;error&#8217;)</p>
<p>&#8216;wind&#8217;, &#8216;water&#8217;, &#8216;waves&#8217; attributes also have special meaning. An
object containing this attribute references the corresponding object.</p>
<p>Logs warnings
:returns: a tuple of length two containing:</p>
<blockquote>
<div>(a list of messages that were logged, isvalid bool)
If any references are missing and make_default_refs is False,
object is not valid</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridCurrentMover.validate_refs">
<code class="descname">validate_refs</code><span class="sig-paren">(</span><em>refs=['wind', 'water', 'waves']</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.GridCurrentMover.validate_refs" title="Permalink to this definition">¶</a></dt>
<dd><p>level is the logging level to use for messages. Default is &#8216;warning&#8217;
but if called from prepare_for_model_run, we want to use error and
raise exception.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="gnome.movers.WindMover">
<em class="property">class </em><code class="descclassname">gnome.movers.</code><code class="descname">WindMover</code><span class="sig-paren">(</span><em>wind=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/movers/wind_movers.html#WindMover"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.movers.WindMover" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">gnome.movers.wind_movers.WindMoversBase</span></code>, <a class="reference internal" href="#gnome.utilities.serializable.Serializable" title="gnome.utilities.serializable.Serializable"><code class="xref py py-class docutils literal"><span class="pre">gnome.utilities.serializable.Serializable</span></code></a></p>
<p>Python wrapper around the Cython wind_mover module.
This class inherits from CyMover and contains CyWindMover</p>
<p>The real work is done by the CyWindMover object.  CyMover
sets everything up that is common to all movers.</p>
<p>Uses super to call CyMover base class __init__</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>wind</strong> &#8211; wind object &#8211; provides the wind time series for the mover</td>
</tr>
</tbody>
</table>
<p>Remaining kwargs are passed onto WindMoversBase __init__ using super.
See Mover documentation for remaining valid kwargs.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Can be initialized with wind=None; however, wind must be
set before running. If wind is not None, toggle make_default_refs
to False since user provided a valid Wind and does not wish to
use the default from the Model.</p>
</div>
<dl class="method">
<dt id="gnome.movers.WindMover.prepare_for_model_run">
<code class="descname">prepare_for_model_run</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/movers/wind_movers.html#WindMover.prepare_for_model_run"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.movers.WindMover.prepare_for_model_run" title="Permalink to this definition">¶</a></dt>
<dd><p>if wind attribute is not set, raise ReferencedObjectNotSet excpetion</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.WindMover.serialize">
<code class="descname">serialize</code><span class="sig-paren">(</span><em>json_='webapi'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/movers/wind_movers.html#WindMover.serialize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.movers.WindMover.serialize" title="Permalink to this definition">¶</a></dt>
<dd><p>Since &#8216;wind&#8217; property is saved as a reference when used in save file
and &#8216;save&#8217; option, need to add appropriate node to WindMover schema</p>
</dd></dl>

<dl class="classmethod">
<dt id="gnome.movers.WindMover.deserialize">
<em class="property">classmethod </em><code class="descname">deserialize</code><span class="sig-paren">(</span><em>json_</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/movers/wind_movers.html#WindMover.deserialize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.movers.WindMover.deserialize" title="Permalink to this definition">¶</a></dt>
<dd><p>append correct schema for wind object</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="gnome.movers.GridWindMover">
<em class="property">class </em><code class="descclassname">gnome.movers.</code><code class="descname">GridWindMover</code><span class="sig-paren">(</span><em>wind_file</em>, <em>topology_file=None</em>, <em>extrapolate=False</em>, <em>time_offset=0</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/movers/wind_movers.html#GridWindMover"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.movers.GridWindMover" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>wind_file</strong> &#8211; file containing wind data on a grid</li>
<li><strong>topology_file</strong> &#8211; Default is None. When exporting topology, it
is stored in this file</li>
<li><strong>wind_scale</strong> &#8211; Value to scale wind data</li>
<li><strong>extrapolate</strong> &#8211; Allow current data to be extrapolated before and
after file data</li>
<li><strong>time_offset</strong> &#8211; Time zone shift if data is in GMT</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Pass optional arguments to base class
uses super: super(GridWindMover,self).__init__(**kwargs)</p>
<dl class="attribute">
<dt id="gnome.movers.GridWindMover.name">
<code class="descname">name</code><a class="headerlink" href="#gnome.movers.GridWindMover.name" title="Permalink to this definition">¶</a></dt>
<dd><p>define as property in base class so all objects will have a name
by default</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridWindMover.attr_to_dict">
<code class="descname">attr_to_dict</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.GridWindMover.attr_to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>refactor to_dict&#8217;s functionality so child classes can convert a
single attribute to_dict instead of doing a whole list of fields</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridWindMover.datetime_to_seconds">
<code class="descname">datetime_to_seconds</code><span class="sig-paren">(</span><em>model_time</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.GridWindMover.datetime_to_seconds" title="Permalink to this definition">¶</a></dt>
<dd><p>Put the time conversion call here - in case we decide to change it, it
only updates here</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridWindMover.deserialize">
<code class="descname">deserialize</code><span class="sig-paren">(</span><em>json_</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.GridWindMover.deserialize" title="Permalink to this definition">¶</a></dt>
<dd><p>classmethod takes json structure as input, deserializes it using a
colander schema then invokes the new_from_dict method to create an
instance of the object described by the json schema.</p>
<p>We also need to accept sparse json objects, in which case we will
not treat them, but just send them back.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridWindMover.deserialize_oc">
<code class="descname">deserialize_oc</code><span class="sig-paren">(</span><em>json_</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.GridWindMover.deserialize_oc" title="Permalink to this definition">¶</a></dt>
<dd><p>check contents of orderered collections to figure out what schema to
use.
Basically, the json serialized ordered collection looks like a regular
list.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridWindMover.get_move">
<code class="descname">get_move</code><span class="sig-paren">(</span><em>sc</em>, <em>time_step</em>, <em>model_time_datetime</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.GridWindMover.get_move" title="Permalink to this definition">¶</a></dt>
<dd><p>Override base class functionality because mover has a different
get_move signature</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>sc</strong> &#8211; an instance of the gnome.SpillContainer class</li>
<li><strong>time_step</strong> &#8211; time step in seconds</li>
<li><strong>model_time_datetime</strong> &#8211; current time of the model as a date time
object</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="gnome.movers.GridWindMover.id">
<code class="descname">id</code><a class="headerlink" href="#gnome.movers.GridWindMover.id" title="Permalink to this definition">¶</a></dt>
<dd><p>Override this method for more exotic forms of identification.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a unique ID assigned during construction</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridWindMover.is_sparse">
<code class="descname">is_sparse</code><span class="sig-paren">(</span><em>json_</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.GridWindMover.is_sparse" title="Permalink to this definition">¶</a></dt>
<dd><p>Sparse means that we have a previously created object,
and we are receiving a reference to the object using just
an obj_type and an id.  This is a valid payload that the
Web Client will send.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridWindMover.loads">
<code class="descname">loads</code><span class="sig-paren">(</span><em>json_data</em>, <em>saveloc=None</em>, <em>references=None</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.GridWindMover.loads" title="Permalink to this definition">¶</a></dt>
<dd><p>loads object from json_data</p>
<ul class="simple">
<li>load json for references from files</li>
<li>update paths of datafiles if needed</li>
<li>deserialize json_data</li>
<li>and create object with new_from_dict()</li>
</ul>
<dl class="docutils">
<dt>json_data: dict containing json data. It has been parsed through the</dt>
<dd>json.loads() command. The json will be valided here when it gets
deserialized. Its references and datafile paths will be recreated
here prior to calling new_from_dict()</dd>
</dl>
<p>Optional parameter</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>saveloc</strong> &#8211; location of data files or <a href="#id29"><span class="problematic" id="id30">*</span></a>.json files for objects
stored as references. If object requires no datafiles and does not
need to read references from a <a href="#id31"><span class="problematic" id="id32">*</span></a>.json file in saveloc, then this
can be None.</li>
<li><strong>references</strong> &#8211; references object - if this is called by the Model,
it will pass a references object. It is not required.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">object constructed from json_data.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="gnome.movers.GridWindMover.logger">
<code class="descname">logger</code><a class="headerlink" href="#gnome.movers.GridWindMover.logger" title="Permalink to this definition">¶</a></dt>
<dd><p>define attribute &#8216;_log&#8217;. If it doesn&#8217;t exist, define it here.
This is so we don&#8217;t have to add it to all PyGnome classes - this
property makes the logger available to each object.
- default log_level is INFO</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridWindMover.model_step_is_done">
<code class="descname">model_step_is_done</code><span class="sig-paren">(</span><em>sc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.GridWindMover.model_step_is_done" title="Permalink to this definition">¶</a></dt>
<dd><p>This method gets called by the model after everything else is done
in a time step, and is intended to perform any necessary clean-up
operations. Subclassed movers can override this method.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridWindMover.new_from_dict">
<code class="descname">new_from_dict</code><span class="sig-paren">(</span><em>dict_</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.GridWindMover.new_from_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>creates a new object from dictionary</p>
<p>This is base implementation and can be over-ridden by classes using
this mixin</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridWindMover.obj_type_to_dict">
<code class="descname">obj_type_to_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.GridWindMover.obj_type_to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>returns object type to save in dict.
This is base implementation and can be over-ridden</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridWindMover.prepare_data_for_get_move">
<code class="descname">prepare_data_for_get_move</code><span class="sig-paren">(</span><em>sc</em>, <em>model_time_datetime</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.GridWindMover.prepare_data_for_get_move" title="Permalink to this definition">¶</a></dt>
<dd><p>organizes the spill object into inputs for calling with Cython
wrapper&#8217;s get_move(...)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>sc</strong> &#8211; an instance of gnome.spill_container.SpillContainer class</li>
<li><strong>model_time_datetime</strong> &#8211; current model time as datetime object</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridWindMover.prepare_for_model_run">
<code class="descname">prepare_for_model_run</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.GridWindMover.prepare_for_model_run" title="Permalink to this definition">¶</a></dt>
<dd><p>Calls the contained cython mover&#8217;s prepare_for_model_run()</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridWindMover.prepare_for_model_step">
<code class="descname">prepare_for_model_step</code><span class="sig-paren">(</span><em>sc</em>, <em>time_step</em>, <em>model_time_datetime</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.GridWindMover.prepare_for_model_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Call base class method using super
Also updates windage for this timestep</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>sc</strong> &#8211; an instance of gnome.spill_container.SpillContainer class</li>
<li><strong>time_step</strong> &#8211; time step in seconds</li>
<li><strong>model_time_datetime</strong> &#8211; current time of model as a date time object</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridWindMover.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>saveloc</em>, <em>references=None</em>, <em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.GridWindMover.save" title="Permalink to this definition">¶</a></dt>
<dd><p>save object state as json to user specified saveloc</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>saveloc</strong> (<em>A path as a string or unicode</em>) &#8211; zip archive or a valid directory. Model files are
either persisted here or a new model is re-created from the files
stored here. The files are clobbered when save() is called.</li>
<li><strong>name=None</strong> &#8211; filename to store json. If None, default name is:
&#8220;{0}.json&#8221;.format(self.__class__.__name__). If saveloc is zipfile,
this is the name of archive in which json for self is stored.</li>
<li><strong>references</strong> &#8211; dict of references mapping &#8216;id&#8217; to a string used for
the reference. The value could be a unique integer or it could be
a filename. It is upto the creator of the reference list to decide
how to reference a nested object.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridWindMover.serialize">
<code class="descname">serialize</code><span class="sig-paren">(</span><em>json_='webapi'</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.GridWindMover.serialize" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the dict returned by object&#8217;s to_dict method to valid json
format via colander schema</p>
<p>It uses the modules_dict defined in gnome.persist to find the correct
schema module.</p>
<ol class="arabic">
<li><dl class="first docutils">
<dt>adds &#8216;obj_type&#8217; field to _state for &#8216;save&#8217; attribute so it is</dt>
<dd><p class="first last">contained in serialized data. todo: check if this is needed</p>
</dd>
</dl>
</li>
<li><p class="first">do serialization and return json</p>
</li>
</ol>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>do</strong> &#8211; tells object where serialization is for update or for
creating a new object</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">json format of serialized data</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Note: creating a new object versus &#8216;update&#8217; or &#8216;read&#8217; has a different</dt>
<dd>set of fields for serialization so &#8216;do&#8217; is required.
todo: revisit this to see if it still makes sense to have different
attributes for different operations like &#8216;update&#8217;, &#8216;save&#8217;, &#8216;read&#8217;</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridWindMover.serialize_oc">
<code class="descname">serialize_oc</code><span class="sig-paren">(</span><em>coll</em>, <em>json_='webapi'</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.GridWindMover.serialize_oc" title="Permalink to this definition">¶</a></dt>
<dd><p>Serialize Model attributes of type ordered collection or list - an
iterable containing serializable objects</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridWindMover.to_dict">
<code class="descname">to_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.GridWindMover.to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>returns a dictionary containing the serialized representation of this
object.</p>
<p>For every field, if there is a method defined on the object such that
the method name is <cite>{field_name}_to_dict</cite>, use the return value of that
method as the field value.</p>
<p>Note: any field in <cite>list</cite> that does not exist on the
object and does not have a to_dict method will raise an AttributeError.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>json_='webapi'</strong> &#8211; return the attributes for json payload for
webapi.
The other option is &#8216;save&#8217; corresponding with
json for save files.</td>
</tr>
</tbody>
</table>
<p>NOTE: add the json_=&#8217;webapi&#8217; key to be serialized so we know what the
serialization is for</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridWindMover.to_serialize">
<code class="descname">to_serialize</code><span class="sig-paren">(</span><em>json_='webapi'</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.GridWindMover.to_serialize" title="Permalink to this definition">¶</a></dt>
<dd><p>invoke to_dict() which converts all attributes defined in _state to
dict. If json_=&#8217;save&#8217;, it subselects the Fields with save=True. If
json_=&#8217;webapi&#8217;, it subselects Fields with (update=True, read=True)</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridWindMover.update_attr">
<code class="descname">update_attr</code><span class="sig-paren">(</span><em>name</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.GridWindMover.update_attr" title="Permalink to this definition">¶</a></dt>
<dd><p>update the attribute defined by &#8216;name&#8217; with given &#8216;value&#8217;</p>
<p>If there is a method defined on the object such that the method name is
<cite>{name}_from_dict</cite>, call that method with the field&#8217;s data.</p>
<p>If neither method exists, then set the field with the value from
<code class="docutils literal"><span class="pre">data</span></code> directly on the object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> (<em>str</em>) &#8211; name of attribute to be updated</li>
<li><strong>value</strong> (<em>depends on each attribute being updated</em>) &#8211; the new value of the attribute</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridWindMover.update_from_dict">
<code class="descname">update_from_dict</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.GridWindMover.update_from_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the attributes of this object using the dictionary <code class="docutils literal"><span class="pre">data</span></code> by
looking up the value of each key in <code class="docutils literal"><span class="pre">data</span></code>.
The fields in self._state that have update=True are modified. The
remaining keys in &#8216;data&#8217; are ignored. The object&#8217;s _state attribute
defines what fields can be updated</p>
<p>If an attribute has changed, then call &#8216;update_attr&#8217; to update its
value.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>data</strong> (<em>dict</em>) &#8211; dict containing state of object per the client</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">True if something changed, False otherwise</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">bool</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Does not do updates on nested objects. If the attribute references
another Serializable object, then the value is not a dict but
rather the updated object. For instance, WindMover will receive:</p>
<blockquote>
<div>{..., &#8216;wind&#8217;: &lt;Wind object&gt;}</div></blockquote>
<p class="last">as opposed to a nested dict of the &#8216;wind&#8217; object. It is expected
that the &#8216;wind&#8217; object was updated by calling its own
update_from_dict then added to this dict as the updated object.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridWindMover.validate">
<code class="descname">validate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.GridWindMover.validate" title="Permalink to this definition">¶</a></dt>
<dd><p>All pygnome objects should be able to validate themselves. Many
py_gnome objects reference other objects like wind, water, waves. These
may not be defined when object is created so they can be None at
construction time; however, they should reference valid objects
when running model. If make_default_refs is True, then object isvalid
because model will set these up at runtime. To raise exception
for missing references at runtime, directly call
validate_refs(level=&#8217;error&#8217;)</p>
<p>&#8216;wind&#8217;, &#8216;water&#8217;, &#8216;waves&#8217; attributes also have special meaning. An
object containing this attribute references the corresponding object.</p>
<p>Logs warnings
:returns: a tuple of length two containing:</p>
<blockquote>
<div>(a list of messages that were logged, isvalid bool)
If any references are missing and make_default_refs is False,
object is not valid</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridWindMover.validate_refs">
<code class="descname">validate_refs</code><span class="sig-paren">(</span><em>refs=['wind', 'water', 'waves']</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.GridWindMover.validate_refs" title="Permalink to this definition">¶</a></dt>
<dd><p>level is the logging level to use for messages. Default is &#8216;warning&#8217;
but if called from prepare_for_model_run, we want to use error and
raise exception.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridWindMover.export_topology">
<code class="descname">export_topology</code><span class="sig-paren">(</span><em>topology_file</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/movers/wind_movers.html#GridWindMover.export_topology"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.movers.GridWindMover.export_topology" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>topology_file=None</strong> &#8211; absolute or relative path where topology
file will be written.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridWindMover.extrapolate_in_time">
<code class="descname">extrapolate_in_time</code><span class="sig-paren">(</span><em>extrapolate</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/movers/wind_movers.html#GridWindMover.extrapolate_in_time"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.movers.GridWindMover.extrapolate_in_time" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>extrapolate=false</strong> &#8211; Allow current data to be extrapolated before
and after file data.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridWindMover.offset_time">
<code class="descname">offset_time</code><span class="sig-paren">(</span><em>time_offset</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/movers/wind_movers.html#GridWindMover.offset_time"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.movers.GridWindMover.offset_time" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>offset_time=0</strong> &#8211; Allow data to be in GMT with a time zone offset
(hours).</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-gnome.weatherers">
<span id="gnome-weatherers-pygnome-adios-weathering-mass-removal-classes"></span><h2><code class="docutils literal"><span class="pre">gnome.weatherers</span></code> &#8211; PyGnome/Adios weathering/mass removal classes<a class="headerlink" href="#module-gnome.weatherers" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="gnome.weatherers.Weatherer">
<em class="property">class </em><code class="descclassname">gnome.weatherers.</code><code class="descname">Weatherer</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/weatherers/core.html#Weatherer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.weatherers.Weatherer" title="Permalink to this definition">¶</a></dt>
<dd><p>Base Weathering agent.  This is almost exactly like the base Mover
in the way that it acts upon the model.  It contains the same API
as the mover as well. Not Serializable since it does is partial
implementation</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>weathering</strong> &#8211; object that represents the weathering</td>
</tr>
</tbody>
</table>
<p>properties of the substance that our
LEs are made up of.</p>
<dl class="method">
<dt id="gnome.weatherers.Weatherer.prepare_for_model_run">
<code class="descname">prepare_for_model_run</code><span class="sig-paren">(</span><em>sc</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/weatherers/core.html#Weatherer.prepare_for_model_run"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.weatherers.Weatherer.prepare_for_model_run" title="Permalink to this definition">¶</a></dt>
<dd><p>Override for weatherers so they can initialize correct &#8216;mass_balance&#8217;
key and set initial value to 0.0</p>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.Weatherer.weather_elements">
<code class="descname">weather_elements</code><span class="sig-paren">(</span><em>sc</em>, <em>time_step</em>, <em>model_time</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/weatherers/core.html#Weatherer.weather_elements"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.weatherers.Weatherer.weather_elements" title="Permalink to this definition">¶</a></dt>
<dd><p>run the equivalent of get_move for weathering processes. It weathers
each component and returns the mass remaining at end of time_step. It
returns the mass in units of &#8216;kg&#8217;</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="gnome.weatherers.Evaporation">
<em class="property">class </em><code class="descclassname">gnome.weatherers.</code><code class="descname">Evaporation</code><span class="sig-paren">(</span><em>water=None</em>, <em>wind=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/weatherers/evaporation.html#Evaporation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.weatherers.Evaporation" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>conditions</strong> &#8211; gnome.environment.Conditions object which contains
things like water temperature</li>
<li><strong>wind</strong> (<em>Wind API, specifically must have get_value(time) method</em>) &#8211; wind object for obtaining speed at specified time</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="gnome.weatherers.Evaporation.prepare_for_model_run">
<code class="descname">prepare_for_model_run</code><span class="sig-paren">(</span><em>sc</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/weatherers/evaporation.html#Evaporation.prepare_for_model_run"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.weatherers.Evaporation.prepare_for_model_run" title="Permalink to this definition">¶</a></dt>
<dd><p>add evaporated key to weathering_data
for now also add &#8216;density&#8217; key here
Assumes all spills have the same type of oil</p>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.Evaporation.weather_elements">
<code class="descname">weather_elements</code><span class="sig-paren">(</span><em>sc</em>, <em>time_step</em>, <em>model_time</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/weatherers/evaporation.html#Evaporation.weather_elements"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.weatherers.Evaporation.weather_elements" title="Permalink to this definition">¶</a></dt>
<dd><p>weather elements over time_step
- sets &#8216;evaporation&#8217; in sc.weathering_data
- currently also sets &#8216;density&#8217; in sc.weathering_data but may update</p>
<blockquote>
<div>this as we add more weatherers and perhaps density gets set elsewhere</div></blockquote>
<p>Following diff eq models rate of change each pseudocomponent of oil:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">dm</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">/</span><span class="n">dt</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">fw</span><span class="p">)</span> <span class="o">*</span> <span class="n">A</span><span class="o">/</span><span class="n">B</span> <span class="o">*</span> <span class="n">m</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
<p>Over a time-step, A, B, C are assumed constant. m(t) is the component
mass at beginning of timestep; m(t + Dt) is mass at end of timestep:</p>
<div class="highlight-python"><div class="highlight"><pre>m(t + Dt) = m(t) * exp(-L * Dt)
L := (1 - fw) * A/B
</pre></div>
</div>
<p>Define properties for each pseudocomponent of oil and constants:</p>
<div class="highlight-python"><div class="highlight"><pre>vp: vapor pressure
mw: molecular weight
</pre></div>
</div>
<p>The following quantities are defined for a given blob of oil. The
thickness of the blob is same for all LEs regardless of how many LEs
are used to model the blob:</p>
<div class="highlight-python"><div class="highlight"><pre>area: area computed from fay spreading
m_i:
sum_m_mw: sum(m_i/mw_i) over all components
</pre></div>
</div>
<p>effect of wind - mass transport coefficient:</p>
<div class="highlight-python"><div class="highlight"><pre>K: See _mass_transport_coeff()
</pre></div>
</div>
<p>Finally, Evaporation of component &#8216;i&#8217; for blob of oil:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">A</span> <span class="o">=</span> <span class="n">area</span> <span class="o">*</span> <span class="n">K</span> <span class="o">*</span> <span class="n">vp</span>
<span class="n">B</span> <span class="o">=</span> <span class="n">gas_constant</span> <span class="o">*</span> <span class="n">water_temp</span> <span class="o">*</span> <span class="n">sum_m_mw</span>
</pre></div>
</div>
<p>L becomes:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">L</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">fw</span><span class="p">)</span> <span class="o">*</span> <span class="n">area</span> <span class="o">*</span> <span class="n">K</span> <span class="o">*</span> <span class="n">vp</span><span class="o">/</span><span class="p">(</span><span class="n">gas_constant</span> <span class="o">*</span> <span class="n">water_temp</span> <span class="o">*</span> <span class="n">sum_m_mw</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.Evaporation.serialize">
<code class="descname">serialize</code><span class="sig-paren">(</span><em>json_='webapi'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/weatherers/evaporation.html#Evaporation.serialize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.weatherers.Evaporation.serialize" title="Permalink to this definition">¶</a></dt>
<dd><p>Since &#8216;wind&#8217;/&#8217;water&#8217; property is saved as references in save file
need to add appropriate node to WindMover schema for &#8216;webapi&#8217;</p>
</dd></dl>

<dl class="classmethod">
<dt id="gnome.weatherers.Evaporation.deserialize">
<em class="property">classmethod </em><code class="descname">deserialize</code><span class="sig-paren">(</span><em>json_</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/weatherers/evaporation.html#Evaporation.deserialize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.weatherers.Evaporation.deserialize" title="Permalink to this definition">¶</a></dt>
<dd><p>append correct schema for wind object</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="gnome.weatherers.Emulsification">
<em class="property">class </em><code class="descclassname">gnome.weatherers.</code><code class="descname">Emulsification</code><span class="sig-paren">(</span><em>waves=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/weatherers/emulsification.html#Emulsification"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.weatherers.Emulsification" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>conditions</strong> &#8211; gnome.environment.Conditions object which contains
things like water temperature</li>
<li><strong>waves</strong> (<em>get_emulsification_wind(model_time)</em>) &#8211; waves object for obtaining emulsification wind speed at specified time</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="gnome.weatherers.Emulsification.prepare_for_model_run">
<code class="descname">prepare_for_model_run</code><span class="sig-paren">(</span><em>sc</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/weatherers/emulsification.html#Emulsification.prepare_for_model_run"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.weatherers.Emulsification.prepare_for_model_run" title="Permalink to this definition">¶</a></dt>
<dd><p>add water_content key to weathering_data
Assumes all spills have the same type of oil</p>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.Emulsification.prepare_for_model_step">
<code class="descname">prepare_for_model_step</code><span class="sig-paren">(</span><em>sc</em>, <em>time_step</em>, <em>model_time</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/weatherers/emulsification.html#Emulsification.prepare_for_model_step"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.weatherers.Emulsification.prepare_for_model_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Set/update arrays used by emulsification module for this timestep:</p>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.Emulsification.weather_elements">
<code class="descname">weather_elements</code><span class="sig-paren">(</span><em>sc</em>, <em>time_step</em>, <em>model_time</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/weatherers/emulsification.html#Emulsification.weather_elements"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.weatherers.Emulsification.weather_elements" title="Permalink to this definition">¶</a></dt>
<dd><p>weather elements over time_step
- sets &#8216;water_content&#8217; in sc.weathering_data</p>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.Emulsification.serialize">
<code class="descname">serialize</code><span class="sig-paren">(</span><em>json_='webapi'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/weatherers/emulsification.html#Emulsification.serialize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.weatherers.Emulsification.serialize" title="Permalink to this definition">¶</a></dt>
<dd><p>Since &#8216;wind&#8217;/&#8217;waves&#8217; property is saved as references in save file
need to add appropriate node to WindMover schema for &#8216;webapi&#8217;</p>
</dd></dl>

<dl class="classmethod">
<dt id="gnome.weatherers.Emulsification.deserialize">
<em class="property">classmethod </em><code class="descname">deserialize</code><span class="sig-paren">(</span><em>json_</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/weatherers/emulsification.html#Emulsification.deserialize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.weatherers.Emulsification.deserialize" title="Permalink to this definition">¶</a></dt>
<dd><p>append correct schema for waves object</p>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.Emulsification.attr_to_dict">
<code class="descname">attr_to_dict</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.weatherers.Emulsification.attr_to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>refactor to_dict&#8217;s functionality so child classes can convert a
single attribute to_dict instead of doing a whole list of fields</p>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.Emulsification.datetime_to_seconds">
<code class="descname">datetime_to_seconds</code><span class="sig-paren">(</span><em>model_time</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.weatherers.Emulsification.datetime_to_seconds" title="Permalink to this definition">¶</a></dt>
<dd><p>Put the time conversion call here - in case we decide to change it, it
only updates here</p>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.Emulsification.deserialize_oc">
<code class="descname">deserialize_oc</code><span class="sig-paren">(</span><em>json_</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.weatherers.Emulsification.deserialize_oc" title="Permalink to this definition">¶</a></dt>
<dd><p>check contents of orderered collections to figure out what schema to
use.
Basically, the json serialized ordered collection looks like a regular
list.</p>
</dd></dl>

<dl class="attribute">
<dt id="gnome.weatherers.Emulsification.id">
<code class="descname">id</code><a class="headerlink" href="#gnome.weatherers.Emulsification.id" title="Permalink to this definition">¶</a></dt>
<dd><p>Override this method for more exotic forms of identification.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a unique ID assigned during construction</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.Emulsification.is_sparse">
<code class="descname">is_sparse</code><span class="sig-paren">(</span><em>json_</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.weatherers.Emulsification.is_sparse" title="Permalink to this definition">¶</a></dt>
<dd><p>Sparse means that we have a previously created object,
and we are receiving a reference to the object using just
an obj_type and an id.  This is a valid payload that the
Web Client will send.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.Emulsification.loads">
<code class="descname">loads</code><span class="sig-paren">(</span><em>json_data</em>, <em>saveloc=None</em>, <em>references=None</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.weatherers.Emulsification.loads" title="Permalink to this definition">¶</a></dt>
<dd><p>loads object from json_data</p>
<ul class="simple">
<li>load json for references from files</li>
<li>update paths of datafiles if needed</li>
<li>deserialize json_data</li>
<li>and create object with new_from_dict()</li>
</ul>
<dl class="docutils">
<dt>json_data: dict containing json data. It has been parsed through the</dt>
<dd>json.loads() command. The json will be valided here when it gets
deserialized. Its references and datafile paths will be recreated
here prior to calling new_from_dict()</dd>
</dl>
<p>Optional parameter</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>saveloc</strong> &#8211; location of data files or <a href="#id33"><span class="problematic" id="id34">*</span></a>.json files for objects
stored as references. If object requires no datafiles and does not
need to read references from a <a href="#id35"><span class="problematic" id="id36">*</span></a>.json file in saveloc, then this
can be None.</li>
<li><strong>references</strong> &#8211; references object - if this is called by the Model,
it will pass a references object. It is not required.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">object constructed from json_data.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="gnome.weatherers.Emulsification.logger">
<code class="descname">logger</code><a class="headerlink" href="#gnome.weatherers.Emulsification.logger" title="Permalink to this definition">¶</a></dt>
<dd><p>define attribute &#8216;_log&#8217;. If it doesn&#8217;t exist, define it here.
This is so we don&#8217;t have to add it to all PyGnome classes - this
property makes the logger available to each object.
- default log_level is INFO</p>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.Emulsification.model_step_is_done">
<code class="descname">model_step_is_done</code><span class="sig-paren">(</span><em>sc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.weatherers.Emulsification.model_step_is_done" title="Permalink to this definition">¶</a></dt>
<dd><p>This method gets called by the model when after everything else is done
in a time step. Put any code need for clean-up, etc in here in
subclassed movers.</p>
</dd></dl>

<dl class="attribute">
<dt id="gnome.weatherers.Emulsification.name">
<code class="descname">name</code><a class="headerlink" href="#gnome.weatherers.Emulsification.name" title="Permalink to this definition">¶</a></dt>
<dd><p>define as property in base class so all objects will have a name
by default</p>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.Emulsification.new_from_dict">
<code class="descname">new_from_dict</code><span class="sig-paren">(</span><em>dict_</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.weatherers.Emulsification.new_from_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>creates a new object from dictionary</p>
<p>This is base implementation and can be over-ridden by classes using
this mixin</p>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.Emulsification.obj_type_to_dict">
<code class="descname">obj_type_to_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gnome.weatherers.Emulsification.obj_type_to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>returns object type to save in dict.
This is base implementation and can be over-ridden</p>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.Emulsification.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>saveloc</em>, <em>references=None</em>, <em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.weatherers.Emulsification.save" title="Permalink to this definition">¶</a></dt>
<dd><p>save object state as json to user specified saveloc</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>saveloc</strong> (<em>A path as a string or unicode</em>) &#8211; zip archive or a valid directory. Model files are
either persisted here or a new model is re-created from the files
stored here. The files are clobbered when save() is called.</li>
<li><strong>name=None</strong> &#8211; filename to store json. If None, default name is:
&#8220;{0}.json&#8221;.format(self.__class__.__name__). If saveloc is zipfile,
this is the name of archive in which json for self is stored.</li>
<li><strong>references</strong> &#8211; dict of references mapping &#8216;id&#8217; to a string used for
the reference. The value could be a unique integer or it could be
a filename. It is upto the creator of the reference list to decide
how to reference a nested object.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.Emulsification.serialize_oc">
<code class="descname">serialize_oc</code><span class="sig-paren">(</span><em>coll</em>, <em>json_='webapi'</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.weatherers.Emulsification.serialize_oc" title="Permalink to this definition">¶</a></dt>
<dd><p>Serialize Model attributes of type ordered collection or list - an
iterable containing serializable objects</p>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.Emulsification.to_dict">
<code class="descname">to_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gnome.weatherers.Emulsification.to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>returns a dictionary containing the serialized representation of this
object.</p>
<p>For every field, if there is a method defined on the object such that
the method name is <cite>{field_name}_to_dict</cite>, use the return value of that
method as the field value.</p>
<p>Note: any field in <cite>list</cite> that does not exist on the
object and does not have a to_dict method will raise an AttributeError.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>json_='webapi'</strong> &#8211; return the attributes for json payload for
webapi.
The other option is &#8216;save&#8217; corresponding with
json for save files.</td>
</tr>
</tbody>
</table>
<p>NOTE: add the json_=&#8217;webapi&#8217; key to be serialized so we know what the
serialization is for</p>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.Emulsification.to_serialize">
<code class="descname">to_serialize</code><span class="sig-paren">(</span><em>json_='webapi'</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.weatherers.Emulsification.to_serialize" title="Permalink to this definition">¶</a></dt>
<dd><p>invoke to_dict() which converts all attributes defined in _state to
dict. If json_=&#8217;save&#8217;, it subselects the Fields with save=True. If
json_=&#8217;webapi&#8217;, it subselects Fields with (update=True, read=True)</p>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.Emulsification.update_attr">
<code class="descname">update_attr</code><span class="sig-paren">(</span><em>name</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.weatherers.Emulsification.update_attr" title="Permalink to this definition">¶</a></dt>
<dd><p>update the attribute defined by &#8216;name&#8217; with given &#8216;value&#8217;</p>
<p>If there is a method defined on the object such that the method name is
<cite>{name}_from_dict</cite>, call that method with the field&#8217;s data.</p>
<p>If neither method exists, then set the field with the value from
<code class="docutils literal"><span class="pre">data</span></code> directly on the object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> (<em>str</em>) &#8211; name of attribute to be updated</li>
<li><strong>value</strong> (<em>depends on each attribute being updated</em>) &#8211; the new value of the attribute</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.Emulsification.update_from_dict">
<code class="descname">update_from_dict</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.weatherers.Emulsification.update_from_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the attributes of this object using the dictionary <code class="docutils literal"><span class="pre">data</span></code> by
looking up the value of each key in <code class="docutils literal"><span class="pre">data</span></code>.
The fields in self._state that have update=True are modified. The
remaining keys in &#8216;data&#8217; are ignored. The object&#8217;s _state attribute
defines what fields can be updated</p>
<p>If an attribute has changed, then call &#8216;update_attr&#8217; to update its
value.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>data</strong> (<em>dict</em>) &#8211; dict containing state of object per the client</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">True if something changed, False otherwise</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">bool</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Does not do updates on nested objects. If the attribute references
another Serializable object, then the value is not a dict but
rather the updated object. For instance, WindMover will receive:</p>
<blockquote>
<div>{..., &#8216;wind&#8217;: &lt;Wind object&gt;}</div></blockquote>
<p class="last">as opposed to a nested dict of the &#8216;wind&#8217; object. It is expected
that the &#8216;wind&#8217; object was updated by calling its own
update_from_dict then added to this dict as the updated object.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.Emulsification.validate">
<code class="descname">validate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gnome.weatherers.Emulsification.validate" title="Permalink to this definition">¶</a></dt>
<dd><p>All pygnome objects should be able to validate themselves. Many
py_gnome objects reference other objects like wind, water, waves. These
may not be defined when object is created so they can be None at
construction time; however, they should reference valid objects
when running model. If make_default_refs is True, then object isvalid
because model will set these up at runtime. To raise exception
for missing references at runtime, directly call
validate_refs(level=&#8217;error&#8217;)</p>
<p>&#8216;wind&#8217;, &#8216;water&#8217;, &#8216;waves&#8217; attributes also have special meaning. An
object containing this attribute references the corresponding object.</p>
<p>Logs warnings
:returns: a tuple of length two containing:</p>
<blockquote>
<div>(a list of messages that were logged, isvalid bool)
If any references are missing and make_default_refs is False,
object is not valid</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.Emulsification.validate_refs">
<code class="descname">validate_refs</code><span class="sig-paren">(</span><em>refs=['wind', 'water', 'waves']</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.weatherers.Emulsification.validate_refs" title="Permalink to this definition">¶</a></dt>
<dd><p>level is the logging level to use for messages. Default is &#8216;warning&#8217;
but if called from prepare_for_model_run, we want to use error and
raise exception.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="gnome.weatherers.NaturalDispersion">
<em class="property">class </em><code class="descclassname">gnome.weatherers.</code><code class="descname">NaturalDispersion</code><span class="sig-paren">(</span><em>waves=None</em>, <em>water=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/weatherers/natural_dispersion.html#NaturalDispersion"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.weatherers.NaturalDispersion" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>conditions</strong> &#8211; gnome.environment.Conditions object which contains
things like water temperature</li>
<li><strong>waves</strong> &#8211; waves object for obtaining wave_height, etc at given time</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="gnome.weatherers.NaturalDispersion.prepare_for_model_run">
<code class="descname">prepare_for_model_run</code><span class="sig-paren">(</span><em>sc</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/weatherers/natural_dispersion.html#NaturalDispersion.prepare_for_model_run"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.weatherers.NaturalDispersion.prepare_for_model_run" title="Permalink to this definition">¶</a></dt>
<dd><p>add dispersion and sedimentation keys to weathering_data
Assumes all spills have the same type of oil</p>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.NaturalDispersion.prepare_for_model_step">
<code class="descname">prepare_for_model_step</code><span class="sig-paren">(</span><em>sc</em>, <em>time_step</em>, <em>model_time</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/weatherers/natural_dispersion.html#NaturalDispersion.prepare_for_model_step"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.weatherers.NaturalDispersion.prepare_for_model_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Set/update arrays used by dispersion module for this timestep:</p>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.NaturalDispersion.weather_elements">
<code class="descname">weather_elements</code><span class="sig-paren">(</span><em>sc</em>, <em>time_step</em>, <em>model_time</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/weatherers/natural_dispersion.html#NaturalDispersion.weather_elements"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.weatherers.NaturalDispersion.weather_elements" title="Permalink to this definition">¶</a></dt>
<dd><p>weather elements over time_step
- sets &#8216;natural_dispersion&#8217; and &#8216;sedimentation&#8217; in sc.weathering_data</p>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.NaturalDispersion.serialize">
<code class="descname">serialize</code><span class="sig-paren">(</span><em>json_='webapi'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/weatherers/natural_dispersion.html#NaturalDispersion.serialize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.weatherers.NaturalDispersion.serialize" title="Permalink to this definition">¶</a></dt>
<dd><p>&#8216;water&#8217;/&#8217;waves&#8217; property is saved as references in save file</p>
</dd></dl>

<dl class="classmethod">
<dt id="gnome.weatherers.NaturalDispersion.deserialize">
<em class="property">classmethod </em><code class="descname">deserialize</code><span class="sig-paren">(</span><em>json_</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/weatherers/natural_dispersion.html#NaturalDispersion.deserialize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.weatherers.NaturalDispersion.deserialize" title="Permalink to this definition">¶</a></dt>
<dd><p>append correct schema for water / waves</p>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.NaturalDispersion.attr_to_dict">
<code class="descname">attr_to_dict</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.weatherers.NaturalDispersion.attr_to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>refactor to_dict&#8217;s functionality so child classes can convert a
single attribute to_dict instead of doing a whole list of fields</p>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.NaturalDispersion.datetime_to_seconds">
<code class="descname">datetime_to_seconds</code><span class="sig-paren">(</span><em>model_time</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.weatherers.NaturalDispersion.datetime_to_seconds" title="Permalink to this definition">¶</a></dt>
<dd><p>Put the time conversion call here - in case we decide to change it, it
only updates here</p>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.NaturalDispersion.deserialize_oc">
<code class="descname">deserialize_oc</code><span class="sig-paren">(</span><em>json_</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.weatherers.NaturalDispersion.deserialize_oc" title="Permalink to this definition">¶</a></dt>
<dd><p>check contents of orderered collections to figure out what schema to
use.
Basically, the json serialized ordered collection looks like a regular
list.</p>
</dd></dl>

<dl class="attribute">
<dt id="gnome.weatherers.NaturalDispersion.id">
<code class="descname">id</code><a class="headerlink" href="#gnome.weatherers.NaturalDispersion.id" title="Permalink to this definition">¶</a></dt>
<dd><p>Override this method for more exotic forms of identification.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a unique ID assigned during construction</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.NaturalDispersion.is_sparse">
<code class="descname">is_sparse</code><span class="sig-paren">(</span><em>json_</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.weatherers.NaturalDispersion.is_sparse" title="Permalink to this definition">¶</a></dt>
<dd><p>Sparse means that we have a previously created object,
and we are receiving a reference to the object using just
an obj_type and an id.  This is a valid payload that the
Web Client will send.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.NaturalDispersion.loads">
<code class="descname">loads</code><span class="sig-paren">(</span><em>json_data</em>, <em>saveloc=None</em>, <em>references=None</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.weatherers.NaturalDispersion.loads" title="Permalink to this definition">¶</a></dt>
<dd><p>loads object from json_data</p>
<ul class="simple">
<li>load json for references from files</li>
<li>update paths of datafiles if needed</li>
<li>deserialize json_data</li>
<li>and create object with new_from_dict()</li>
</ul>
<dl class="docutils">
<dt>json_data: dict containing json data. It has been parsed through the</dt>
<dd>json.loads() command. The json will be valided here when it gets
deserialized. Its references and datafile paths will be recreated
here prior to calling new_from_dict()</dd>
</dl>
<p>Optional parameter</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>saveloc</strong> &#8211; location of data files or <a href="#id37"><span class="problematic" id="id38">*</span></a>.json files for objects
stored as references. If object requires no datafiles and does not
need to read references from a <a href="#id39"><span class="problematic" id="id40">*</span></a>.json file in saveloc, then this
can be None.</li>
<li><strong>references</strong> &#8211; references object - if this is called by the Model,
it will pass a references object. It is not required.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">object constructed from json_data.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="gnome.weatherers.NaturalDispersion.logger">
<code class="descname">logger</code><a class="headerlink" href="#gnome.weatherers.NaturalDispersion.logger" title="Permalink to this definition">¶</a></dt>
<dd><p>define attribute &#8216;_log&#8217;. If it doesn&#8217;t exist, define it here.
This is so we don&#8217;t have to add it to all PyGnome classes - this
property makes the logger available to each object.
- default log_level is INFO</p>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.NaturalDispersion.model_step_is_done">
<code class="descname">model_step_is_done</code><span class="sig-paren">(</span><em>sc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.weatherers.NaturalDispersion.model_step_is_done" title="Permalink to this definition">¶</a></dt>
<dd><p>This method gets called by the model when after everything else is done
in a time step. Put any code need for clean-up, etc in here in
subclassed movers.</p>
</dd></dl>

<dl class="attribute">
<dt id="gnome.weatherers.NaturalDispersion.name">
<code class="descname">name</code><a class="headerlink" href="#gnome.weatherers.NaturalDispersion.name" title="Permalink to this definition">¶</a></dt>
<dd><p>define as property in base class so all objects will have a name
by default</p>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.NaturalDispersion.new_from_dict">
<code class="descname">new_from_dict</code><span class="sig-paren">(</span><em>dict_</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.weatherers.NaturalDispersion.new_from_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>creates a new object from dictionary</p>
<p>This is base implementation and can be over-ridden by classes using
this mixin</p>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.NaturalDispersion.obj_type_to_dict">
<code class="descname">obj_type_to_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gnome.weatherers.NaturalDispersion.obj_type_to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>returns object type to save in dict.
This is base implementation and can be over-ridden</p>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.NaturalDispersion.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>saveloc</em>, <em>references=None</em>, <em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.weatherers.NaturalDispersion.save" title="Permalink to this definition">¶</a></dt>
<dd><p>save object state as json to user specified saveloc</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>saveloc</strong> (<em>A path as a string or unicode</em>) &#8211; zip archive or a valid directory. Model files are
either persisted here or a new model is re-created from the files
stored here. The files are clobbered when save() is called.</li>
<li><strong>name=None</strong> &#8211; filename to store json. If None, default name is:
&#8220;{0}.json&#8221;.format(self.__class__.__name__). If saveloc is zipfile,
this is the name of archive in which json for self is stored.</li>
<li><strong>references</strong> &#8211; dict of references mapping &#8216;id&#8217; to a string used for
the reference. The value could be a unique integer or it could be
a filename. It is upto the creator of the reference list to decide
how to reference a nested object.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.NaturalDispersion.serialize_oc">
<code class="descname">serialize_oc</code><span class="sig-paren">(</span><em>coll</em>, <em>json_='webapi'</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.weatherers.NaturalDispersion.serialize_oc" title="Permalink to this definition">¶</a></dt>
<dd><p>Serialize Model attributes of type ordered collection or list - an
iterable containing serializable objects</p>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.NaturalDispersion.to_dict">
<code class="descname">to_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gnome.weatherers.NaturalDispersion.to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>returns a dictionary containing the serialized representation of this
object.</p>
<p>For every field, if there is a method defined on the object such that
the method name is <cite>{field_name}_to_dict</cite>, use the return value of that
method as the field value.</p>
<p>Note: any field in <cite>list</cite> that does not exist on the
object and does not have a to_dict method will raise an AttributeError.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>json_='webapi'</strong> &#8211; return the attributes for json payload for
webapi.
The other option is &#8216;save&#8217; corresponding with
json for save files.</td>
</tr>
</tbody>
</table>
<p>NOTE: add the json_=&#8217;webapi&#8217; key to be serialized so we know what the
serialization is for</p>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.NaturalDispersion.to_serialize">
<code class="descname">to_serialize</code><span class="sig-paren">(</span><em>json_='webapi'</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.weatherers.NaturalDispersion.to_serialize" title="Permalink to this definition">¶</a></dt>
<dd><p>invoke to_dict() which converts all attributes defined in _state to
dict. If json_=&#8217;save&#8217;, it subselects the Fields with save=True. If
json_=&#8217;webapi&#8217;, it subselects Fields with (update=True, read=True)</p>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.NaturalDispersion.update_attr">
<code class="descname">update_attr</code><span class="sig-paren">(</span><em>name</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.weatherers.NaturalDispersion.update_attr" title="Permalink to this definition">¶</a></dt>
<dd><p>update the attribute defined by &#8216;name&#8217; with given &#8216;value&#8217;</p>
<p>If there is a method defined on the object such that the method name is
<cite>{name}_from_dict</cite>, call that method with the field&#8217;s data.</p>
<p>If neither method exists, then set the field with the value from
<code class="docutils literal"><span class="pre">data</span></code> directly on the object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> (<em>str</em>) &#8211; name of attribute to be updated</li>
<li><strong>value</strong> (<em>depends on each attribute being updated</em>) &#8211; the new value of the attribute</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.NaturalDispersion.update_from_dict">
<code class="descname">update_from_dict</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.weatherers.NaturalDispersion.update_from_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the attributes of this object using the dictionary <code class="docutils literal"><span class="pre">data</span></code> by
looking up the value of each key in <code class="docutils literal"><span class="pre">data</span></code>.
The fields in self._state that have update=True are modified. The
remaining keys in &#8216;data&#8217; are ignored. The object&#8217;s _state attribute
defines what fields can be updated</p>
<p>If an attribute has changed, then call &#8216;update_attr&#8217; to update its
value.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>data</strong> (<em>dict</em>) &#8211; dict containing state of object per the client</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">True if something changed, False otherwise</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">bool</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Does not do updates on nested objects. If the attribute references
another Serializable object, then the value is not a dict but
rather the updated object. For instance, WindMover will receive:</p>
<blockquote>
<div>{..., &#8216;wind&#8217;: &lt;Wind object&gt;}</div></blockquote>
<p class="last">as opposed to a nested dict of the &#8216;wind&#8217; object. It is expected
that the &#8216;wind&#8217; object was updated by calling its own
update_from_dict then added to this dict as the updated object.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.NaturalDispersion.validate">
<code class="descname">validate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gnome.weatherers.NaturalDispersion.validate" title="Permalink to this definition">¶</a></dt>
<dd><p>All pygnome objects should be able to validate themselves. Many
py_gnome objects reference other objects like wind, water, waves. These
may not be defined when object is created so they can be None at
construction time; however, they should reference valid objects
when running model. If make_default_refs is True, then object isvalid
because model will set these up at runtime. To raise exception
for missing references at runtime, directly call
validate_refs(level=&#8217;error&#8217;)</p>
<p>&#8216;wind&#8217;, &#8216;water&#8217;, &#8216;waves&#8217; attributes also have special meaning. An
object containing this attribute references the corresponding object.</p>
<p>Logs warnings
:returns: a tuple of length two containing:</p>
<blockquote>
<div>(a list of messages that were logged, isvalid bool)
If any references are missing and make_default_refs is False,
object is not valid</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.NaturalDispersion.validate_refs">
<code class="descname">validate_refs</code><span class="sig-paren">(</span><em>refs=['wind', 'water', 'waves']</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.weatherers.NaturalDispersion.validate_refs" title="Permalink to this definition">¶</a></dt>
<dd><p>level is the logging level to use for messages. Default is &#8216;warning&#8217;
but if called from prepare_for_model_run, we want to use error and
raise exception.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="gnome.weatherers.Skimmer">
<em class="property">class </em><code class="descclassname">gnome.weatherers.</code><code class="descname">Skimmer</code><span class="sig-paren">(</span><em>amount</em>, <em>units</em>, <em>efficiency</em>, <em>active_start</em>, <em>active_stop</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/weatherers/cleanup.html#Skimmer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.weatherers.Skimmer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">gnome.weatherers.cleanup.CleanUpBase</span></code>, <a class="reference internal" href="#gnome.utilities.serializable.Serializable" title="gnome.utilities.serializable.Serializable"><code class="xref py py-class docutils literal"><span class="pre">gnome.utilities.serializable.Serializable</span></code></a></p>
<p>initialize Skimmer object - calls base class __init__ using super()
active_start and active_stop time are required
cleanup operations must have a valid datetime - cannot use -inf and inf
active_start/active_stop is used to get the mass removal rate</p>
<dl class="attribute">
<dt id="gnome.weatherers.Skimmer.units">
<code class="descname">units</code><a class="headerlink" href="#gnome.weatherers.Skimmer.units" title="Permalink to this definition">¶</a></dt>
<dd><p>return units for amount skimmed</p>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.Skimmer.prepare_for_model_run">
<code class="descname">prepare_for_model_run</code><span class="sig-paren">(</span><em>sc</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/weatherers/cleanup.html#Skimmer.prepare_for_model_run"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.weatherers.Skimmer.prepare_for_model_run" title="Permalink to this definition">¶</a></dt>
<dd><p>no need to call base class since no new array_types were added</p>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.Skimmer.prepare_for_model_step">
<code class="descname">prepare_for_model_step</code><span class="sig-paren">(</span><em>sc</em>, <em>time_step</em>, <em>model_time</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/weatherers/cleanup.html#Skimmer.prepare_for_model_step"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.weatherers.Skimmer.prepare_for_model_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Do sub timestep resolution here so numbers add up correctly
Mark LEs to be skimmed - do them in order right now. Assume all LEs
that are released together will be skimmed together since they would
be closer to each other in position.</p>
<p>Assumes: there is more mass in water than amount of mass to be
skimmed. The LEs marked for Skimming are marked only once -
code checks to see if any LEs are marked for skimming and if
none are found, it marks them.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.Skimmer.weather_elements">
<code class="descname">weather_elements</code><span class="sig-paren">(</span><em>sc</em>, <em>time_step</em>, <em>model_time</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/weatherers/cleanup.html#Skimmer.weather_elements"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.weatherers.Skimmer.weather_elements" title="Permalink to this definition">¶</a></dt>
<dd><p>Assumes there is only ever 1 substance being modeled!
remove mass equally from LEs marked to be skimmed</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="gnome.weatherers.Burn">
<em class="property">class </em><code class="descclassname">gnome.weatherers.</code><code class="descname">Burn</code><span class="sig-paren">(</span><em>area</em>, <em>thickness</em>, <em>active_start</em>, <em>area_units='m^2'</em>, <em>thickness_units='m'</em>, <em>efficiency=1.0</em>, <em>wind=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/weatherers/cleanup.html#Burn"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.weatherers.Burn" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the area of boomed oil to be burned.
Cleanup operations must have a valid datetime for active_start,
cannot use -inf. Cannot set active_stop - burn automatically stops
when oil/water thickness reaches 2mm.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>area</strong> (<em>float</em>) &#8211; area of boomed oil/water mixture to burn</li>
<li><strong>thickness</strong> (<em>float</em>) &#8211; thickness of boomed oil/water mixture</li>
<li><strong>active_start</strong> (<em>datetime</em>) &#8211; time when the burn starts</li>
<li><strong>area_units</strong> (<em>str</em>) &#8211; default is &#8216;m^2&#8217;</li>
<li><strong>thickness_units</strong> (<em>str</em>) &#8211; default is &#8216;m&#8217;</li>
<li><strong>efficiency</strong> (<em>float</em>) &#8211; burn efficiency, must be greater than 0 and
less than or equal to 1.0</li>
<li><strong>wind</strong> &#8211; <p>gnome.environment.Wind object. Only used to set
efficiency if efficiency is None. Efficiency is defined as:</p>
<blockquote>
<div>1 - 0.07 * wind.get_value(model_time)</div></blockquote>
<p>where wind.get_value(model_time) is value of wind at model_time</p>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Kwargs passed onto base class:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> (<em>str</em>) &#8211; name of object</li>
<li><strong>on</strong> (<em>bool</em>) &#8211; whether object is on or not for the run</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="gnome.weatherers.Burn.prepare_for_model_run">
<code class="descname">prepare_for_model_run</code><span class="sig-paren">(</span><em>sc</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/weatherers/cleanup.html#Burn.prepare_for_model_run"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.weatherers.Burn.prepare_for_model_run" title="Permalink to this definition">¶</a></dt>
<dd><p>resets internal _oilwater_thickness variable to initial thickness
specified by user and active_stop to &#8216;inf&#8217; again.
initializes sc.weathering_data[&#8216;burned&#8217;] = 0.0</p>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.Burn.prepare_for_model_step">
<code class="descname">prepare_for_model_step</code><span class="sig-paren">(</span><em>sc</em>, <em>time_step</em>, <em>model_time</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/weatherers/cleanup.html#Burn.prepare_for_model_step"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.weatherers.Burn.prepare_for_model_step" title="Permalink to this definition">¶</a></dt>
<dd><ol class="arabic simple">
<li>set &#8216;active&#8217; flag based on active_start, and model_time</li>
<li>Mark LEs to be burned - do them in order right now. Assume all LEs
that are released together will be burned together since they would
be closer to each other in position.
Assumes: there is more mass in water than amount of mass to be
skimmed. The LEs marked for Burning are marked only once -
during the very first step that the object becomes active</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.Burn.weather_elements">
<code class="descname">weather_elements</code><span class="sig-paren">(</span><em>sc</em>, <em>time_step</em>, <em>model_time</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/weatherers/cleanup.html#Burn.weather_elements"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.weatherers.Burn.weather_elements" title="Permalink to this definition">¶</a></dt>
<dd><ol class="arabic simple">
<li>figure out the mass to remove for current timestep based on rate and
efficiency. Find fraction of total mass and remove equally from all
&#8216;mass_components&#8217; of LEs marked for burning.</li>
<li>update &#8216;mass&#8217; array and the amount burned in weathering_data dict</li>
<li>append to _burn_duration for each timestep</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.Burn.serialize">
<code class="descname">serialize</code><span class="sig-paren">(</span><em>json_='webapi'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/weatherers/cleanup.html#Burn.serialize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.weatherers.Burn.serialize" title="Permalink to this definition">¶</a></dt>
<dd><p>&#8216;wind&#8217;/&#8217;waves&#8217; property is saved as references in save file
need to add serialized object for &#8216;webapi&#8217;. Burn could have &#8216;wind&#8217; and
ChemicalDispersion could have &#8216;waves&#8217;.</p>
</dd></dl>

<dl class="classmethod">
<dt id="gnome.weatherers.Burn.deserialize">
<em class="property">classmethod </em><code class="descname">deserialize</code><span class="sig-paren">(</span><em>json_</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/weatherers/cleanup.html#Burn.deserialize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.weatherers.Burn.deserialize" title="Permalink to this definition">¶</a></dt>
<dd><p>append correct schema for wind object</p>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.Burn.attr_to_dict">
<code class="descname">attr_to_dict</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.weatherers.Burn.attr_to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>refactor to_dict&#8217;s functionality so child classes can convert a
single attribute to_dict instead of doing a whole list of fields</p>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.Burn.datetime_to_seconds">
<code class="descname">datetime_to_seconds</code><span class="sig-paren">(</span><em>model_time</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.weatherers.Burn.datetime_to_seconds" title="Permalink to this definition">¶</a></dt>
<dd><p>Put the time conversion call here - in case we decide to change it, it
only updates here</p>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.Burn.deserialize_oc">
<code class="descname">deserialize_oc</code><span class="sig-paren">(</span><em>json_</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.weatherers.Burn.deserialize_oc" title="Permalink to this definition">¶</a></dt>
<dd><p>check contents of orderered collections to figure out what schema to
use.
Basically, the json serialized ordered collection looks like a regular
list.</p>
</dd></dl>

<dl class="attribute">
<dt id="gnome.weatherers.Burn.id">
<code class="descname">id</code><a class="headerlink" href="#gnome.weatherers.Burn.id" title="Permalink to this definition">¶</a></dt>
<dd><p>Override this method for more exotic forms of identification.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a unique ID assigned during construction</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.Burn.is_sparse">
<code class="descname">is_sparse</code><span class="sig-paren">(</span><em>json_</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.weatherers.Burn.is_sparse" title="Permalink to this definition">¶</a></dt>
<dd><p>Sparse means that we have a previously created object,
and we are receiving a reference to the object using just
an obj_type and an id.  This is a valid payload that the
Web Client will send.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.Burn.loads">
<code class="descname">loads</code><span class="sig-paren">(</span><em>json_data</em>, <em>saveloc=None</em>, <em>references=None</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.weatherers.Burn.loads" title="Permalink to this definition">¶</a></dt>
<dd><p>loads object from json_data</p>
<ul class="simple">
<li>load json for references from files</li>
<li>update paths of datafiles if needed</li>
<li>deserialize json_data</li>
<li>and create object with new_from_dict()</li>
</ul>
<dl class="docutils">
<dt>json_data: dict containing json data. It has been parsed through the</dt>
<dd>json.loads() command. The json will be valided here when it gets
deserialized. Its references and datafile paths will be recreated
here prior to calling new_from_dict()</dd>
</dl>
<p>Optional parameter</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>saveloc</strong> &#8211; location of data files or <a href="#id41"><span class="problematic" id="id42">*</span></a>.json files for objects
stored as references. If object requires no datafiles and does not
need to read references from a <a href="#id43"><span class="problematic" id="id44">*</span></a>.json file in saveloc, then this
can be None.</li>
<li><strong>references</strong> &#8211; references object - if this is called by the Model,
it will pass a references object. It is not required.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">object constructed from json_data.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="gnome.weatherers.Burn.logger">
<code class="descname">logger</code><a class="headerlink" href="#gnome.weatherers.Burn.logger" title="Permalink to this definition">¶</a></dt>
<dd><p>define attribute &#8216;_log&#8217;. If it doesn&#8217;t exist, define it here.
This is so we don&#8217;t have to add it to all PyGnome classes - this
property makes the logger available to each object.
- default log_level is INFO</p>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.Burn.model_step_is_done">
<code class="descname">model_step_is_done</code><span class="sig-paren">(</span><em>sc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.weatherers.Burn.model_step_is_done" title="Permalink to this definition">¶</a></dt>
<dd><p>This method gets called by the model when after everything else is done
in a time step. Put any code need for clean-up, etc in here in
subclassed movers.</p>
</dd></dl>

<dl class="attribute">
<dt id="gnome.weatherers.Burn.name">
<code class="descname">name</code><a class="headerlink" href="#gnome.weatherers.Burn.name" title="Permalink to this definition">¶</a></dt>
<dd><p>define as property in base class so all objects will have a name
by default</p>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.Burn.new_from_dict">
<code class="descname">new_from_dict</code><span class="sig-paren">(</span><em>dict_</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.weatherers.Burn.new_from_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>creates a new object from dictionary</p>
<p>This is base implementation and can be over-ridden by classes using
this mixin</p>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.Burn.obj_type_to_dict">
<code class="descname">obj_type_to_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gnome.weatherers.Burn.obj_type_to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>returns object type to save in dict.
This is base implementation and can be over-ridden</p>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.Burn.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>saveloc</em>, <em>references=None</em>, <em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.weatherers.Burn.save" title="Permalink to this definition">¶</a></dt>
<dd><p>save object state as json to user specified saveloc</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>saveloc</strong> (<em>A path as a string or unicode</em>) &#8211; zip archive or a valid directory. Model files are
either persisted here or a new model is re-created from the files
stored here. The files are clobbered when save() is called.</li>
<li><strong>name=None</strong> &#8211; filename to store json. If None, default name is:
&#8220;{0}.json&#8221;.format(self.__class__.__name__). If saveloc is zipfile,
this is the name of archive in which json for self is stored.</li>
<li><strong>references</strong> &#8211; dict of references mapping &#8216;id&#8217; to a string used for
the reference. The value could be a unique integer or it could be
a filename. It is upto the creator of the reference list to decide
how to reference a nested object.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.Burn.serialize_oc">
<code class="descname">serialize_oc</code><span class="sig-paren">(</span><em>coll</em>, <em>json_='webapi'</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.weatherers.Burn.serialize_oc" title="Permalink to this definition">¶</a></dt>
<dd><p>Serialize Model attributes of type ordered collection or list - an
iterable containing serializable objects</p>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.Burn.to_dict">
<code class="descname">to_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gnome.weatherers.Burn.to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>returns a dictionary containing the serialized representation of this
object.</p>
<p>For every field, if there is a method defined on the object such that
the method name is <cite>{field_name}_to_dict</cite>, use the return value of that
method as the field value.</p>
<p>Note: any field in <cite>list</cite> that does not exist on the
object and does not have a to_dict method will raise an AttributeError.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>json_='webapi'</strong> &#8211; return the attributes for json payload for
webapi.
The other option is &#8216;save&#8217; corresponding with
json for save files.</td>
</tr>
</tbody>
</table>
<p>NOTE: add the json_=&#8217;webapi&#8217; key to be serialized so we know what the
serialization is for</p>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.Burn.to_serialize">
<code class="descname">to_serialize</code><span class="sig-paren">(</span><em>json_='webapi'</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.weatherers.Burn.to_serialize" title="Permalink to this definition">¶</a></dt>
<dd><p>invoke to_dict() which converts all attributes defined in _state to
dict. If json_=&#8217;save&#8217;, it subselects the Fields with save=True. If
json_=&#8217;webapi&#8217;, it subselects Fields with (update=True, read=True)</p>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.Burn.update_attr">
<code class="descname">update_attr</code><span class="sig-paren">(</span><em>name</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.weatherers.Burn.update_attr" title="Permalink to this definition">¶</a></dt>
<dd><p>update the attribute defined by &#8216;name&#8217; with given &#8216;value&#8217;</p>
<p>If there is a method defined on the object such that the method name is
<cite>{name}_from_dict</cite>, call that method with the field&#8217;s data.</p>
<p>If neither method exists, then set the field with the value from
<code class="docutils literal"><span class="pre">data</span></code> directly on the object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> (<em>str</em>) &#8211; name of attribute to be updated</li>
<li><strong>value</strong> (<em>depends on each attribute being updated</em>) &#8211; the new value of the attribute</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.Burn.validate">
<code class="descname">validate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gnome.weatherers.Burn.validate" title="Permalink to this definition">¶</a></dt>
<dd><p>All pygnome objects should be able to validate themselves. Many
py_gnome objects reference other objects like wind, water, waves. These
may not be defined when object is created so they can be None at
construction time; however, they should reference valid objects
when running model. If make_default_refs is True, then object isvalid
because model will set these up at runtime. To raise exception
for missing references at runtime, directly call
validate_refs(level=&#8217;error&#8217;)</p>
<p>&#8216;wind&#8217;, &#8216;water&#8217;, &#8216;waves&#8217; attributes also have special meaning. An
object containing this attribute references the corresponding object.</p>
<p>Logs warnings
:returns: a tuple of length two containing:</p>
<blockquote>
<div>(a list of messages that were logged, isvalid bool)
If any references are missing and make_default_refs is False,
object is not valid</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.Burn.validate_refs">
<code class="descname">validate_refs</code><span class="sig-paren">(</span><em>refs=['wind', 'water', 'waves']</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.weatherers.Burn.validate_refs" title="Permalink to this definition">¶</a></dt>
<dd><p>level is the logging level to use for messages. Default is &#8216;warning&#8217;
but if called from prepare_for_model_run, we want to use error and
raise exception.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-gnome.environment">
<span id="gnome-environment-pygnome-environment-classes"></span><h2><code class="docutils literal"><span class="pre">gnome.environment</span></code> &#8211; PyGnome environment classes<a class="headerlink" href="#module-gnome.environment" title="Permalink to this headline">¶</a></h2>
<p>environment module</p>
<dl class="class">
<dt id="gnome.environment.Tide">
<em class="property">class </em><code class="descclassname">gnome.environment.</code><code class="descname">Tide</code><span class="sig-paren">(</span><em>filename</em>, <em>yeardata='/Users/jasmine.sandhu/Documents/projects/GNOME2_github/py_gnome/gnome/data/yeardata'</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/environment/tide.html#Tide"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.environment.Tide" title="Permalink to this definition">¶</a></dt>
<dd><p>todo: baseclass called ScaleTimeseries (or something like that)
ScaleCurrent
Define the tide for a spill</p>
<p>Currently, this internally defines and uses the CyShioTime object, which is
a cython wrapper around the C++ Shio object</p>
<p>Tide information can be obtained from a filename or set as a
timeseries (timeseries is NOT TESTED YET)</p>
<p>It requires one of the following to initialize:</p>
<blockquote>
<div><ol class="arabic simple">
<li>&#8216;timeseries&#8217; assumed to be in &#8216;uv&#8217; format
(NOT TESTED/IMPLEMENTED OR USED YET)</li>
<li>a &#8216;filename&#8217; containing a header that defines units amongst
other meta data</li>
</ol>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>timeseries</strong> (<em>numpy.ndarray with dtype=datetime_value_1d</em>) &#8211; numpy array containing tide data</li>
<li><strong>units</strong> &#8211; units associated with the timeseries data. If &#8216;filename&#8217;
is given, then units are read in from the filename.
unit_conversion - NOT IMPLEMENTED YET</li>
<li><strong>filename</strong> &#8211; path to a long wind filename from which to read
wind data</li>
<li><strong>yeardata='gnome/data/yeardata/'</strong> &#8211; path to yeardata used for Shio
data.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="gnome.environment.Tide.name">
<code class="descname">name</code><a class="headerlink" href="#gnome.environment.Tide.name" title="Permalink to this definition">¶</a></dt>
<dd><p>define as property in base class so all objects will have a name
by default</p>
</dd></dl>

<dl class="method">
<dt id="gnome.environment.Tide.attr_to_dict">
<code class="descname">attr_to_dict</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.environment.Tide.attr_to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>refactor to_dict&#8217;s functionality so child classes can convert a
single attribute to_dict instead of doing a whole list of fields</p>
</dd></dl>

<dl class="method">
<dt id="gnome.environment.Tide.deserialize">
<code class="descname">deserialize</code><span class="sig-paren">(</span><em>json_</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.environment.Tide.deserialize" title="Permalink to this definition">¶</a></dt>
<dd><p>classmethod takes json structure as input, deserializes it using a
colander schema then invokes the new_from_dict method to create an
instance of the object described by the json schema.</p>
<p>We also need to accept sparse json objects, in which case we will
not treat them, but just send them back.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.environment.Tide.deserialize_oc">
<code class="descname">deserialize_oc</code><span class="sig-paren">(</span><em>json_</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.environment.Tide.deserialize_oc" title="Permalink to this definition">¶</a></dt>
<dd><p>check contents of orderered collections to figure out what schema to
use.
Basically, the json serialized ordered collection looks like a regular
list.</p>
</dd></dl>

<dl class="attribute">
<dt id="gnome.environment.Tide.id">
<code class="descname">id</code><a class="headerlink" href="#gnome.environment.Tide.id" title="Permalink to this definition">¶</a></dt>
<dd><p>Override this method for more exotic forms of identification.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a unique ID assigned during construction</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.environment.Tide.is_sparse">
<code class="descname">is_sparse</code><span class="sig-paren">(</span><em>json_</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.environment.Tide.is_sparse" title="Permalink to this definition">¶</a></dt>
<dd><p>Sparse means that we have a previously created object,
and we are receiving a reference to the object using just
an obj_type and an id.  This is a valid payload that the
Web Client will send.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.environment.Tide.loads">
<code class="descname">loads</code><span class="sig-paren">(</span><em>json_data</em>, <em>saveloc=None</em>, <em>references=None</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.environment.Tide.loads" title="Permalink to this definition">¶</a></dt>
<dd><p>loads object from json_data</p>
<ul class="simple">
<li>load json for references from files</li>
<li>update paths of datafiles if needed</li>
<li>deserialize json_data</li>
<li>and create object with new_from_dict()</li>
</ul>
<dl class="docutils">
<dt>json_data: dict containing json data. It has been parsed through the</dt>
<dd>json.loads() command. The json will be valided here when it gets
deserialized. Its references and datafile paths will be recreated
here prior to calling new_from_dict()</dd>
</dl>
<p>Optional parameter</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>saveloc</strong> &#8211; location of data files or <a href="#id45"><span class="problematic" id="id46">*</span></a>.json files for objects
stored as references. If object requires no datafiles and does not
need to read references from a <a href="#id47"><span class="problematic" id="id48">*</span></a>.json file in saveloc, then this
can be None.</li>
<li><strong>references</strong> &#8211; references object - if this is called by the Model,
it will pass a references object. It is not required.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">object constructed from json_data.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="gnome.environment.Tide.logger">
<code class="descname">logger</code><a class="headerlink" href="#gnome.environment.Tide.logger" title="Permalink to this definition">¶</a></dt>
<dd><p>define attribute &#8216;_log&#8217;. If it doesn&#8217;t exist, define it here.
This is so we don&#8217;t have to add it to all PyGnome classes - this
property makes the logger available to each object.
- default log_level is INFO</p>
</dd></dl>

<dl class="method">
<dt id="gnome.environment.Tide.new_from_dict">
<code class="descname">new_from_dict</code><span class="sig-paren">(</span><em>dict_</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.environment.Tide.new_from_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>creates a new object from dictionary</p>
<p>This is base implementation and can be over-ridden by classes using
this mixin</p>
</dd></dl>

<dl class="method">
<dt id="gnome.environment.Tide.obj_type_to_dict">
<code class="descname">obj_type_to_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gnome.environment.Tide.obj_type_to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>returns object type to save in dict.
This is base implementation and can be over-ridden</p>
</dd></dl>

<dl class="method">
<dt id="gnome.environment.Tide.prepare_for_model_run">
<code class="descname">prepare_for_model_run</code><span class="sig-paren">(</span><em>model_time</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.environment.Tide.prepare_for_model_run" title="Permalink to this definition">¶</a></dt>
<dd><p>Override this method if a derived environment class needs to perform any
actions prior to a model run</p>
</dd></dl>

<dl class="method">
<dt id="gnome.environment.Tide.prepare_for_model_step">
<code class="descname">prepare_for_model_step</code><span class="sig-paren">(</span><em>model_time</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.environment.Tide.prepare_for_model_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Override this method if a derived environment class needs to perform any
actions prior to a model run</p>
</dd></dl>

<dl class="method">
<dt id="gnome.environment.Tide.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>saveloc</em>, <em>references=None</em>, <em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.environment.Tide.save" title="Permalink to this definition">¶</a></dt>
<dd><p>save object state as json to user specified saveloc</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>saveloc</strong> (<em>A path as a string or unicode</em>) &#8211; zip archive or a valid directory. Model files are
either persisted here or a new model is re-created from the files
stored here. The files are clobbered when save() is called.</li>
<li><strong>name=None</strong> &#8211; filename to store json. If None, default name is:
&#8220;{0}.json&#8221;.format(self.__class__.__name__). If saveloc is zipfile,
this is the name of archive in which json for self is stored.</li>
<li><strong>references</strong> &#8211; dict of references mapping &#8216;id&#8217; to a string used for
the reference. The value could be a unique integer or it could be
a filename. It is upto the creator of the reference list to decide
how to reference a nested object.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.environment.Tide.serialize_oc">
<code class="descname">serialize_oc</code><span class="sig-paren">(</span><em>coll</em>, <em>json_='webapi'</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.environment.Tide.serialize_oc" title="Permalink to this definition">¶</a></dt>
<dd><p>Serialize Model attributes of type ordered collection or list - an
iterable containing serializable objects</p>
</dd></dl>

<dl class="method">
<dt id="gnome.environment.Tide.to_dict">
<code class="descname">to_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gnome.environment.Tide.to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>returns a dictionary containing the serialized representation of this
object.</p>
<p>For every field, if there is a method defined on the object such that
the method name is <cite>{field_name}_to_dict</cite>, use the return value of that
method as the field value.</p>
<p>Note: any field in <cite>list</cite> that does not exist on the
object and does not have a to_dict method will raise an AttributeError.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>json_='webapi'</strong> &#8211; return the attributes for json payload for
webapi.
The other option is &#8216;save&#8217; corresponding with
json for save files.</td>
</tr>
</tbody>
</table>
<p>NOTE: add the json_=&#8217;webapi&#8217; key to be serialized so we know what the
serialization is for</p>
</dd></dl>

<dl class="method">
<dt id="gnome.environment.Tide.to_serialize">
<code class="descname">to_serialize</code><span class="sig-paren">(</span><em>json_='webapi'</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.environment.Tide.to_serialize" title="Permalink to this definition">¶</a></dt>
<dd><p>invoke to_dict() which converts all attributes defined in _state to
dict. If json_=&#8217;save&#8217;, it subselects the Fields with save=True. If
json_=&#8217;webapi&#8217;, it subselects Fields with (update=True, read=True)</p>
</dd></dl>

<dl class="method">
<dt id="gnome.environment.Tide.update_attr">
<code class="descname">update_attr</code><span class="sig-paren">(</span><em>name</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.environment.Tide.update_attr" title="Permalink to this definition">¶</a></dt>
<dd><p>update the attribute defined by &#8216;name&#8217; with given &#8216;value&#8217;</p>
<p>If there is a method defined on the object such that the method name is
<cite>{name}_from_dict</cite>, call that method with the field&#8217;s data.</p>
<p>If neither method exists, then set the field with the value from
<code class="docutils literal"><span class="pre">data</span></code> directly on the object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> (<em>str</em>) &#8211; name of attribute to be updated</li>
<li><strong>value</strong> (<em>depends on each attribute being updated</em>) &#8211; the new value of the attribute</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.environment.Tide.update_from_dict">
<code class="descname">update_from_dict</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.environment.Tide.update_from_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the attributes of this object using the dictionary <code class="docutils literal"><span class="pre">data</span></code> by
looking up the value of each key in <code class="docutils literal"><span class="pre">data</span></code>.
The fields in self._state that have update=True are modified. The
remaining keys in &#8216;data&#8217; are ignored. The object&#8217;s _state attribute
defines what fields can be updated</p>
<p>If an attribute has changed, then call &#8216;update_attr&#8217; to update its
value.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>data</strong> (<em>dict</em>) &#8211; dict containing state of object per the client</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">True if something changed, False otherwise</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">bool</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Does not do updates on nested objects. If the attribute references
another Serializable object, then the value is not a dict but
rather the updated object. For instance, WindMover will receive:</p>
<blockquote>
<div>{..., &#8216;wind&#8217;: &lt;Wind object&gt;}</div></blockquote>
<p class="last">as opposed to a nested dict of the &#8216;wind&#8217; object. It is expected
that the &#8216;wind&#8217; object was updated by calling its own
update_from_dict then added to this dict as the updated object.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="gnome.environment.Tide.validate">
<code class="descname">validate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gnome.environment.Tide.validate" title="Permalink to this definition">¶</a></dt>
<dd><p>All pygnome objects should be able to validate themselves. Many
py_gnome objects reference other objects like wind, water, waves. These
may not be defined when object is created so they can be None at
construction time; however, they should reference valid objects
when running model. If make_default_refs is True, then object isvalid
because model will set these up at runtime. To raise exception
for missing references at runtime, directly call
validate_refs(level=&#8217;error&#8217;)</p>
<p>&#8216;wind&#8217;, &#8216;water&#8217;, &#8216;waves&#8217; attributes also have special meaning. An
object containing this attribute references the corresponding object.</p>
<p>Logs warnings
:returns: a tuple of length two containing:</p>
<blockquote>
<div>(a list of messages that were logged, isvalid bool)
If any references are missing and make_default_refs is False,
object is not valid</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="gnome.environment.Tide.validate_refs">
<code class="descname">validate_refs</code><span class="sig-paren">(</span><em>refs=['wind', 'water', 'waves']</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.environment.Tide.validate_refs" title="Permalink to this definition">¶</a></dt>
<dd><p>level is the logging level to use for messages. Default is &#8216;warning&#8217;
but if called from prepare_for_model_run, we want to use error and
raise exception.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.environment.Tide.serialize">
<code class="descname">serialize</code><span class="sig-paren">(</span><em>json_='webapi'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/environment/tide.html#Tide.serialize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.environment.Tide.serialize" title="Permalink to this definition">¶</a></dt>
<dd><p>For the filename - need to make it the full path before saving</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="gnome.environment.Wind">
<em class="property">class </em><code class="descclassname">gnome.environment.</code><code class="descname">Wind</code><span class="sig-paren">(</span><em>timeseries=None</em>, <em>units=None</em>, <em>filename=None</em>, <em>format='r-theta'</em>, <em>latitude=None</em>, <em>longitude=None</em>, <em>speed_uncertainty_scale=0.0</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/environment/wind.html#Wind"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.environment.Wind" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines the Wind conditions for a spill</p>
<p>todo: update docstrings!</p>
<dl class="attribute">
<dt id="gnome.environment.Wind.name">
<code class="descname">name</code><a class="headerlink" href="#gnome.environment.Wind.name" title="Permalink to this definition">¶</a></dt>
<dd><p>define as property in base class so all objects will have a name
by default</p>
</dd></dl>

<dl class="attribute">
<dt id="gnome.environment.Wind.timeseries">
<code class="descname">timeseries</code><a class="headerlink" href="#gnome.environment.Wind.timeseries" title="Permalink to this definition">¶</a></dt>
<dd><p>returns entire timeseries in &#8216;r-theta&#8217; format in the units in which
the data was entered or as specified by units attribute</p>
</dd></dl>

<dl class="method">
<dt id="gnome.environment.Wind.timeseries_to_dict">
<code class="descname">timeseries_to_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/environment/wind.html#Wind.timeseries_to_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.environment.Wind.timeseries_to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>when serializing data - round it to 2 decimal places</p>
</dd></dl>

<dl class="attribute">
<dt id="gnome.environment.Wind.units">
<code class="descname">units</code><a class="headerlink" href="#gnome.environment.Wind.units" title="Permalink to this definition">¶</a></dt>
<dd><p>define units in which wind data is input/output</p>
</dd></dl>

<dl class="method">
<dt id="gnome.environment.Wind.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>saveloc</em>, <em>references=None</em>, <em>name=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/environment/wind.html#Wind.save"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.environment.Wind.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Write Wind timeseries to file or to zip,
then call save method using super</p>
</dd></dl>

<dl class="method">
<dt id="gnome.environment.Wind.update_from_dict">
<code class="descname">update_from_dict</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/environment/wind.html#Wind.update_from_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.environment.Wind.update_from_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>update attributes from dict - override base class because we want to
set the units before updating the data so conversion is done correctly.
Internally all data is stored in SI units.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.environment.Wind.attr_to_dict">
<code class="descname">attr_to_dict</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.environment.Wind.attr_to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>refactor to_dict&#8217;s functionality so child classes can convert a
single attribute to_dict instead of doing a whole list of fields</p>
</dd></dl>

<dl class="method">
<dt id="gnome.environment.Wind.deserialize">
<code class="descname">deserialize</code><span class="sig-paren">(</span><em>json_</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.environment.Wind.deserialize" title="Permalink to this definition">¶</a></dt>
<dd><p>classmethod takes json structure as input, deserializes it using a
colander schema then invokes the new_from_dict method to create an
instance of the object described by the json schema.</p>
<p>We also need to accept sparse json objects, in which case we will
not treat them, but just send them back.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.environment.Wind.deserialize_oc">
<code class="descname">deserialize_oc</code><span class="sig-paren">(</span><em>json_</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.environment.Wind.deserialize_oc" title="Permalink to this definition">¶</a></dt>
<dd><p>check contents of orderered collections to figure out what schema to
use.
Basically, the json serialized ordered collection looks like a regular
list.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.environment.Wind.get_timeseries">
<code class="descname">get_timeseries</code><span class="sig-paren">(</span><em>datetime=None</em>, <em>format='uv'</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.environment.Wind.get_timeseries" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the timeseries in requested format. If datetime=None,
then the original timeseries that was entered is returned.
If datetime is a list containing datetime objects, then the value
for each of those date times is determined by the underlying
C++ object and the timeseries is returned.</p>
<p>The output format is defined by the strings &#8216;r-theta&#8217;, &#8216;uv&#8217;</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>datetime</strong> (<em>datetime object</em>) &#8211; [optional] datetime object or list of datetime
objects for which the value is desired</li>
<li><strong>format</strong> (<em>either string or integer value defined by
basic_types.ts_format.* (see cy_basic_types.pyx)</em>) &#8211; output format for the times series:
either &#8216;r-theta&#8217; or &#8216;uv&#8217;</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">numpy array containing dtype=basic_types.datetime_value_2d.
Contains user specified datetime and the corresponding
values in user specified ts_format</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.environment.Wind.get_wind_data">
<code class="descname">get_wind_data</code><span class="sig-paren">(</span><em>datetime=None</em>, <em>units=None</em>, <em>format='r-theta'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/environment/wind.html#Wind.get_wind_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.environment.Wind.get_wind_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the timeseries in the requested format. If datetime=None,
then the original timeseries that was entered is returned.
If datetime is a list containing datetime objects, then the value
for each of those date times is determined by the underlying
C++ object and the timeseries is returned.</p>
<p>The output format is defined by the strings &#8216;r-theta&#8217;, &#8216;uv&#8217;</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>datetime</strong> (<em>datetime object</em>) &#8211; [optional] datetime object or list of datetime
objects for which the value is desired</li>
<li><strong>units</strong> (<em>string. Uses the unit_conversion module.</em>) &#8211; [optional] outputs data in these units. Default is to
output data without unit conversion</li>
<li><strong>format</strong> (<em>either string or integer value defined by
basic_types.ts_format.* (see cy_basic_types.pyx)</em>) &#8211; output format for the times series:
either &#8216;r-theta&#8217; or &#8216;uv&#8217;</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">numpy array containing dtype=basic_types.datetime_value_2d.
Contains user specified datetime and the corresponding
values in user specified ts_format</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Invokes self._convert_units() to do the unit conversion.
Override this method to define the derived object&#8217;s unit conversion
functionality</p>
</div>
<p>todo: return data in appropriate significant digits</p>
</dd></dl>

<dl class="attribute">
<dt id="gnome.environment.Wind.id">
<code class="descname">id</code><a class="headerlink" href="#gnome.environment.Wind.id" title="Permalink to this definition">¶</a></dt>
<dd><p>Override this method for more exotic forms of identification.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a unique ID assigned during construction</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.environment.Wind.is_sparse">
<code class="descname">is_sparse</code><span class="sig-paren">(</span><em>json_</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.environment.Wind.is_sparse" title="Permalink to this definition">¶</a></dt>
<dd><p>Sparse means that we have a previously created object,
and we are receiving a reference to the object using just
an obj_type and an id.  This is a valid payload that the
Web Client will send.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.environment.Wind.loads">
<code class="descname">loads</code><span class="sig-paren">(</span><em>json_data</em>, <em>saveloc=None</em>, <em>references=None</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.environment.Wind.loads" title="Permalink to this definition">¶</a></dt>
<dd><p>loads object from json_data</p>
<ul class="simple">
<li>load json for references from files</li>
<li>update paths of datafiles if needed</li>
<li>deserialize json_data</li>
<li>and create object with new_from_dict()</li>
</ul>
<dl class="docutils">
<dt>json_data: dict containing json data. It has been parsed through the</dt>
<dd>json.loads() command. The json will be valided here when it gets
deserialized. Its references and datafile paths will be recreated
here prior to calling new_from_dict()</dd>
</dl>
<p>Optional parameter</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>saveloc</strong> &#8211; location of data files or <a href="#id49"><span class="problematic" id="id50">*</span></a>.json files for objects
stored as references. If object requires no datafiles and does not
need to read references from a <a href="#id51"><span class="problematic" id="id52">*</span></a>.json file in saveloc, then this
can be None.</li>
<li><strong>references</strong> &#8211; references object - if this is called by the Model,
it will pass a references object. It is not required.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">object constructed from json_data.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="gnome.environment.Wind.logger">
<code class="descname">logger</code><a class="headerlink" href="#gnome.environment.Wind.logger" title="Permalink to this definition">¶</a></dt>
<dd><p>define attribute &#8216;_log&#8217;. If it doesn&#8217;t exist, define it here.
This is so we don&#8217;t have to add it to all PyGnome classes - this
property makes the logger available to each object.
- default log_level is INFO</p>
</dd></dl>

<dl class="method">
<dt id="gnome.environment.Wind.new_from_dict">
<code class="descname">new_from_dict</code><span class="sig-paren">(</span><em>dict_</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.environment.Wind.new_from_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>creates a new object from dictionary</p>
<p>This is base implementation and can be over-ridden by classes using
this mixin</p>
</dd></dl>

<dl class="method">
<dt id="gnome.environment.Wind.obj_type_to_dict">
<code class="descname">obj_type_to_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gnome.environment.Wind.obj_type_to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>returns object type to save in dict.
This is base implementation and can be over-ridden</p>
</dd></dl>

<dl class="method">
<dt id="gnome.environment.Wind.prepare_for_model_run">
<code class="descname">prepare_for_model_run</code><span class="sig-paren">(</span><em>model_time</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.environment.Wind.prepare_for_model_run" title="Permalink to this definition">¶</a></dt>
<dd><p>Override this method if a derived environment class needs to perform any
actions prior to a model run</p>
</dd></dl>

<dl class="method">
<dt id="gnome.environment.Wind.prepare_for_model_step">
<code class="descname">prepare_for_model_step</code><span class="sig-paren">(</span><em>model_time</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.environment.Wind.prepare_for_model_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Override this method if a derived environment class needs to perform any
actions prior to a model run</p>
</dd></dl>

<dl class="method">
<dt id="gnome.environment.Wind.serialize">
<code class="descname">serialize</code><span class="sig-paren">(</span><em>json_='webapi'</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.environment.Wind.serialize" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the dict returned by object&#8217;s to_dict method to valid json
format via colander schema</p>
<p>It uses the modules_dict defined in gnome.persist to find the correct
schema module.</p>
<ol class="arabic">
<li><dl class="first docutils">
<dt>adds &#8216;obj_type&#8217; field to _state for &#8216;save&#8217; attribute so it is</dt>
<dd><p class="first last">contained in serialized data. todo: check if this is needed</p>
</dd>
</dl>
</li>
<li><p class="first">do serialization and return json</p>
</li>
</ol>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>do</strong> &#8211; tells object where serialization is for update or for
creating a new object</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">json format of serialized data</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Note: creating a new object versus &#8216;update&#8217; or &#8216;read&#8217; has a different</dt>
<dd>set of fields for serialization so &#8216;do&#8217; is required.
todo: revisit this to see if it still makes sense to have different
attributes for different operations like &#8216;update&#8217;, &#8216;save&#8217;, &#8216;read&#8217;</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="gnome.environment.Wind.serialize_oc">
<code class="descname">serialize_oc</code><span class="sig-paren">(</span><em>coll</em>, <em>json_='webapi'</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.environment.Wind.serialize_oc" title="Permalink to this definition">¶</a></dt>
<dd><p>Serialize Model attributes of type ordered collection or list - an
iterable containing serializable objects</p>
</dd></dl>

<dl class="method">
<dt id="gnome.environment.Wind.set_timeseries">
<code class="descname">set_timeseries</code><span class="sig-paren">(</span><em>datetime_value_2d</em>, <em>format='uv'</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.environment.Wind.set_timeseries" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the timeseries to the new value given by a numpy array.  The
format for the input data defaults to
basic_types.format.magnitude_direction but can be changed by the user
Assumes timeseries is valid so _check_timeseries has been invoked
and any unit conversions are done. This function simply converts
datetime_value_2d to time_value_pair and updates the data in underlying
cython/C++ object</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>datetime_value_2d</strong> (<em>numpy array of dtype
basic_types.datetime_value_2d</em>) &#8211; timeseries of wind data defined in a
numpy array</li>
<li><strong>format</strong> (<em>either string or integer value defined by
basic_types.format.* (see cy_basic_types.pyx)</em>) &#8211; output format for the times series; as defined by
basic_types.format.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.environment.Wind.to_dict">
<code class="descname">to_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gnome.environment.Wind.to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>returns a dictionary containing the serialized representation of this
object.</p>
<p>For every field, if there is a method defined on the object such that
the method name is <cite>{field_name}_to_dict</cite>, use the return value of that
method as the field value.</p>
<p>Note: any field in <cite>list</cite> that does not exist on the
object and does not have a to_dict method will raise an AttributeError.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>json_='webapi'</strong> &#8211; return the attributes for json payload for
webapi.
The other option is &#8216;save&#8217; corresponding with
json for save files.</td>
</tr>
</tbody>
</table>
<p>NOTE: add the json_=&#8217;webapi&#8217; key to be serialized so we know what the
serialization is for</p>
</dd></dl>

<dl class="method">
<dt id="gnome.environment.Wind.to_serialize">
<code class="descname">to_serialize</code><span class="sig-paren">(</span><em>json_='webapi'</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.environment.Wind.to_serialize" title="Permalink to this definition">¶</a></dt>
<dd><p>invoke to_dict() which converts all attributes defined in _state to
dict. If json_=&#8217;save&#8217;, it subselects the Fields with save=True. If
json_=&#8217;webapi&#8217;, it subselects Fields with (update=True, read=True)</p>
</dd></dl>

<dl class="method">
<dt id="gnome.environment.Wind.update_attr">
<code class="descname">update_attr</code><span class="sig-paren">(</span><em>name</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.environment.Wind.update_attr" title="Permalink to this definition">¶</a></dt>
<dd><p>update the attribute defined by &#8216;name&#8217; with given &#8216;value&#8217;</p>
<p>If there is a method defined on the object such that the method name is
<cite>{name}_from_dict</cite>, call that method with the field&#8217;s data.</p>
<p>If neither method exists, then set the field with the value from
<code class="docutils literal"><span class="pre">data</span></code> directly on the object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> (<em>str</em>) &#8211; name of attribute to be updated</li>
<li><strong>value</strong> (<em>depends on each attribute being updated</em>) &#8211; the new value of the attribute</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.environment.Wind.validate_refs">
<code class="descname">validate_refs</code><span class="sig-paren">(</span><em>refs=['wind', 'water', 'waves']</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.environment.Wind.validate_refs" title="Permalink to this definition">¶</a></dt>
<dd><p>level is the logging level to use for messages. Default is &#8216;warning&#8217;
but if called from prepare_for_model_run, we want to use error and
raise exception.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.environment.Wind.set_wind_data">
<code class="descname">set_wind_data</code><span class="sig-paren">(</span><em>datetime_value_2d</em>, <em>units</em>, <em>format='r-theta'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/environment/wind.html#Wind.set_wind_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.environment.Wind.set_wind_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the timeseries of the Wind object to the new value given by
a numpy array.  The format for the input data defaults to
basic_types.format.magnitude_direction but can be changed by the user.
Units are also required with the data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>datetime_value_2d</strong> (<em>numpy array of dtype
basic_types.datetime_value_2d</em>) &#8211; timeseries of wind data defined in a
numpy array</li>
<li><strong>units</strong> &#8211; units associated with the data. Valid units defined in
Wind.valid_vel_units list</li>
<li><strong>format</strong> (<em>either string or integer value defined by
basic_types.format.* (see cy_basic_types.pyx)</em>) &#8211; output format for the times series; as defined by
basic_types.format.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.environment.Wind.get_value">
<code class="descname">get_value</code><span class="sig-paren">(</span><em>time</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/environment/wind.html#Wind.get_value"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.environment.Wind.get_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the value at specified time and location. Wind timeseries are
independent of location; however, a gridded datafile may require
location so this interface may get refactored if it needs to support
different types of wind data. It returns the data in SI units (m/s)
in &#8216;r-theta&#8217; format (speed, direction)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>time</strong> (<em>datetime object or sequence of datetime objects.</em>) &#8211; the time(s) you want the data for</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">It invokes get_wind_data(..) function</p>
</div>
</dd></dl>

<dl class="method">
<dt id="gnome.environment.Wind.set_speed_uncertainty">
<code class="descname">set_speed_uncertainty</code><span class="sig-paren">(</span><em>up_or_down=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/environment/wind.html#Wind.set_speed_uncertainty"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.environment.Wind.set_speed_uncertainty" title="Permalink to this definition">¶</a></dt>
<dd><p>This function shifts the wind speed values in our time series
based on a single parameter Rayleigh distribution method,
and scaled by a value in the range [0.0 ... 0.5].
This range represents a plus-or-minus percent of uncertainty that
the distribution function should calculate</p>
<p>For each wind value in our time series:</p>
<ul class="simple">
<li>We assume it to be the average speed for that sample time</li>
<li>We calculate its respective Rayleigh distribution mode (sigma).</li>
<li>We determine either an upper percent uncertainty or a
lower percent uncertainty based on a passed in parameter.</li>
<li>Using the Rayleigh Quantile method and our calculated percent,
we determine the wind speed that is just at or above the
fractional area under the Probability distribution.</li>
<li>We assign the wind speed to its new calculated value.</li>
</ul>
<p>Since we are irreversibly changing the wind speed values,
we should probably do this only once.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.environment.Wind.validate">
<code class="descname">validate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/environment/wind.html#Wind.validate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.environment.Wind.validate" title="Permalink to this definition">¶</a></dt>
<dd><p>only issues warning - object is always valid</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-gnome.outputters">
<span id="gnome-outputter-pygnome-outputters-module"></span><h2><code class="docutils literal"><span class="pre">gnome.outputter</span></code> &#8211; PyGnome outputters module<a class="headerlink" href="#module-gnome.outputters" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-gnome.utilities.serializable">
<span id="gnome-utilities-pygnome-utilities-module"></span><h2><code class="docutils literal"><span class="pre">gnome.utilities</span></code> &#8211; PyGnome utilities module<a class="headerlink" href="#module-gnome.utilities.serializable" title="Permalink to this headline">¶</a></h2>
<p>Created on Feb 15, 2013</p>
<dl class="class">
<dt id="gnome.utilities.serializable.Field">
<em class="property">class </em><code class="descclassname">gnome.utilities.serializable.</code><code class="descname">Field</code><span class="sig-paren">(</span><em>name</em>, <em>isdatafile=False</em>, <em>update=False</em>, <em>save=False</em>, <em>read=False</em>, <em>save_reference=False</em>, <em>iscollection=False</em>, <em>test_for_eq=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/utilities/serializable.html#Field"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.utilities.serializable.Field" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Class containing information about the property to be serialized</p>
<p>Constructor for the Field object.
The Field object is used to describe the property of an object.
For instance, if a property is required to re-create the object from
a persisted _state, its &#8216;save&#8217; attribute is True.
If the property describes a data file that will need to be moved
when persisting the model, isdatafile should be True.
The gnome.persist.scenario module contains a Scenario class that loads
and saves a model. It looks for these attributes to correctly save/load
it.</p>
<p>It sets all attributes to False by default.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> (<em>str</em>) &#8211; Name of the property being described by this Field
object</li>
<li><strong>isdatafile=False</strong> (<em>bool</em>) &#8211; Is the property a datafile that should be
moved during persistence?</li>
<li><strong>update=False</strong> (<em>bool</em>) &#8211; Is the property update-able by the web app?</li>
<li><strong>create=False</strong> (<em>bool</em>) &#8211; Is the property required to re-create the
object when loading from a save file?</li>
<li><strong>read=False</strong> (<em>bool</em>) &#8211; If property is not updateable, perhaps make it
read only so web app has information about the object</li>
<li><strong>save_reference=False</strong> (<em>bool</em>) &#8211; <p>bool with default value of False.
if the property is object, you can either
serialize the object and store it as a nested structure or just
store a reference to the object. For instance, the WindMover
contains a Wind object and a Weatherer could also contain the
same wind object, in this case, the &#8216;wind&#8217; property should be
stored as a reference. The Model.load function is responsible for
hooking up the correct Wind object to the WindMover, Weatherer etc</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">save_reference currently is only used when the field is
stored with &#8216;save&#8217; flag.</p>
</div>
</li>
<li><strong>test_for_eq=True</strong> (<em>bool</em>) &#8211; bool with default value of True
when checking equality (__eq__()) of two gnome
objects that are serializable, look for equality of attributes
corresponding with fields with &#8216;save&#8217;=True and &#8216;test_for_eq&#8217;=True
For instance, if a gnome.model.Model() object is saved, then loaded
back from save file location, the filename attributes of objects
that read data from file will point to different location. The
objects are still equal. To avoid this problem, we can customize
whether to use a field when testing for equality or not.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="gnome.utilities.serializable.Serializable">
<em class="property">class </em><code class="descclassname">gnome.utilities.serializable.</code><code class="descname">Serializable</code><a class="reference internal" href="_modules/gnome/utilities/serializable.html#Serializable"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.utilities.serializable.Serializable" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">gnome.gnomeobject.GnomeId</span></code>, <code class="xref py py-class docutils literal"><span class="pre">gnome.persist.save_load.Savable</span></code></p>
<p>contains the to_dict and update_from_dict method to output properties of
object in a list.</p>
<p>This class is intended as a mixin so to_dict and update_from_dict become
part of the object and the object must define a _state attribute of type
State().</p>
<p>It mixes in the GnomeId class since all Serializable gnome objects will
have an Id as well</p>
<p>The default _state=State(save=[&#8216;id&#8217;]) is a static variable for this class
It uses the same convention as State to obtain the lists, &#8216;update&#8217; for
updating  properties, &#8216;read&#8217; for read-only properties and &#8216;save&#8217; for a
list of properties required to create new object.</p>
<p>The default _state contains &#8216;id&#8217; in the save list. This is because all
objects in a Model need &#8216;id&#8217; to create a new one.</p>
<p>Similarly, &#8216;obj_type&#8217; is required for all objects, this is so the scenario
module knows which object to create when loading from file.
A default implementation of obj_type_to_dict exists here.</p>
<p>Used obj_type instead of type because type is a builtin in python and
didn&#8217;t want to use the same name. The obj_type contains the type of the
object as a string.</p>
<dl class="classmethod">
<dt id="gnome.utilities.serializable.Serializable.new_from_dict">
<em class="property">classmethod </em><code class="descname">new_from_dict</code><span class="sig-paren">(</span><em>dict_</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/utilities/serializable.html#Serializable.new_from_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.utilities.serializable.Serializable.new_from_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>creates a new object from dictionary</p>
<p>This is base implementation and can be over-ridden by classes using
this mixin</p>
</dd></dl>

<dl class="method">
<dt id="gnome.utilities.serializable.Serializable.to_dict">
<code class="descname">to_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/utilities/serializable.html#Serializable.to_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.utilities.serializable.Serializable.to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>returns a dictionary containing the serialized representation of this
object.</p>
<p>For every field, if there is a method defined on the object such that
the method name is <cite>{field_name}_to_dict</cite>, use the return value of that
method as the field value.</p>
<p>Note: any field in <cite>list</cite> that does not exist on the
object and does not have a to_dict method will raise an AttributeError.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>json_='webapi'</strong> &#8211; return the attributes for json payload for
webapi.
The other option is &#8216;save&#8217; corresponding with
json for save files.</td>
</tr>
</tbody>
</table>
<p>NOTE: add the json_=&#8217;webapi&#8217; key to be serialized so we know what the
serialization is for</p>
</dd></dl>

<dl class="method">
<dt id="gnome.utilities.serializable.Serializable.attr_to_dict">
<code class="descname">attr_to_dict</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/utilities/serializable.html#Serializable.attr_to_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.utilities.serializable.Serializable.attr_to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>refactor to_dict&#8217;s functionality so child classes can convert a
single attribute to_dict instead of doing a whole list of fields</p>
</dd></dl>

<dl class="method">
<dt id="gnome.utilities.serializable.Serializable.update_from_dict">
<code class="descname">update_from_dict</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/utilities/serializable.html#Serializable.update_from_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.utilities.serializable.Serializable.update_from_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the attributes of this object using the dictionary <code class="docutils literal"><span class="pre">data</span></code> by
looking up the value of each key in <code class="docutils literal"><span class="pre">data</span></code>.
The fields in self._state that have update=True are modified. The
remaining keys in &#8216;data&#8217; are ignored. The object&#8217;s _state attribute
defines what fields can be updated</p>
<p>If an attribute has changed, then call &#8216;update_attr&#8217; to update its
value.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>data</strong> (<em>dict</em>) &#8211; dict containing state of object per the client</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">True if something changed, False otherwise</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">bool</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Does not do updates on nested objects. If the attribute references
another Serializable object, then the value is not a dict but
rather the updated object. For instance, WindMover will receive:</p>
<blockquote>
<div>{..., &#8216;wind&#8217;: &lt;Wind object&gt;}</div></blockquote>
<p class="last">as opposed to a nested dict of the &#8216;wind&#8217; object. It is expected
that the &#8216;wind&#8217; object was updated by calling its own
update_from_dict then added to this dict as the updated object.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="gnome.utilities.serializable.Serializable.update_attr">
<code class="descname">update_attr</code><span class="sig-paren">(</span><em>name</em>, <em>value</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/utilities/serializable.html#Serializable.update_attr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.utilities.serializable.Serializable.update_attr" title="Permalink to this definition">¶</a></dt>
<dd><p>update the attribute defined by &#8216;name&#8217; with given &#8216;value&#8217;</p>
<p>If there is a method defined on the object such that the method name is
<cite>{name}_from_dict</cite>, call that method with the field&#8217;s data.</p>
<p>If neither method exists, then set the field with the value from
<code class="docutils literal"><span class="pre">data</span></code> directly on the object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> (<em>str</em>) &#8211; name of attribute to be updated</li>
<li><strong>value</strong> (<em>depends on each attribute being updated</em>) &#8211; the new value of the attribute</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.utilities.serializable.Serializable.obj_type_to_dict">
<code class="descname">obj_type_to_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/utilities/serializable.html#Serializable.obj_type_to_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.utilities.serializable.Serializable.obj_type_to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>returns object type to save in dict.
This is base implementation and can be over-ridden</p>
</dd></dl>

<dl class="method">
<dt id="gnome.utilities.serializable.Serializable.to_serialize">
<code class="descname">to_serialize</code><span class="sig-paren">(</span><em>json_='webapi'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/utilities/serializable.html#Serializable.to_serialize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.utilities.serializable.Serializable.to_serialize" title="Permalink to this definition">¶</a></dt>
<dd><p>invoke to_dict() which converts all attributes defined in _state to
dict. If json_=&#8217;save&#8217;, it subselects the Fields with save=True. If
json_=&#8217;webapi&#8217;, it subselects Fields with (update=True, read=True)</p>
</dd></dl>

<dl class="method">
<dt id="gnome.utilities.serializable.Serializable.serialize">
<code class="descname">serialize</code><span class="sig-paren">(</span><em>json_='webapi'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/utilities/serializable.html#Serializable.serialize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.utilities.serializable.Serializable.serialize" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the dict returned by object&#8217;s to_dict method to valid json
format via colander schema</p>
<p>It uses the modules_dict defined in gnome.persist to find the correct
schema module.</p>
<ol class="arabic">
<li><dl class="first docutils">
<dt>adds &#8216;obj_type&#8217; field to _state for &#8216;save&#8217; attribute so it is</dt>
<dd><p class="first last">contained in serialized data. todo: check if this is needed</p>
</dd>
</dl>
</li>
<li><p class="first">do serialization and return json</p>
</li>
</ol>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>do</strong> &#8211; tells object where serialization is for update or for
creating a new object</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">json format of serialized data</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Note: creating a new object versus &#8216;update&#8217; or &#8216;read&#8217; has a different</dt>
<dd>set of fields for serialization so &#8216;do&#8217; is required.
todo: revisit this to see if it still makes sense to have different
attributes for different operations like &#8216;update&#8217;, &#8216;save&#8217;, &#8216;read&#8217;</dd>
</dl>
</dd></dl>

<dl class="classmethod">
<dt id="gnome.utilities.serializable.Serializable.is_sparse">
<em class="property">classmethod </em><code class="descname">is_sparse</code><span class="sig-paren">(</span><em>json_</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/utilities/serializable.html#Serializable.is_sparse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.utilities.serializable.Serializable.is_sparse" title="Permalink to this definition">¶</a></dt>
<dd><p>Sparse means that we have a previously created object,
and we are receiving a reference to the object using just
an obj_type and an id.  This is a valid payload that the
Web Client will send.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.utilities.serializable.Serializable.serialize_oc">
<code class="descname">serialize_oc</code><span class="sig-paren">(</span><em>coll</em>, <em>json_='webapi'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/utilities/serializable.html#Serializable.serialize_oc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.utilities.serializable.Serializable.serialize_oc" title="Permalink to this definition">¶</a></dt>
<dd><p>Serialize Model attributes of type ordered collection or list - an
iterable containing serializable objects</p>
</dd></dl>

<dl class="classmethod">
<dt id="gnome.utilities.serializable.Serializable.deserialize">
<em class="property">classmethod </em><code class="descname">deserialize</code><span class="sig-paren">(</span><em>json_</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/utilities/serializable.html#Serializable.deserialize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.utilities.serializable.Serializable.deserialize" title="Permalink to this definition">¶</a></dt>
<dd><p>classmethod takes json structure as input, deserializes it using a
colander schema then invokes the new_from_dict method to create an
instance of the object described by the json schema.</p>
<p>We also need to accept sparse json objects, in which case we will
not treat them, but just send them back.</p>
</dd></dl>

<dl class="classmethod">
<dt id="gnome.utilities.serializable.Serializable.deserialize_oc">
<em class="property">classmethod </em><code class="descname">deserialize_oc</code><span class="sig-paren">(</span><em>json_</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/utilities/serializable.html#Serializable.deserialize_oc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.utilities.serializable.Serializable.deserialize_oc" title="Permalink to this definition">¶</a></dt>
<dd><p>check contents of orderered collections to figure out what schema to
use.
Basically, the json serialized ordered collection looks like a regular
list.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-gnome.persist.base_schema">
<span id="gnome-persist-pygnome-persistance-classes"></span><h2><code class="docutils literal"><span class="pre">gnome.persist</span></code> &#8211; PyGnome persistance classes<a class="headerlink" href="#module-gnome.persist.base_schema" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="gnome.persist.base_schema.ObjType">
<em class="property">class </em><code class="descclassname">gnome.persist.base_schema.</code><code class="descname">ObjType</code><span class="sig-paren">(</span><em>*arg</em>, <em>**kw</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/persist/base_schema.html#ObjType"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.persist.base_schema.ObjType" title="Permalink to this definition">¶</a></dt>
<dd><p>defines the obj_type which is stored by all gnome objects when persisting
to save files
It also optionally stores the &#8216;id&#8217; if present</p>
</dd></dl>

<dl class="class">
<dt id="gnome.persist.base_schema.CollectionItemMap">
<em class="property">class </em><code class="descclassname">gnome.persist.base_schema.</code><code class="descname">CollectionItemMap</code><span class="sig-paren">(</span><em>*arg</em>, <em>**kw</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/persist/base_schema.html#CollectionItemMap"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.persist.base_schema.CollectionItemMap" title="Permalink to this definition">¶</a></dt>
<dd><p>This stores the obj_type and obj_index</p>
</dd></dl>

<dl class="class">
<dt id="gnome.persist.base_schema.LongLat">
<em class="property">class </em><code class="descclassname">gnome.persist.base_schema.</code><code class="descname">LongLat</code><span class="sig-paren">(</span><em>*arg</em>, <em>**kw</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/persist/base_schema.html#LongLat"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.persist.base_schema.LongLat" title="Permalink to this definition">¶</a></dt>
<dd><p>Only contains 2D (long, lat) positions</p>
</dd></dl>

<dl class="class">
<dt id="gnome.persist.base_schema.LongLatBounds">
<em class="property">class </em><code class="descclassname">gnome.persist.base_schema.</code><code class="descname">LongLatBounds</code><span class="sig-paren">(</span><em>*args</em>, <em>**kw</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/persist/base_schema.html#LongLatBounds"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.persist.base_schema.LongLatBounds" title="Permalink to this definition">¶</a></dt>
<dd><p>Used to define bounds on a map</p>
</dd></dl>

<dl class="class">
<dt id="gnome.persist.base_schema.WorldPoint">
<em class="property">class </em><code class="descclassname">gnome.persist.base_schema.</code><code class="descname">WorldPoint</code><span class="sig-paren">(</span><em>*arg</em>, <em>**kw</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/persist/base_schema.html#WorldPoint"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.persist.base_schema.WorldPoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Used to define reference points. 3D positions (long,lat,z)</p>
</dd></dl>

<dl class="class">
<dt id="gnome.persist.base_schema.WorldPointNumpy">
<em class="property">class </em><code class="descclassname">gnome.persist.base_schema.</code><code class="descname">WorldPointNumpy</code><span class="sig-paren">(</span><em>*arg</em>, <em>**kw</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/persist/base_schema.html#WorldPointNumpy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.persist.base_schema.WorldPointNumpy" title="Permalink to this definition">¶</a></dt>
<dd><p>Define same schema as WorldPoint; however, the base class NumpyFixedLenSchema
serializes/deserializes it from/to a numpy array</p>
</dd></dl>

<dl class="class">
<dt id="gnome.persist.base_schema.ImageSize">
<em class="property">class </em><code class="descclassname">gnome.persist.base_schema.</code><code class="descname">ImageSize</code><span class="sig-paren">(</span><em>*arg</em>, <em>**kw</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/persist/base_schema.html#ImageSize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.persist.base_schema.ImageSize" title="Permalink to this definition">¶</a></dt>
<dd><p>Only contains 2D (long, lat) positions</p>
</dd></dl>

<span class="target" id="module-gnome.persist.extend_colander"></span><p>Extend colander&#8217;s basic types for serialization/deserialization
of gnome specific types</p>
<dl class="class">
<dt id="gnome.persist.extend_colander.DefaultTuple">
<em class="property">class </em><code class="descclassname">gnome.persist.extend_colander.</code><code class="descname">DefaultTuple</code><a class="reference internal" href="_modules/gnome/persist/extend_colander.html#DefaultTuple"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.persist.extend_colander.DefaultTuple" title="Permalink to this definition">¶</a></dt>
<dd><p>A Tuple subclass that provides defaults from child nodes.</p>
<p>Required because Tuple returns <cite>colander.null</cite> by default
when <code class="docutils literal"><span class="pre">appstruct</span></code> is not provided, instead of creating a Tuple of
default values.</p>
</dd></dl>

<dl class="class">
<dt id="gnome.persist.extend_colander.NumpyFixedLen">
<em class="property">class </em><code class="descclassname">gnome.persist.extend_colander.</code><code class="descname">NumpyFixedLen</code><a class="reference internal" href="_modules/gnome/persist/extend_colander.html#NumpyFixedLen"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.persist.extend_colander.NumpyFixedLen" title="Permalink to this definition">¶</a></dt>
<dd><p>A subclass of <code class="xref py py-class docutils literal"><span class="pre">colander.Tuple</span></code> that converts itself to a Tuple and
back to a numpy array. This is used to define schemas for Numpy arrays that
have a fixed size like WorldPoint, 3D velocity of SimpleMover.</p>
</dd></dl>

<dl class="class">
<dt id="gnome.persist.extend_colander.NumpyArray">
<em class="property">class </em><code class="descclassname">gnome.persist.extend_colander.</code><code class="descname">NumpyArray</code><a class="reference internal" href="_modules/gnome/persist/extend_colander.html#NumpyArray"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.persist.extend_colander.NumpyArray" title="Permalink to this definition">¶</a></dt>
<dd><p>A subclass of <code class="xref py py-class docutils literal"><span class="pre">colander.List</span></code> that converts itself to a more general
numpy array of greater than length 1.</p>
</dd></dl>

<dl class="class">
<dt id="gnome.persist.extend_colander.DatetimeValue2dArray">
<em class="property">class </em><code class="descclassname">gnome.persist.extend_colander.</code><code class="descname">DatetimeValue2dArray</code><span class="sig-paren">(</span><em>accept_scalar=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/persist/extend_colander.html#DatetimeValue2dArray"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.persist.extend_colander.DatetimeValue2dArray" title="Permalink to this definition">¶</a></dt>
<dd><p>A subclass of <code class="xref py py-class docutils literal"><span class="pre">colander.Sequence</span></code> that converts itself to a numpy
array using <code class="xref py py-class docutils literal"><span class="pre">gnome.basic_types.datetime_value_2d</span></code> as the data type.</p>
<dl class="docutils">
<dt>todo: serialize/deserialize must happen for each element - not very</dt>
<dd>efficient.</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="gnome.persist.extend_colander.DatetimeValue1dArray">
<em class="property">class </em><code class="descclassname">gnome.persist.extend_colander.</code><code class="descname">DatetimeValue1dArray</code><span class="sig-paren">(</span><em>accept_scalar=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/persist/extend_colander.html#DatetimeValue1dArray"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.persist.extend_colander.DatetimeValue1dArray" title="Permalink to this definition">¶</a></dt>
<dd><p>A subclass of <code class="xref py py-class docutils literal"><span class="pre">colander.Sequence</span></code> that converts itself to a numpy
array using <code class="xref py py-class docutils literal"><span class="pre">gnome.basic_types.datetime_value_2d</span></code> as the data type.</p>
</dd></dl>

<dl class="class">
<dt id="gnome.persist.extend_colander.TimeDelta">
<em class="property">class </em><code class="descclassname">gnome.persist.extend_colander.</code><code class="descname">TimeDelta</code><a class="reference internal" href="_modules/gnome/persist/extend_colander.html#TimeDelta"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.persist.extend_colander.TimeDelta" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a type to serialize/deserialize timedelta objects</p>
</dd></dl>

<span class="target" id="module-gnome.persist.validators"></span><p>Created on Feb 26, 2013</p>
<p>Define general purpose functions that can used as validators</p>
<dl class="function">
<dt id="gnome.persist.validators.convertible_to_seconds">
<code class="descclassname">gnome.persist.validators.</code><code class="descname">convertible_to_seconds</code><span class="sig-paren">(</span><em>node</em>, <em>value</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/persist/validators.html#convertible_to_seconds"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.persist.validators.convertible_to_seconds" title="Permalink to this definition">¶</a></dt>
<dd><p>validate only datetime objects</p>
</dd></dl>

<dl class="function">
<dt id="gnome.persist.validators.no_duplicate_datetime">
<code class="descclassname">gnome.persist.validators.</code><code class="descname">no_duplicate_datetime</code><span class="sig-paren">(</span><em>node</em>, <em>values</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/persist/validators.html#no_duplicate_datetime"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.persist.validators.no_duplicate_datetime" title="Permalink to this definition">¶</a></dt>
<dd><p>Check for duplicate datetime values in numpy structured array like
datetime_value_2d
Reject <code class="docutils literal"><span class="pre">values</span></code> if it contains duplicates.</p>
</dd></dl>

<dl class="function">
<dt id="gnome.persist.validators.ascending_datetime">
<code class="descclassname">gnome.persist.validators.</code><code class="descname">ascending_datetime</code><span class="sig-paren">(</span><em>node</em>, <em>values</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/persist/validators.html#ascending_datetime"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.persist.validators.ascending_datetime" title="Permalink to this definition">¶</a></dt>
<dd><p>Check the datetime values in numpy structured array
(like datetime_value_2d)
are in ascending order</p>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">PyGnome Reference</a><ul>
<li><a class="reference internal" href="#basic-structure">Basic Structure</a></li>
<li><a class="reference internal" href="#class-reference">Class Reference:</a></li>
<li><a class="reference internal" href="#module-gnome.model"><code class="docutils literal"><span class="pre">gnome.model</span></code> &#8211; the PyGnome model class</a></li>
<li><a class="reference internal" href="#module-gnome.map"><code class="docutils literal"><span class="pre">gnome.map</span></code> &#8211; the PyGnome map class</a></li>
<li><a class="reference internal" href="#module-gnome.spill"><code class="docutils literal"><span class="pre">gnome.spill</span></code> &#8211; classes in the spill module</a></li>
<li><a class="reference internal" href="#module-gnome.spill.elements.element_type"><code class="docutils literal"><span class="pre">gnome.spill.elements</span></code> &#8211; classes in the elements module</a></li>
<li><a class="reference internal" href="#module-gnome.movers"><code class="docutils literal"><span class="pre">gnome.movers</span></code> &#8211; PyGnome mover classes</a></li>
<li><a class="reference internal" href="#module-gnome.weatherers"><code class="docutils literal"><span class="pre">gnome.weatherers</span></code> &#8211; PyGnome/Adios weathering/mass removal classes</a></li>
<li><a class="reference internal" href="#module-gnome.environment"><code class="docutils literal"><span class="pre">gnome.environment</span></code> &#8211; PyGnome environment classes</a></li>
<li><a class="reference internal" href="#module-gnome.outputters"><code class="docutils literal"><span class="pre">gnome.outputter</span></code> &#8211; PyGnome outputters module</a></li>
<li><a class="reference internal" href="#module-gnome.utilities.serializable"><code class="docutils literal"><span class="pre">gnome.utilities</span></code> &#8211; PyGnome utilities module</a></li>
<li><a class="reference internal" href="#module-gnome.persist.base_schema"><code class="docutils literal"><span class="pre">gnome.persist</span></code> &#8211; PyGnome persistance classes</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="tutorial_2.html"
                        title="previous chapter">CATS currents</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="units.html"
                        title="next chapter">Units used in GNOME / PyGNOME</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/reference.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="units.html" title="Units used in GNOME / PyGNOME"
             >next</a> |</li>
        <li class="right" >
          <a href="tutorial_2.html" title="CATS currents"
             >previous</a> |</li>
        <li><a href="index.html">pyGNOME 0.1.1 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2012, NOAA Emergecny Response Division.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3b1.
    </div>
  </body>
</html>