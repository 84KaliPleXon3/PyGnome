#!/usr/bin/env python
"""
This module holds classes and supporting code for simulating the vertical
plume that is generated by an underwater blowout.
"""

import numpy as np

import matplotlib
from matplotlib import pylab, mlab, pyplot
plt = pyplot

from pylab import *


from datetime import datetime, timedelta

from gnome.basic_types import world_point


def get_plume_data():
    '''
      Here we will generate plume data that conforms to that of Socolofsky's
      model.
      - We will represent the mass flux amounts in kg/s.
      - We will probably get these values from a running
        plume model, but for right now, we just return
        an array with some hardcoded values.
      - For now, we return data in the format [(depth, mass_flux), ...]
    '''
    plume_mass_flux = np.zeros((10))
    plume_mass_flux[:] = 5.  # background values.
    plume_mass_flux[3] = 15.  # and now a few spikes.
    plume_mass_flux[5] = 20.
    plume_mass_flux[7] = 30.

    plume_depths = np.linspace(0, 200, plume_mass_flux.size)

    return zip(plume_depths, plume_mass_flux)


class Plume(object):
    '''
      Here, we represent the characteristics of the plume
      as a set of mass fluxes along a vertical stack.
    '''
    def __init__(self,
                 lon, lat,
                 plume_data):
        self.mass_flux = np.array([d[1] for d in plume_data])
        num_points = self.mass_flux.size

        self.coords = np.zeros((num_points), dtype=world_point)
        self.coords[:]['long'] = lon
        self.coords[:]['lat'] = lat
        self.coords[:]['z'] = np.array([d[0] for d in plume_data])


class PlumeGenerator(object):
    '''
      Here we define the method for generating LEs from a 3D plume
      over a range of time.
    '''
    def __init__(self,
                 release_time, end_release_time, time_step_delta,
                 plume):
        self.release_time = release_time
        self.end_release_time = end_release_time
        self.time_step_delta = time_step_delta
        self.time_steps = int((end_release_time - release_time).total_seconds() / time_step_delta)

        self.plume = plume

        self.accum_mass = np.zeros_like(self.plume.mass_flux)

        # Here we just calculate a reasonable value for the mass
        # that is contained in a single LE.
        # This may not be a good assumption, as other things may be
        # determining the mass of an LE in the model.
        # But we can always change this after class initialization
        # if we need to.
        self.mass_of_an_le = self.plume.mass_flux.mean() * time_step_delta

    def set_le_mass_from_total_le_count(self, num_elements):
        # Calculate the mass of an LE if a total number of LEs
        # is spread across the total released mass.
        total_release_time = (end_release_time - release_time).total_seconds()
        total_mass = self.plume.mass_flux.sum() * total_release_time
        self.mass_of_an_le = total_mass / num_elements

    def _mass_to_elems(self, mass):
        '''
          Calculate mass into an equivalent number of LEs and return them.
          - We do not count the fractional amounts.
        '''
        return (mass / self.mass_of_an_le).astype(np.int32)

    def _elems_to_mass(self, elems):
        '''
          Calculate LEs into equivalent amounts of mass and return them.
        '''
        return elems * self.mass_of_an_le

    def _xfer_mass_to_elems(self):
        '''
          Transfer mass into an equivalent number of LEs and return them.
        '''
        tmp_elems = self._mass_to_elems(self.accum_mass)
        self.accum_mass -= self._elems_to_mass(tmp_elems)
    
        return tmp_elems

    def __iter__(self):
        self.accum_mass.fill(0.)
        for step in range(self.time_steps):
            self.accum_mass += self.plume.mass_flux * self.time_step_delta
            curr_step_time = self.release_time + timedelta(seconds=self.time_step_delta * step)
            yield (curr_step_time,
                   zip(self.plume.coords, self._xfer_mass_to_elems()))


if __name__ == '__main__':
    release_time = datetime.now()
    end_release_time = release_time + timedelta(hours=24)
    time_step_delta = timedelta(hours=1).total_seconds()

    plume = Plume(lon=10., lat=20.,
                  plume_data=get_plume_data())
    plume_gen = PlumeGenerator(release_time=release_time,
                               end_release_time=end_release_time,
                               time_step_delta=time_step_delta,
                               plume=plume)

    # let's print out some facts about our plume
    print '''
Based on the mean plume mass flux value,
we will choose an LE with %s kg of oil
''' % (plume_gen.mass_of_an_le)

    # now lets iterate our plume generator
    print 'First, just the occurrence pattern for LE releases...'
    for step in plume_gen:
        print step[0], [r[1] for r in step[1]]

    print '\nNext, the full information...'
    for step in plume_gen:
        for r in step:
            # each row should consist of a world_point
            # and a number of LEs to create
            print r
        print

    # I believe with our test data that the total LEs is 240
    # Lets change the total number of LEs and see how that affects our run.
    plume_gen.set_le_mass_from_total_le_count(200)
    print 'Now, the occurrence pattern if the total LEs is 200...'
    total_le_count = 0
    for step in plume_gen:
        le_count = sum([r[1] for r in step[1]])
        total_le_count += le_count
        print step[0], [r[1] for r in step[1]], le_count
    print 'total LEs:', total_le_count
    assert total_le_count == 200

    #
    # OK, that worked for 200 LEs, but there will be cases where an LE
    # did not show up in the output of a plume generation run.
    # I think we need to analyze how the actual number of LEs
    # might differ from the number of LEs that we are trying to specify.
    # And we need to run this test on some real plume data when we get it.
    #
    def compare_le_count(plume_generator, le_count):
        plume_generator.set_le_mass_from_total_le_count(le_count)
        return le_count, sum([sum([r[1] for r in step[1]]) for step in plume_generator])

    # To start with, we will compare the number of LEs we specified vs. the number
    # of LEs that we came up with after a run of our plume generator.  And we will
    # do this over a range of specified LE counts.
    le_counts = [compare_le_count(plume_gen, n) for n in range(100, 401)]
    print le_counts

    figure(num=10)
    plot([n[0] for n in le_counts], le_counts)
    title('Specified LEs vs. Resulting LEs')

    # Here we plot the difference in LEs that we had.
    # - I would expect there is a small chance where
    #   every one of our points missed an LE.  In this case
    #   we would be off by an amount equal to the number of points in our
    #   plume column.
    # - I would not expect any single point to miss more than one LE.
    #   Thus, I would not expect a number greater than the number of
    #   plume data points.
    # - For our test data, this maximum number is 10, and it
    #   occurs when we specify 260 LEs.
    figure(num=20)
    plot([n[0] for n in le_counts], [diff(i) for i in le_counts])
    xlabel('Number of LEs specified')
    ylabel('Diff in LEs')
    title('Specified LEs vs. Resulting LEs)')

    # OK the biggest deviation was about 8% when we specified 119 LEs, and
    # it tends to get smaller as we increase the specified LE count.
    figure(num=30)
    plot([n[0] for n in le_counts], [((np.float(i[0]) / np.float(i[1])) * 100) - 100. for i in le_counts])
    xlabel('Number of LEs specified')
    ylabel('Deviation (%)')
    title('Specified LEs vs. Resulting LEs')

    show()
    #plt.close('all')
